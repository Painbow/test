
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Car
 * 
 */
export type Car = $Result.DefaultSelection<Prisma.$CarPayload>
/**
 * Model Auction
 * 
 */
export type Auction = $Result.DefaultSelection<Prisma.$AuctionPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Orders
 * 
 */
export type Orders = $Result.DefaultSelection<Prisma.$OrdersPayload>
/**
 * Model SellingHistory
 * 
 */
export type SellingHistory = $Result.DefaultSelection<Prisma.$SellingHistoryPayload>
/**
 * Model BiddingHistory
 * 
 */
export type BiddingHistory = $Result.DefaultSelection<Prisma.$BiddingHistoryPayload>
/**
 * Model Request
 * 
 */
export type Request = $Result.DefaultSelection<Prisma.$RequestPayload>
/**
 * Model FAQ
 * 
 */
export type FAQ = $Result.DefaultSelection<Prisma.$FAQPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.car`: Exposes CRUD operations for the **Car** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cars
    * const cars = await prisma.car.findMany()
    * ```
    */
  get car(): Prisma.CarDelegate<ExtArgs>;

  /**
   * `prisma.auction`: Exposes CRUD operations for the **Auction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auctions
    * const auctions = await prisma.auction.findMany()
    * ```
    */
  get auction(): Prisma.AuctionDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs>;

  /**
   * `prisma.orders`: Exposes CRUD operations for the **Orders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.orders.findMany()
    * ```
    */
  get orders(): Prisma.OrdersDelegate<ExtArgs>;

  /**
   * `prisma.sellingHistory`: Exposes CRUD operations for the **SellingHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SellingHistories
    * const sellingHistories = await prisma.sellingHistory.findMany()
    * ```
    */
  get sellingHistory(): Prisma.SellingHistoryDelegate<ExtArgs>;

  /**
   * `prisma.biddingHistory`: Exposes CRUD operations for the **BiddingHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BiddingHistories
    * const biddingHistories = await prisma.biddingHistory.findMany()
    * ```
    */
  get biddingHistory(): Prisma.BiddingHistoryDelegate<ExtArgs>;

  /**
   * `prisma.request`: Exposes CRUD operations for the **Request** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Requests
    * const requests = await prisma.request.findMany()
    * ```
    */
  get request(): Prisma.RequestDelegate<ExtArgs>;

  /**
   * `prisma.fAQ`: Exposes CRUD operations for the **FAQ** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FAQS
    * const fAQS = await prisma.fAQ.findMany()
    * ```
    */
  get fAQ(): Prisma.FAQDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.4.2
   * Query Engine version: ac9d7041ed77bcc8a8dbd2ab6616b39013829574
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Account: 'Account',
    Car: 'Car',
    Auction: 'Auction',
    Comment: 'Comment',
    Orders: 'Orders',
    SellingHistory: 'SellingHistory',
    BiddingHistory: 'BiddingHistory',
    Request: 'Request',
    FAQ: 'FAQ'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'account' | 'car' | 'auction' | 'comment' | 'orders' | 'sellingHistory' | 'biddingHistory' | 'request' | 'fAQ'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>,
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Car: {
        payload: Prisma.$CarPayload<ExtArgs>
        fields: Prisma.CarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CarFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CarFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CarPayload>
          }
          findFirst: {
            args: Prisma.CarFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CarFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CarPayload>
          }
          findMany: {
            args: Prisma.CarFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CarPayload>[]
          }
          create: {
            args: Prisma.CarCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CarPayload>
          }
          createMany: {
            args: Prisma.CarCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CarDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CarPayload>
          }
          update: {
            args: Prisma.CarUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CarPayload>
          }
          deleteMany: {
            args: Prisma.CarDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CarUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CarUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CarPayload>
          }
          aggregate: {
            args: Prisma.CarAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCar>
          }
          groupBy: {
            args: Prisma.CarGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CarGroupByOutputType>[]
          }
          count: {
            args: Prisma.CarCountArgs<ExtArgs>,
            result: $Utils.Optional<CarCountAggregateOutputType> | number
          }
        }
      }
      Auction: {
        payload: Prisma.$AuctionPayload<ExtArgs>
        fields: Prisma.AuctionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuctionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuctionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuctionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuctionPayload>
          }
          findFirst: {
            args: Prisma.AuctionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuctionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuctionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuctionPayload>
          }
          findMany: {
            args: Prisma.AuctionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuctionPayload>[]
          }
          create: {
            args: Prisma.AuctionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuctionPayload>
          }
          createMany: {
            args: Prisma.AuctionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AuctionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuctionPayload>
          }
          update: {
            args: Prisma.AuctionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuctionPayload>
          }
          deleteMany: {
            args: Prisma.AuctionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AuctionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AuctionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AuctionPayload>
          }
          aggregate: {
            args: Prisma.AuctionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAuction>
          }
          groupBy: {
            args: Prisma.AuctionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AuctionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuctionCountArgs<ExtArgs>,
            result: $Utils.Optional<AuctionCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>,
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Orders: {
        payload: Prisma.$OrdersPayload<ExtArgs>
        fields: Prisma.OrdersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrdersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrdersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>
          }
          findFirst: {
            args: Prisma.OrdersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrdersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>
          }
          findMany: {
            args: Prisma.OrdersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>[]
          }
          create: {
            args: Prisma.OrdersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>
          }
          createMany: {
            args: Prisma.OrdersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OrdersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>
          }
          update: {
            args: Prisma.OrdersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>
          }
          deleteMany: {
            args: Prisma.OrdersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OrdersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OrdersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>
          }
          aggregate: {
            args: Prisma.OrdersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrders>
          }
          groupBy: {
            args: Prisma.OrdersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrdersGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrdersCountArgs<ExtArgs>,
            result: $Utils.Optional<OrdersCountAggregateOutputType> | number
          }
        }
      }
      SellingHistory: {
        payload: Prisma.$SellingHistoryPayload<ExtArgs>
        fields: Prisma.SellingHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SellingHistoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SellingHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SellingHistoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SellingHistoryPayload>
          }
          findFirst: {
            args: Prisma.SellingHistoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SellingHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SellingHistoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SellingHistoryPayload>
          }
          findMany: {
            args: Prisma.SellingHistoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SellingHistoryPayload>[]
          }
          create: {
            args: Prisma.SellingHistoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SellingHistoryPayload>
          }
          createMany: {
            args: Prisma.SellingHistoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SellingHistoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SellingHistoryPayload>
          }
          update: {
            args: Prisma.SellingHistoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SellingHistoryPayload>
          }
          deleteMany: {
            args: Prisma.SellingHistoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SellingHistoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SellingHistoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SellingHistoryPayload>
          }
          aggregate: {
            args: Prisma.SellingHistoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSellingHistory>
          }
          groupBy: {
            args: Prisma.SellingHistoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SellingHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SellingHistoryCountArgs<ExtArgs>,
            result: $Utils.Optional<SellingHistoryCountAggregateOutputType> | number
          }
        }
      }
      BiddingHistory: {
        payload: Prisma.$BiddingHistoryPayload<ExtArgs>
        fields: Prisma.BiddingHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BiddingHistoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BiddingHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BiddingHistoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BiddingHistoryPayload>
          }
          findFirst: {
            args: Prisma.BiddingHistoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BiddingHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BiddingHistoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BiddingHistoryPayload>
          }
          findMany: {
            args: Prisma.BiddingHistoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BiddingHistoryPayload>[]
          }
          create: {
            args: Prisma.BiddingHistoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BiddingHistoryPayload>
          }
          createMany: {
            args: Prisma.BiddingHistoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BiddingHistoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BiddingHistoryPayload>
          }
          update: {
            args: Prisma.BiddingHistoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BiddingHistoryPayload>
          }
          deleteMany: {
            args: Prisma.BiddingHistoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BiddingHistoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BiddingHistoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BiddingHistoryPayload>
          }
          aggregate: {
            args: Prisma.BiddingHistoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBiddingHistory>
          }
          groupBy: {
            args: Prisma.BiddingHistoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BiddingHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.BiddingHistoryCountArgs<ExtArgs>,
            result: $Utils.Optional<BiddingHistoryCountAggregateOutputType> | number
          }
        }
      }
      Request: {
        payload: Prisma.$RequestPayload<ExtArgs>
        fields: Prisma.RequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RequestFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RequestFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>
          }
          findFirst: {
            args: Prisma.RequestFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RequestFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>
          }
          findMany: {
            args: Prisma.RequestFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>[]
          }
          create: {
            args: Prisma.RequestCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>
          }
          createMany: {
            args: Prisma.RequestCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RequestDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>
          }
          update: {
            args: Prisma.RequestUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>
          }
          deleteMany: {
            args: Prisma.RequestDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RequestUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RequestUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RequestPayload>
          }
          aggregate: {
            args: Prisma.RequestAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRequest>
          }
          groupBy: {
            args: Prisma.RequestGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.RequestCountArgs<ExtArgs>,
            result: $Utils.Optional<RequestCountAggregateOutputType> | number
          }
        }
      }
      FAQ: {
        payload: Prisma.$FAQPayload<ExtArgs>
        fields: Prisma.FAQFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FAQFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FAQPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FAQFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          findFirst: {
            args: Prisma.FAQFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FAQPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FAQFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          findMany: {
            args: Prisma.FAQFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>[]
          }
          create: {
            args: Prisma.FAQCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          createMany: {
            args: Prisma.FAQCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FAQDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          update: {
            args: Prisma.FAQUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          deleteMany: {
            args: Prisma.FAQDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FAQUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FAQUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          aggregate: {
            args: Prisma.FAQAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFAQ>
          }
          groupBy: {
            args: Prisma.FAQGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FAQGroupByOutputType>[]
          }
          count: {
            args: Prisma.FAQCountArgs<ExtArgs>,
            result: $Utils.Optional<FAQCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }



  /**
   * Count Type AccountCountOutputType
   */

  export type AccountCountOutputType = {
    cars: number
    auctions: number
    comments: number
    orders: number
    sellingHistory: number
    biddingHistory: number
    requests: number
  }

  export type AccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cars?: boolean | AccountCountOutputTypeCountCarsArgs
    auctions?: boolean | AccountCountOutputTypeCountAuctionsArgs
    comments?: boolean | AccountCountOutputTypeCountCommentsArgs
    orders?: boolean | AccountCountOutputTypeCountOrdersArgs
    sellingHistory?: boolean | AccountCountOutputTypeCountSellingHistoryArgs
    biddingHistory?: boolean | AccountCountOutputTypeCountBiddingHistoryArgs
    requests?: boolean | AccountCountOutputTypeCountRequestsArgs
  }

  // Custom InputTypes

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCountOutputType
     */
    select?: AccountCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountCarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CarWhereInput
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountAuctionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuctionWhereInput
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdersWhereInput
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountSellingHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellingHistoryWhereInput
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountBiddingHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BiddingHistoryWhereInput
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestWhereInput
  }



  /**
   * Count Type CarCountOutputType
   */

  export type CarCountOutputType = {
    auctions: number
  }

  export type CarCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auctions?: boolean | CarCountOutputTypeCountAuctionsArgs
  }

  // Custom InputTypes

  /**
   * CarCountOutputType without action
   */
  export type CarCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarCountOutputType
     */
    select?: CarCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CarCountOutputType without action
   */
  export type CarCountOutputTypeCountAuctionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuctionWhereInput
  }



  /**
   * Count Type AuctionCountOutputType
   */

  export type AuctionCountOutputType = {
    comments: number
    orders: number
    biddingHistories: number
  }

  export type AuctionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | AuctionCountOutputTypeCountCommentsArgs
    orders?: boolean | AuctionCountOutputTypeCountOrdersArgs
    biddingHistories?: boolean | AuctionCountOutputTypeCountBiddingHistoriesArgs
  }

  // Custom InputTypes

  /**
   * AuctionCountOutputType without action
   */
  export type AuctionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionCountOutputType
     */
    select?: AuctionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AuctionCountOutputType without action
   */
  export type AuctionCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * AuctionCountOutputType without action
   */
  export type AuctionCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdersWhereInput
  }


  /**
   * AuctionCountOutputType without action
   */
  export type AuctionCountOutputTypeCountBiddingHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BiddingHistoryWhereInput
  }



  /**
   * Count Type OrdersCountOutputType
   */

  export type OrdersCountOutputType = {
    sellingHistory: number
  }

  export type OrdersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sellingHistory?: boolean | OrdersCountOutputTypeCountSellingHistoryArgs
  }

  // Custom InputTypes

  /**
   * OrdersCountOutputType without action
   */
  export type OrdersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdersCountOutputType
     */
    select?: OrdersCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * OrdersCountOutputType without action
   */
  export type OrdersCountOutputTypeCountSellingHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellingHistoryWhereInput
  }



  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    userID: number | null
  }

  export type UserSumAggregateOutputType = {
    userID: number | null
  }

  export type UserMinAggregateOutputType = {
    userID: number | null
    firstName: string | null
    lastName: string | null
    address: string | null
    phoneNumber: string | null
    emailAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    userID: number | null
    firstName: string | null
    lastName: string | null
    address: string | null
    phoneNumber: string | null
    emailAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    userID: number
    firstName: number
    lastName: number
    address: number
    phoneNumber: number
    emailAddress: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    userID?: true
  }

  export type UserSumAggregateInputType = {
    userID?: true
  }

  export type UserMinAggregateInputType = {
    userID?: true
    firstName?: true
    lastName?: true
    address?: true
    phoneNumber?: true
    emailAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    userID?: true
    firstName?: true
    lastName?: true
    address?: true
    phoneNumber?: true
    emailAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    userID?: true
    firstName?: true
    lastName?: true
    address?: true
    phoneNumber?: true
    emailAddress?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    userID: number
    firstName: string
    lastName: string
    address: string | null
    phoneNumber: string
    emailAddress: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userID?: boolean
    firstName?: boolean
    lastName?: boolean
    address?: boolean
    phoneNumber?: boolean
    emailAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    userID?: boolean
    firstName?: boolean
    lastName?: boolean
    address?: boolean
    phoneNumber?: boolean
    emailAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      userID: number
      firstName: string
      lastName: string
      address: string | null
      phoneNumber: string
      emailAddress: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `userID`
     * const userWithUserIDOnly = await prisma.user.findMany({ select: { userID: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly userID: FieldRef<"User", 'Int'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly emailAddress: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    accountID: number | null
    userID: number | null
  }

  export type AccountSumAggregateOutputType = {
    accountID: number | null
    userID: number | null
  }

  export type AccountMinAggregateOutputType = {
    accountID: number | null
    accountType: string | null
    accountStatus: string | null
    username: string | null
    password: string | null
    userID: number | null
    token2fa: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    accountID: number | null
    accountType: string | null
    accountStatus: string | null
    username: string | null
    password: string | null
    userID: number | null
    token2fa: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    accountID: number
    accountType: number
    accountStatus: number
    username: number
    password: number
    userID: number
    token2fa: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    accountID?: true
    userID?: true
  }

  export type AccountSumAggregateInputType = {
    accountID?: true
    userID?: true
  }

  export type AccountMinAggregateInputType = {
    accountID?: true
    accountType?: true
    accountStatus?: true
    username?: true
    password?: true
    userID?: true
    token2fa?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    accountID?: true
    accountType?: true
    accountStatus?: true
    username?: true
    password?: true
    userID?: true
    token2fa?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    accountID?: true
    accountType?: true
    accountStatus?: true
    username?: true
    password?: true
    userID?: true
    token2fa?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    accountID: number
    accountType: string
    accountStatus: string
    username: string
    password: string
    userID: number | null
    token2fa: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    accountID?: boolean
    accountType?: boolean
    accountStatus?: boolean
    username?: boolean
    password?: boolean
    userID?: boolean
    token2fa?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Account$userArgs<ExtArgs>
    cars?: boolean | Account$carsArgs<ExtArgs>
    auctions?: boolean | Account$auctionsArgs<ExtArgs>
    comments?: boolean | Account$commentsArgs<ExtArgs>
    orders?: boolean | Account$ordersArgs<ExtArgs>
    sellingHistory?: boolean | Account$sellingHistoryArgs<ExtArgs>
    biddingHistory?: boolean | Account$biddingHistoryArgs<ExtArgs>
    requests?: boolean | Account$requestsArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    accountID?: boolean
    accountType?: boolean
    accountStatus?: boolean
    username?: boolean
    password?: boolean
    userID?: boolean
    token2fa?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Account$userArgs<ExtArgs>
    cars?: boolean | Account$carsArgs<ExtArgs>
    auctions?: boolean | Account$auctionsArgs<ExtArgs>
    comments?: boolean | Account$commentsArgs<ExtArgs>
    orders?: boolean | Account$ordersArgs<ExtArgs>
    sellingHistory?: boolean | Account$sellingHistoryArgs<ExtArgs>
    biddingHistory?: boolean | Account$biddingHistoryArgs<ExtArgs>
    requests?: boolean | Account$requestsArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      cars: Prisma.$CarPayload<ExtArgs>[]
      auctions: Prisma.$AuctionPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      orders: Prisma.$OrdersPayload<ExtArgs>[]
      sellingHistory: Prisma.$SellingHistoryPayload<ExtArgs>[]
      biddingHistory: Prisma.$BiddingHistoryPayload<ExtArgs>[]
      requests: Prisma.$RequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      accountID: number
      accountType: string
      accountStatus: string
      username: string
      password: string
      userID: number | null
      token2fa: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }


  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `accountID`
     * const accountWithAccountIDOnly = await prisma.account.findMany({ select: { accountID: true } })
     * 
    **/
    findMany<T extends AccountFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
    **/
    create<T extends AccountCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountCreateArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Accounts.
     *     @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     *     @example
     *     // Create many Accounts
     *     const account = await prisma.account.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
    **/
    delete<T extends AccountDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
    **/
    upsert<T extends AccountUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends Account$userArgs<ExtArgs> = {}>(args?: Subset<T, Account$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    cars<T extends Account$carsArgs<ExtArgs> = {}>(args?: Subset<T, Account$carsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, 'findMany'> | Null>;

    auctions<T extends Account$auctionsArgs<ExtArgs> = {}>(args?: Subset<T, Account$auctionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, 'findMany'> | Null>;

    comments<T extends Account$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Account$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany'> | Null>;

    orders<T extends Account$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Account$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, 'findMany'> | Null>;

    sellingHistory<T extends Account$sellingHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Account$sellingHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellingHistoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    biddingHistory<T extends Account$biddingHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Account$biddingHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiddingHistoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    requests<T extends Account$requestsArgs<ExtArgs> = {}>(args?: Subset<T, Account$requestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly accountID: FieldRef<"Account", 'Int'>
    readonly accountType: FieldRef<"Account", 'String'>
    readonly accountStatus: FieldRef<"Account", 'String'>
    readonly username: FieldRef<"Account", 'String'>
    readonly password: FieldRef<"Account", 'String'>
    readonly userID: FieldRef<"Account", 'Int'>
    readonly token2fa: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }


  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }


  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }


  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }


  /**
   * Account.user
   */
  export type Account$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Account.cars
   */
  export type Account$carsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CarInclude<ExtArgs> | null
    where?: CarWhereInput
    orderBy?: CarOrderByWithRelationInput | CarOrderByWithRelationInput[]
    cursor?: CarWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CarScalarFieldEnum | CarScalarFieldEnum[]
  }


  /**
   * Account.auctions
   */
  export type Account$auctionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuctionInclude<ExtArgs> | null
    where?: AuctionWhereInput
    orderBy?: AuctionOrderByWithRelationInput | AuctionOrderByWithRelationInput[]
    cursor?: AuctionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuctionScalarFieldEnum | AuctionScalarFieldEnum[]
  }


  /**
   * Account.comments
   */
  export type Account$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Account.orders
   */
  export type Account$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrdersInclude<ExtArgs> | null
    where?: OrdersWhereInput
    orderBy?: OrdersOrderByWithRelationInput | OrdersOrderByWithRelationInput[]
    cursor?: OrdersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }


  /**
   * Account.sellingHistory
   */
  export type Account$sellingHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHistory
     */
    select?: SellingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SellingHistoryInclude<ExtArgs> | null
    where?: SellingHistoryWhereInput
    orderBy?: SellingHistoryOrderByWithRelationInput | SellingHistoryOrderByWithRelationInput[]
    cursor?: SellingHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SellingHistoryScalarFieldEnum | SellingHistoryScalarFieldEnum[]
  }


  /**
   * Account.biddingHistory
   */
  export type Account$biddingHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiddingHistory
     */
    select?: BiddingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BiddingHistoryInclude<ExtArgs> | null
    where?: BiddingHistoryWhereInput
    orderBy?: BiddingHistoryOrderByWithRelationInput | BiddingHistoryOrderByWithRelationInput[]
    cursor?: BiddingHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BiddingHistoryScalarFieldEnum | BiddingHistoryScalarFieldEnum[]
  }


  /**
   * Account.requests
   */
  export type Account$requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestInclude<ExtArgs> | null
    where?: RequestWhereInput
    orderBy?: RequestOrderByWithRelationInput | RequestOrderByWithRelationInput[]
    cursor?: RequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequestScalarFieldEnum | RequestScalarFieldEnum[]
  }


  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
  }



  /**
   * Model Car
   */

  export type AggregateCar = {
    _count: CarCountAggregateOutputType | null
    _avg: CarAvgAggregateOutputType | null
    _sum: CarSumAggregateOutputType | null
    _min: CarMinAggregateOutputType | null
    _max: CarMaxAggregateOutputType | null
  }

  export type CarAvgAggregateOutputType = {
    carID: number | null
    startingBid: number | null
    reservePrice: number | null
    accountID: number | null
  }

  export type CarSumAggregateOutputType = {
    carID: number | null
    startingBid: number | null
    reservePrice: number | null
    accountID: number | null
  }

  export type CarMinAggregateOutputType = {
    carID: number | null
    vehicleNumber: string | null
    carImage: Buffer | null
    highlights: string | null
    equipment: string | null
    modifications: string | null
    knownFlaws: string | null
    make: string | null
    model: string | null
    interiorColor: string | null
    exteriorColor: string | null
    startingBid: number | null
    reservePrice: number | null
    accountID: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CarMaxAggregateOutputType = {
    carID: number | null
    vehicleNumber: string | null
    carImage: Buffer | null
    highlights: string | null
    equipment: string | null
    modifications: string | null
    knownFlaws: string | null
    make: string | null
    model: string | null
    interiorColor: string | null
    exteriorColor: string | null
    startingBid: number | null
    reservePrice: number | null
    accountID: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CarCountAggregateOutputType = {
    carID: number
    vehicleNumber: number
    carImage: number
    highlights: number
    equipment: number
    modifications: number
    knownFlaws: number
    make: number
    model: number
    interiorColor: number
    exteriorColor: number
    startingBid: number
    reservePrice: number
    accountID: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CarAvgAggregateInputType = {
    carID?: true
    startingBid?: true
    reservePrice?: true
    accountID?: true
  }

  export type CarSumAggregateInputType = {
    carID?: true
    startingBid?: true
    reservePrice?: true
    accountID?: true
  }

  export type CarMinAggregateInputType = {
    carID?: true
    vehicleNumber?: true
    carImage?: true
    highlights?: true
    equipment?: true
    modifications?: true
    knownFlaws?: true
    make?: true
    model?: true
    interiorColor?: true
    exteriorColor?: true
    startingBid?: true
    reservePrice?: true
    accountID?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CarMaxAggregateInputType = {
    carID?: true
    vehicleNumber?: true
    carImage?: true
    highlights?: true
    equipment?: true
    modifications?: true
    knownFlaws?: true
    make?: true
    model?: true
    interiorColor?: true
    exteriorColor?: true
    startingBid?: true
    reservePrice?: true
    accountID?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CarCountAggregateInputType = {
    carID?: true
    vehicleNumber?: true
    carImage?: true
    highlights?: true
    equipment?: true
    modifications?: true
    knownFlaws?: true
    make?: true
    model?: true
    interiorColor?: true
    exteriorColor?: true
    startingBid?: true
    reservePrice?: true
    accountID?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Car to aggregate.
     */
    where?: CarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cars to fetch.
     */
    orderBy?: CarOrderByWithRelationInput | CarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cars
    **/
    _count?: true | CarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CarAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CarSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CarMaxAggregateInputType
  }

  export type GetCarAggregateType<T extends CarAggregateArgs> = {
        [P in keyof T & keyof AggregateCar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCar[P]>
      : GetScalarType<T[P], AggregateCar[P]>
  }




  export type CarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CarWhereInput
    orderBy?: CarOrderByWithAggregationInput | CarOrderByWithAggregationInput[]
    by: CarScalarFieldEnum[] | CarScalarFieldEnum
    having?: CarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CarCountAggregateInputType | true
    _avg?: CarAvgAggregateInputType
    _sum?: CarSumAggregateInputType
    _min?: CarMinAggregateInputType
    _max?: CarMaxAggregateInputType
  }

  export type CarGroupByOutputType = {
    carID: number
    vehicleNumber: string
    carImage: Buffer | null
    highlights: string | null
    equipment: string | null
    modifications: string | null
    knownFlaws: string | null
    make: string
    model: string
    interiorColor: string | null
    exteriorColor: string | null
    startingBid: number
    reservePrice: number
    accountID: number
    createdAt: Date
    updatedAt: Date
    _count: CarCountAggregateOutputType | null
    _avg: CarAvgAggregateOutputType | null
    _sum: CarSumAggregateOutputType | null
    _min: CarMinAggregateOutputType | null
    _max: CarMaxAggregateOutputType | null
  }

  type GetCarGroupByPayload<T extends CarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CarGroupByOutputType[P]>
            : GetScalarType<T[P], CarGroupByOutputType[P]>
        }
      >
    >


  export type CarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    carID?: boolean
    vehicleNumber?: boolean
    carImage?: boolean
    highlights?: boolean
    equipment?: boolean
    modifications?: boolean
    knownFlaws?: boolean
    make?: boolean
    model?: boolean
    interiorColor?: boolean
    exteriorColor?: boolean
    startingBid?: boolean
    reservePrice?: boolean
    accountID?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    auctions?: boolean | Car$auctionsArgs<ExtArgs>
    _count?: boolean | CarCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["car"]>

  export type CarSelectScalar = {
    carID?: boolean
    vehicleNumber?: boolean
    carImage?: boolean
    highlights?: boolean
    equipment?: boolean
    modifications?: boolean
    knownFlaws?: boolean
    make?: boolean
    model?: boolean
    interiorColor?: boolean
    exteriorColor?: boolean
    startingBid?: boolean
    reservePrice?: boolean
    accountID?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CarInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    auctions?: boolean | Car$auctionsArgs<ExtArgs>
    _count?: boolean | CarCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Car"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      auctions: Prisma.$AuctionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      carID: number
      vehicleNumber: string
      carImage: Buffer | null
      highlights: string | null
      equipment: string | null
      modifications: string | null
      knownFlaws: string | null
      make: string
      model: string
      interiorColor: string | null
      exteriorColor: string | null
      startingBid: number
      reservePrice: number
      accountID: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["car"]>
    composites: {}
  }


  type CarGetPayload<S extends boolean | null | undefined | CarDefaultArgs> = $Result.GetResult<Prisma.$CarPayload, S>

  type CarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CarFindManyArgs, 'select' | 'include'> & {
      select?: CarCountAggregateInputType | true
    }

  export interface CarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Car'], meta: { name: 'Car' } }
    /**
     * Find zero or one Car that matches the filter.
     * @param {CarFindUniqueArgs} args - Arguments to find a Car
     * @example
     * // Get one Car
     * const car = await prisma.car.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CarFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CarFindUniqueArgs<ExtArgs>>
    ): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Car that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CarFindUniqueOrThrowArgs} args - Arguments to find a Car
     * @example
     * // Get one Car
     * const car = await prisma.car.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CarFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CarFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Car that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarFindFirstArgs} args - Arguments to find a Car
     * @example
     * // Get one Car
     * const car = await prisma.car.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CarFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CarFindFirstArgs<ExtArgs>>
    ): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Car that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarFindFirstOrThrowArgs} args - Arguments to find a Car
     * @example
     * // Get one Car
     * const car = await prisma.car.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CarFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CarFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Cars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cars
     * const cars = await prisma.car.findMany()
     * 
     * // Get first 10 Cars
     * const cars = await prisma.car.findMany({ take: 10 })
     * 
     * // Only select the `carID`
     * const carWithCarIDOnly = await prisma.car.findMany({ select: { carID: true } })
     * 
    **/
    findMany<T extends CarFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CarFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Car.
     * @param {CarCreateArgs} args - Arguments to create a Car.
     * @example
     * // Create one Car
     * const Car = await prisma.car.create({
     *   data: {
     *     // ... data to create a Car
     *   }
     * })
     * 
    **/
    create<T extends CarCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CarCreateArgs<ExtArgs>>
    ): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Cars.
     *     @param {CarCreateManyArgs} args - Arguments to create many Cars.
     *     @example
     *     // Create many Cars
     *     const car = await prisma.car.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CarCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CarCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Car.
     * @param {CarDeleteArgs} args - Arguments to delete one Car.
     * @example
     * // Delete one Car
     * const Car = await prisma.car.delete({
     *   where: {
     *     // ... filter to delete one Car
     *   }
     * })
     * 
    **/
    delete<T extends CarDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CarDeleteArgs<ExtArgs>>
    ): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Car.
     * @param {CarUpdateArgs} args - Arguments to update one Car.
     * @example
     * // Update one Car
     * const car = await prisma.car.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CarUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CarUpdateArgs<ExtArgs>>
    ): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Cars.
     * @param {CarDeleteManyArgs} args - Arguments to filter Cars to delete.
     * @example
     * // Delete a few Cars
     * const { count } = await prisma.car.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CarDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CarDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cars
     * const car = await prisma.car.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CarUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CarUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Car.
     * @param {CarUpsertArgs} args - Arguments to update or create a Car.
     * @example
     * // Update or create a Car
     * const car = await prisma.car.upsert({
     *   create: {
     *     // ... data to create a Car
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Car we want to update
     *   }
     * })
    **/
    upsert<T extends CarUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CarUpsertArgs<ExtArgs>>
    ): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Cars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarCountArgs} args - Arguments to filter Cars to count.
     * @example
     * // Count the number of Cars
     * const count = await prisma.car.count({
     *   where: {
     *     // ... the filter for the Cars we want to count
     *   }
     * })
    **/
    count<T extends CarCountArgs>(
      args?: Subset<T, CarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Car.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CarAggregateArgs>(args: Subset<T, CarAggregateArgs>): Prisma.PrismaPromise<GetCarAggregateType<T>>

    /**
     * Group by Car.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CarGroupByArgs['orderBy'] }
        : { orderBy?: CarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Car model
   */
  readonly fields: CarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Car.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    auctions<T extends Car$auctionsArgs<ExtArgs> = {}>(args?: Subset<T, Car$auctionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Car model
   */ 
  interface CarFieldRefs {
    readonly carID: FieldRef<"Car", 'Int'>
    readonly vehicleNumber: FieldRef<"Car", 'String'>
    readonly carImage: FieldRef<"Car", 'Bytes'>
    readonly highlights: FieldRef<"Car", 'String'>
    readonly equipment: FieldRef<"Car", 'String'>
    readonly modifications: FieldRef<"Car", 'String'>
    readonly knownFlaws: FieldRef<"Car", 'String'>
    readonly make: FieldRef<"Car", 'String'>
    readonly model: FieldRef<"Car", 'String'>
    readonly interiorColor: FieldRef<"Car", 'String'>
    readonly exteriorColor: FieldRef<"Car", 'String'>
    readonly startingBid: FieldRef<"Car", 'Float'>
    readonly reservePrice: FieldRef<"Car", 'Float'>
    readonly accountID: FieldRef<"Car", 'Int'>
    readonly createdAt: FieldRef<"Car", 'DateTime'>
    readonly updatedAt: FieldRef<"Car", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Car findUnique
   */
  export type CarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CarInclude<ExtArgs> | null
    /**
     * Filter, which Car to fetch.
     */
    where: CarWhereUniqueInput
  }


  /**
   * Car findUniqueOrThrow
   */
  export type CarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CarInclude<ExtArgs> | null
    /**
     * Filter, which Car to fetch.
     */
    where: CarWhereUniqueInput
  }


  /**
   * Car findFirst
   */
  export type CarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CarInclude<ExtArgs> | null
    /**
     * Filter, which Car to fetch.
     */
    where?: CarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cars to fetch.
     */
    orderBy?: CarOrderByWithRelationInput | CarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cars.
     */
    cursor?: CarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cars.
     */
    distinct?: CarScalarFieldEnum | CarScalarFieldEnum[]
  }


  /**
   * Car findFirstOrThrow
   */
  export type CarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CarInclude<ExtArgs> | null
    /**
     * Filter, which Car to fetch.
     */
    where?: CarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cars to fetch.
     */
    orderBy?: CarOrderByWithRelationInput | CarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cars.
     */
    cursor?: CarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cars.
     */
    distinct?: CarScalarFieldEnum | CarScalarFieldEnum[]
  }


  /**
   * Car findMany
   */
  export type CarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CarInclude<ExtArgs> | null
    /**
     * Filter, which Cars to fetch.
     */
    where?: CarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cars to fetch.
     */
    orderBy?: CarOrderByWithRelationInput | CarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cars.
     */
    cursor?: CarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cars.
     */
    skip?: number
    distinct?: CarScalarFieldEnum | CarScalarFieldEnum[]
  }


  /**
   * Car create
   */
  export type CarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CarInclude<ExtArgs> | null
    /**
     * The data needed to create a Car.
     */
    data: XOR<CarCreateInput, CarUncheckedCreateInput>
  }


  /**
   * Car createMany
   */
  export type CarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cars.
     */
    data: CarCreateManyInput | CarCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Car update
   */
  export type CarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CarInclude<ExtArgs> | null
    /**
     * The data needed to update a Car.
     */
    data: XOR<CarUpdateInput, CarUncheckedUpdateInput>
    /**
     * Choose, which Car to update.
     */
    where: CarWhereUniqueInput
  }


  /**
   * Car updateMany
   */
  export type CarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cars.
     */
    data: XOR<CarUpdateManyMutationInput, CarUncheckedUpdateManyInput>
    /**
     * Filter which Cars to update
     */
    where?: CarWhereInput
  }


  /**
   * Car upsert
   */
  export type CarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CarInclude<ExtArgs> | null
    /**
     * The filter to search for the Car to update in case it exists.
     */
    where: CarWhereUniqueInput
    /**
     * In case the Car found by the `where` argument doesn't exist, create a new Car with this data.
     */
    create: XOR<CarCreateInput, CarUncheckedCreateInput>
    /**
     * In case the Car was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CarUpdateInput, CarUncheckedUpdateInput>
  }


  /**
   * Car delete
   */
  export type CarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CarInclude<ExtArgs> | null
    /**
     * Filter which Car to delete.
     */
    where: CarWhereUniqueInput
  }


  /**
   * Car deleteMany
   */
  export type CarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cars to delete
     */
    where?: CarWhereInput
  }


  /**
   * Car.auctions
   */
  export type Car$auctionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuctionInclude<ExtArgs> | null
    where?: AuctionWhereInput
    orderBy?: AuctionOrderByWithRelationInput | AuctionOrderByWithRelationInput[]
    cursor?: AuctionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuctionScalarFieldEnum | AuctionScalarFieldEnum[]
  }


  /**
   * Car without action
   */
  export type CarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CarInclude<ExtArgs> | null
  }



  /**
   * Model Auction
   */

  export type AggregateAuction = {
    _count: AuctionCountAggregateOutputType | null
    _avg: AuctionAvgAggregateOutputType | null
    _sum: AuctionSumAggregateOutputType | null
    _min: AuctionMinAggregateOutputType | null
    _max: AuctionMaxAggregateOutputType | null
  }

  export type AuctionAvgAggregateOutputType = {
    auctionID: number | null
    currentHighestBid: number | null
    auctionCreatorID: number | null
    carID: number | null
  }

  export type AuctionSumAggregateOutputType = {
    auctionID: number | null
    currentHighestBid: number | null
    auctionCreatorID: number | null
    carID: number | null
  }

  export type AuctionMinAggregateOutputType = {
    auctionID: number | null
    auctionStatus: string | null
    startDate: Date | null
    endDate: Date | null
    currentHighestBid: number | null
    auctionCreationTime: Date | null
    auctionCreatorID: number | null
    carID: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuctionMaxAggregateOutputType = {
    auctionID: number | null
    auctionStatus: string | null
    startDate: Date | null
    endDate: Date | null
    currentHighestBid: number | null
    auctionCreationTime: Date | null
    auctionCreatorID: number | null
    carID: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuctionCountAggregateOutputType = {
    auctionID: number
    auctionStatus: number
    startDate: number
    endDate: number
    currentHighestBid: number
    auctionCreationTime: number
    auctionCreatorID: number
    carID: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AuctionAvgAggregateInputType = {
    auctionID?: true
    currentHighestBid?: true
    auctionCreatorID?: true
    carID?: true
  }

  export type AuctionSumAggregateInputType = {
    auctionID?: true
    currentHighestBid?: true
    auctionCreatorID?: true
    carID?: true
  }

  export type AuctionMinAggregateInputType = {
    auctionID?: true
    auctionStatus?: true
    startDate?: true
    endDate?: true
    currentHighestBid?: true
    auctionCreationTime?: true
    auctionCreatorID?: true
    carID?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuctionMaxAggregateInputType = {
    auctionID?: true
    auctionStatus?: true
    startDate?: true
    endDate?: true
    currentHighestBid?: true
    auctionCreationTime?: true
    auctionCreatorID?: true
    carID?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuctionCountAggregateInputType = {
    auctionID?: true
    auctionStatus?: true
    startDate?: true
    endDate?: true
    currentHighestBid?: true
    auctionCreationTime?: true
    auctionCreatorID?: true
    carID?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuctionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Auction to aggregate.
     */
    where?: AuctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auctions to fetch.
     */
    orderBy?: AuctionOrderByWithRelationInput | AuctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auctions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Auctions
    **/
    _count?: true | AuctionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuctionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuctionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuctionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuctionMaxAggregateInputType
  }

  export type GetAuctionAggregateType<T extends AuctionAggregateArgs> = {
        [P in keyof T & keyof AggregateAuction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuction[P]>
      : GetScalarType<T[P], AggregateAuction[P]>
  }




  export type AuctionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuctionWhereInput
    orderBy?: AuctionOrderByWithAggregationInput | AuctionOrderByWithAggregationInput[]
    by: AuctionScalarFieldEnum[] | AuctionScalarFieldEnum
    having?: AuctionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuctionCountAggregateInputType | true
    _avg?: AuctionAvgAggregateInputType
    _sum?: AuctionSumAggregateInputType
    _min?: AuctionMinAggregateInputType
    _max?: AuctionMaxAggregateInputType
  }

  export type AuctionGroupByOutputType = {
    auctionID: number
    auctionStatus: string
    startDate: Date
    endDate: Date
    currentHighestBid: number
    auctionCreationTime: Date
    auctionCreatorID: number
    carID: number
    createdAt: Date
    updatedAt: Date
    _count: AuctionCountAggregateOutputType | null
    _avg: AuctionAvgAggregateOutputType | null
    _sum: AuctionSumAggregateOutputType | null
    _min: AuctionMinAggregateOutputType | null
    _max: AuctionMaxAggregateOutputType | null
  }

  type GetAuctionGroupByPayload<T extends AuctionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuctionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuctionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuctionGroupByOutputType[P]>
            : GetScalarType<T[P], AuctionGroupByOutputType[P]>
        }
      >
    >


  export type AuctionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    auctionID?: boolean
    auctionStatus?: boolean
    startDate?: boolean
    endDate?: boolean
    currentHighestBid?: boolean
    auctionCreationTime?: boolean
    auctionCreatorID?: boolean
    carID?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    auctionCreator?: boolean | AccountDefaultArgs<ExtArgs>
    car?: boolean | CarDefaultArgs<ExtArgs>
    comments?: boolean | Auction$commentsArgs<ExtArgs>
    orders?: boolean | Auction$ordersArgs<ExtArgs>
    biddingHistories?: boolean | Auction$biddingHistoriesArgs<ExtArgs>
    _count?: boolean | AuctionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auction"]>

  export type AuctionSelectScalar = {
    auctionID?: boolean
    auctionStatus?: boolean
    startDate?: boolean
    endDate?: boolean
    currentHighestBid?: boolean
    auctionCreationTime?: boolean
    auctionCreatorID?: boolean
    carID?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AuctionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auctionCreator?: boolean | AccountDefaultArgs<ExtArgs>
    car?: boolean | CarDefaultArgs<ExtArgs>
    comments?: boolean | Auction$commentsArgs<ExtArgs>
    orders?: boolean | Auction$ordersArgs<ExtArgs>
    biddingHistories?: boolean | Auction$biddingHistoriesArgs<ExtArgs>
    _count?: boolean | AuctionCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AuctionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Auction"
    objects: {
      auctionCreator: Prisma.$AccountPayload<ExtArgs>
      car: Prisma.$CarPayload<ExtArgs>
      comments: Prisma.$CommentPayload<ExtArgs>[]
      orders: Prisma.$OrdersPayload<ExtArgs>[]
      biddingHistories: Prisma.$BiddingHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      auctionID: number
      auctionStatus: string
      startDate: Date
      endDate: Date
      currentHighestBid: number
      auctionCreationTime: Date
      auctionCreatorID: number
      carID: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["auction"]>
    composites: {}
  }


  type AuctionGetPayload<S extends boolean | null | undefined | AuctionDefaultArgs> = $Result.GetResult<Prisma.$AuctionPayload, S>

  type AuctionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuctionFindManyArgs, 'select' | 'include'> & {
      select?: AuctionCountAggregateInputType | true
    }

  export interface AuctionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Auction'], meta: { name: 'Auction' } }
    /**
     * Find zero or one Auction that matches the filter.
     * @param {AuctionFindUniqueArgs} args - Arguments to find a Auction
     * @example
     * // Get one Auction
     * const auction = await prisma.auction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AuctionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AuctionFindUniqueArgs<ExtArgs>>
    ): Prisma__AuctionClient<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Auction that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AuctionFindUniqueOrThrowArgs} args - Arguments to find a Auction
     * @example
     * // Get one Auction
     * const auction = await prisma.auction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AuctionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AuctionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AuctionClient<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Auction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionFindFirstArgs} args - Arguments to find a Auction
     * @example
     * // Get one Auction
     * const auction = await prisma.auction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AuctionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AuctionFindFirstArgs<ExtArgs>>
    ): Prisma__AuctionClient<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Auction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionFindFirstOrThrowArgs} args - Arguments to find a Auction
     * @example
     * // Get one Auction
     * const auction = await prisma.auction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AuctionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AuctionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AuctionClient<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Auctions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auctions
     * const auctions = await prisma.auction.findMany()
     * 
     * // Get first 10 Auctions
     * const auctions = await prisma.auction.findMany({ take: 10 })
     * 
     * // Only select the `auctionID`
     * const auctionWithAuctionIDOnly = await prisma.auction.findMany({ select: { auctionID: true } })
     * 
    **/
    findMany<T extends AuctionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AuctionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Auction.
     * @param {AuctionCreateArgs} args - Arguments to create a Auction.
     * @example
     * // Create one Auction
     * const Auction = await prisma.auction.create({
     *   data: {
     *     // ... data to create a Auction
     *   }
     * })
     * 
    **/
    create<T extends AuctionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AuctionCreateArgs<ExtArgs>>
    ): Prisma__AuctionClient<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Auctions.
     *     @param {AuctionCreateManyArgs} args - Arguments to create many Auctions.
     *     @example
     *     // Create many Auctions
     *     const auction = await prisma.auction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AuctionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AuctionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Auction.
     * @param {AuctionDeleteArgs} args - Arguments to delete one Auction.
     * @example
     * // Delete one Auction
     * const Auction = await prisma.auction.delete({
     *   where: {
     *     // ... filter to delete one Auction
     *   }
     * })
     * 
    **/
    delete<T extends AuctionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AuctionDeleteArgs<ExtArgs>>
    ): Prisma__AuctionClient<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Auction.
     * @param {AuctionUpdateArgs} args - Arguments to update one Auction.
     * @example
     * // Update one Auction
     * const auction = await prisma.auction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AuctionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AuctionUpdateArgs<ExtArgs>>
    ): Prisma__AuctionClient<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Auctions.
     * @param {AuctionDeleteManyArgs} args - Arguments to filter Auctions to delete.
     * @example
     * // Delete a few Auctions
     * const { count } = await prisma.auction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AuctionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AuctionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auctions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auctions
     * const auction = await prisma.auction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AuctionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AuctionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Auction.
     * @param {AuctionUpsertArgs} args - Arguments to update or create a Auction.
     * @example
     * // Update or create a Auction
     * const auction = await prisma.auction.upsert({
     *   create: {
     *     // ... data to create a Auction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auction we want to update
     *   }
     * })
    **/
    upsert<T extends AuctionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AuctionUpsertArgs<ExtArgs>>
    ): Prisma__AuctionClient<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Auctions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionCountArgs} args - Arguments to filter Auctions to count.
     * @example
     * // Count the number of Auctions
     * const count = await prisma.auction.count({
     *   where: {
     *     // ... the filter for the Auctions we want to count
     *   }
     * })
    **/
    count<T extends AuctionCountArgs>(
      args?: Subset<T, AuctionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuctionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuctionAggregateArgs>(args: Subset<T, AuctionAggregateArgs>): Prisma.PrismaPromise<GetAuctionAggregateType<T>>

    /**
     * Group by Auction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuctionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuctionGroupByArgs['orderBy'] }
        : { orderBy?: AuctionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuctionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuctionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Auction model
   */
  readonly fields: AuctionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Auction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuctionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    auctionCreator<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    car<T extends CarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CarDefaultArgs<ExtArgs>>): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    comments<T extends Auction$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Auction$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany'> | Null>;

    orders<T extends Auction$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Auction$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, 'findMany'> | Null>;

    biddingHistories<T extends Auction$biddingHistoriesArgs<ExtArgs> = {}>(args?: Subset<T, Auction$biddingHistoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiddingHistoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Auction model
   */ 
  interface AuctionFieldRefs {
    readonly auctionID: FieldRef<"Auction", 'Int'>
    readonly auctionStatus: FieldRef<"Auction", 'String'>
    readonly startDate: FieldRef<"Auction", 'DateTime'>
    readonly endDate: FieldRef<"Auction", 'DateTime'>
    readonly currentHighestBid: FieldRef<"Auction", 'Float'>
    readonly auctionCreationTime: FieldRef<"Auction", 'DateTime'>
    readonly auctionCreatorID: FieldRef<"Auction", 'Int'>
    readonly carID: FieldRef<"Auction", 'Int'>
    readonly createdAt: FieldRef<"Auction", 'DateTime'>
    readonly updatedAt: FieldRef<"Auction", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Auction findUnique
   */
  export type AuctionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuctionInclude<ExtArgs> | null
    /**
     * Filter, which Auction to fetch.
     */
    where: AuctionWhereUniqueInput
  }


  /**
   * Auction findUniqueOrThrow
   */
  export type AuctionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuctionInclude<ExtArgs> | null
    /**
     * Filter, which Auction to fetch.
     */
    where: AuctionWhereUniqueInput
  }


  /**
   * Auction findFirst
   */
  export type AuctionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuctionInclude<ExtArgs> | null
    /**
     * Filter, which Auction to fetch.
     */
    where?: AuctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auctions to fetch.
     */
    orderBy?: AuctionOrderByWithRelationInput | AuctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Auctions.
     */
    cursor?: AuctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auctions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Auctions.
     */
    distinct?: AuctionScalarFieldEnum | AuctionScalarFieldEnum[]
  }


  /**
   * Auction findFirstOrThrow
   */
  export type AuctionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuctionInclude<ExtArgs> | null
    /**
     * Filter, which Auction to fetch.
     */
    where?: AuctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auctions to fetch.
     */
    orderBy?: AuctionOrderByWithRelationInput | AuctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Auctions.
     */
    cursor?: AuctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auctions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Auctions.
     */
    distinct?: AuctionScalarFieldEnum | AuctionScalarFieldEnum[]
  }


  /**
   * Auction findMany
   */
  export type AuctionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuctionInclude<ExtArgs> | null
    /**
     * Filter, which Auctions to fetch.
     */
    where?: AuctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auctions to fetch.
     */
    orderBy?: AuctionOrderByWithRelationInput | AuctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Auctions.
     */
    cursor?: AuctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auctions.
     */
    skip?: number
    distinct?: AuctionScalarFieldEnum | AuctionScalarFieldEnum[]
  }


  /**
   * Auction create
   */
  export type AuctionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuctionInclude<ExtArgs> | null
    /**
     * The data needed to create a Auction.
     */
    data: XOR<AuctionCreateInput, AuctionUncheckedCreateInput>
  }


  /**
   * Auction createMany
   */
  export type AuctionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Auctions.
     */
    data: AuctionCreateManyInput | AuctionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Auction update
   */
  export type AuctionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuctionInclude<ExtArgs> | null
    /**
     * The data needed to update a Auction.
     */
    data: XOR<AuctionUpdateInput, AuctionUncheckedUpdateInput>
    /**
     * Choose, which Auction to update.
     */
    where: AuctionWhereUniqueInput
  }


  /**
   * Auction updateMany
   */
  export type AuctionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Auctions.
     */
    data: XOR<AuctionUpdateManyMutationInput, AuctionUncheckedUpdateManyInput>
    /**
     * Filter which Auctions to update
     */
    where?: AuctionWhereInput
  }


  /**
   * Auction upsert
   */
  export type AuctionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuctionInclude<ExtArgs> | null
    /**
     * The filter to search for the Auction to update in case it exists.
     */
    where: AuctionWhereUniqueInput
    /**
     * In case the Auction found by the `where` argument doesn't exist, create a new Auction with this data.
     */
    create: XOR<AuctionCreateInput, AuctionUncheckedCreateInput>
    /**
     * In case the Auction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuctionUpdateInput, AuctionUncheckedUpdateInput>
  }


  /**
   * Auction delete
   */
  export type AuctionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuctionInclude<ExtArgs> | null
    /**
     * Filter which Auction to delete.
     */
    where: AuctionWhereUniqueInput
  }


  /**
   * Auction deleteMany
   */
  export type AuctionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Auctions to delete
     */
    where?: AuctionWhereInput
  }


  /**
   * Auction.comments
   */
  export type Auction$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Auction.orders
   */
  export type Auction$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrdersInclude<ExtArgs> | null
    where?: OrdersWhereInput
    orderBy?: OrdersOrderByWithRelationInput | OrdersOrderByWithRelationInput[]
    cursor?: OrdersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }


  /**
   * Auction.biddingHistories
   */
  export type Auction$biddingHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiddingHistory
     */
    select?: BiddingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BiddingHistoryInclude<ExtArgs> | null
    where?: BiddingHistoryWhereInput
    orderBy?: BiddingHistoryOrderByWithRelationInput | BiddingHistoryOrderByWithRelationInput[]
    cursor?: BiddingHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BiddingHistoryScalarFieldEnum | BiddingHistoryScalarFieldEnum[]
  }


  /**
   * Auction without action
   */
  export type AuctionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AuctionInclude<ExtArgs> | null
  }



  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    commentID: number | null
    accountID: number | null
    auctionID: number | null
  }

  export type CommentSumAggregateOutputType = {
    commentID: number | null
    accountID: number | null
    auctionID: number | null
  }

  export type CommentMinAggregateOutputType = {
    commentID: number | null
    details: string | null
    accountID: number | null
    auctionID: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    commentID: number | null
    details: string | null
    accountID: number | null
    auctionID: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    commentID: number
    details: number
    accountID: number
    auctionID: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    commentID?: true
    accountID?: true
    auctionID?: true
  }

  export type CommentSumAggregateInputType = {
    commentID?: true
    accountID?: true
    auctionID?: true
  }

  export type CommentMinAggregateInputType = {
    commentID?: true
    details?: true
    accountID?: true
    auctionID?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    commentID?: true
    details?: true
    accountID?: true
    auctionID?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    commentID?: true
    details?: true
    accountID?: true
    auctionID?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    commentID: number
    details: string
    accountID: number
    auctionID: number
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    commentID?: boolean
    details?: boolean
    accountID?: boolean
    auctionID?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    auction?: boolean | AuctionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    commentID?: boolean
    details?: boolean
    accountID?: boolean
    auctionID?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    auction?: boolean | AuctionDefaultArgs<ExtArgs>
  }


  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      auction: Prisma.$AuctionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      commentID: number
      details: string
      accountID: number
      auctionID: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }


  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `commentID`
     * const commentWithCommentIDOnly = await prisma.comment.findMany({ select: { commentID: true } })
     * 
    **/
    findMany<T extends CommentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
    **/
    create<T extends CommentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CommentCreateArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Comments.
     *     @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     *     @example
     *     // Create many Comments
     *     const comment = await prisma.comment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
    **/
    delete<T extends CommentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
    **/
    upsert<T extends CommentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    auction<T extends AuctionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuctionDefaultArgs<ExtArgs>>): Prisma__AuctionClient<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly commentID: FieldRef<"Comment", 'Int'>
    readonly details: FieldRef<"Comment", 'String'>
    readonly accountID: FieldRef<"Comment", 'Int'>
    readonly auctionID: FieldRef<"Comment", 'Int'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }


  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }


  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }


  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }


  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
  }



  /**
   * Model Orders
   */

  export type AggregateOrders = {
    _count: OrdersCountAggregateOutputType | null
    _avg: OrdersAvgAggregateOutputType | null
    _sum: OrdersSumAggregateOutputType | null
    _min: OrdersMinAggregateOutputType | null
    _max: OrdersMaxAggregateOutputType | null
  }

  export type OrdersAvgAggregateOutputType = {
    orderID: number | null
    orderCreatorID: number | null
    auctionID: number | null
  }

  export type OrdersSumAggregateOutputType = {
    orderID: number | null
    orderCreatorID: number | null
    auctionID: number | null
  }

  export type OrdersMinAggregateOutputType = {
    orderID: number | null
    orderStatus: string | null
    paymentDeadline: Date | null
    deliveryType: string | null
    shippingAddress: string | null
    orderCreationTime: Date | null
    orderCompletionTime: Date | null
    orderCreatorID: number | null
    auctionID: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrdersMaxAggregateOutputType = {
    orderID: number | null
    orderStatus: string | null
    paymentDeadline: Date | null
    deliveryType: string | null
    shippingAddress: string | null
    orderCreationTime: Date | null
    orderCompletionTime: Date | null
    orderCreatorID: number | null
    auctionID: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrdersCountAggregateOutputType = {
    orderID: number
    orderStatus: number
    paymentDeadline: number
    deliveryType: number
    shippingAddress: number
    orderCreationTime: number
    orderCompletionTime: number
    orderCreatorID: number
    auctionID: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrdersAvgAggregateInputType = {
    orderID?: true
    orderCreatorID?: true
    auctionID?: true
  }

  export type OrdersSumAggregateInputType = {
    orderID?: true
    orderCreatorID?: true
    auctionID?: true
  }

  export type OrdersMinAggregateInputType = {
    orderID?: true
    orderStatus?: true
    paymentDeadline?: true
    deliveryType?: true
    shippingAddress?: true
    orderCreationTime?: true
    orderCompletionTime?: true
    orderCreatorID?: true
    auctionID?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrdersMaxAggregateInputType = {
    orderID?: true
    orderStatus?: true
    paymentDeadline?: true
    deliveryType?: true
    shippingAddress?: true
    orderCreationTime?: true
    orderCompletionTime?: true
    orderCreatorID?: true
    auctionID?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrdersCountAggregateInputType = {
    orderID?: true
    orderStatus?: true
    paymentDeadline?: true
    deliveryType?: true
    shippingAddress?: true
    orderCreationTime?: true
    orderCompletionTime?: true
    orderCreatorID?: true
    auctionID?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrdersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to aggregate.
     */
    where?: OrdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrdersOrderByWithRelationInput | OrdersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrdersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrdersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrdersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrdersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrdersMaxAggregateInputType
  }

  export type GetOrdersAggregateType<T extends OrdersAggregateArgs> = {
        [P in keyof T & keyof AggregateOrders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrders[P]>
      : GetScalarType<T[P], AggregateOrders[P]>
  }




  export type OrdersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdersWhereInput
    orderBy?: OrdersOrderByWithAggregationInput | OrdersOrderByWithAggregationInput[]
    by: OrdersScalarFieldEnum[] | OrdersScalarFieldEnum
    having?: OrdersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrdersCountAggregateInputType | true
    _avg?: OrdersAvgAggregateInputType
    _sum?: OrdersSumAggregateInputType
    _min?: OrdersMinAggregateInputType
    _max?: OrdersMaxAggregateInputType
  }

  export type OrdersGroupByOutputType = {
    orderID: number
    orderStatus: string
    paymentDeadline: Date
    deliveryType: string
    shippingAddress: string | null
    orderCreationTime: Date
    orderCompletionTime: Date | null
    orderCreatorID: number
    auctionID: number
    createdAt: Date
    updatedAt: Date
    _count: OrdersCountAggregateOutputType | null
    _avg: OrdersAvgAggregateOutputType | null
    _sum: OrdersSumAggregateOutputType | null
    _min: OrdersMinAggregateOutputType | null
    _max: OrdersMaxAggregateOutputType | null
  }

  type GetOrdersGroupByPayload<T extends OrdersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrdersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrdersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrdersGroupByOutputType[P]>
            : GetScalarType<T[P], OrdersGroupByOutputType[P]>
        }
      >
    >


  export type OrdersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    orderID?: boolean
    orderStatus?: boolean
    paymentDeadline?: boolean
    deliveryType?: boolean
    shippingAddress?: boolean
    orderCreationTime?: boolean
    orderCompletionTime?: boolean
    orderCreatorID?: boolean
    auctionID?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderCreator?: boolean | AccountDefaultArgs<ExtArgs>
    auction?: boolean | AuctionDefaultArgs<ExtArgs>
    sellingHistory?: boolean | Orders$sellingHistoryArgs<ExtArgs>
    _count?: boolean | OrdersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orders"]>

  export type OrdersSelectScalar = {
    orderID?: boolean
    orderStatus?: boolean
    paymentDeadline?: boolean
    deliveryType?: boolean
    shippingAddress?: boolean
    orderCreationTime?: boolean
    orderCompletionTime?: boolean
    orderCreatorID?: boolean
    auctionID?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrdersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderCreator?: boolean | AccountDefaultArgs<ExtArgs>
    auction?: boolean | AuctionDefaultArgs<ExtArgs>
    sellingHistory?: boolean | Orders$sellingHistoryArgs<ExtArgs>
    _count?: boolean | OrdersCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $OrdersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Orders"
    objects: {
      orderCreator: Prisma.$AccountPayload<ExtArgs>
      auction: Prisma.$AuctionPayload<ExtArgs>
      sellingHistory: Prisma.$SellingHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      orderID: number
      orderStatus: string
      paymentDeadline: Date
      deliveryType: string
      shippingAddress: string | null
      orderCreationTime: Date
      orderCompletionTime: Date | null
      orderCreatorID: number
      auctionID: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["orders"]>
    composites: {}
  }


  type OrdersGetPayload<S extends boolean | null | undefined | OrdersDefaultArgs> = $Result.GetResult<Prisma.$OrdersPayload, S>

  type OrdersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrdersFindManyArgs, 'select' | 'include'> & {
      select?: OrdersCountAggregateInputType | true
    }

  export interface OrdersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Orders'], meta: { name: 'Orders' } }
    /**
     * Find zero or one Orders that matches the filter.
     * @param {OrdersFindUniqueArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrdersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OrdersFindUniqueArgs<ExtArgs>>
    ): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Orders that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrdersFindUniqueOrThrowArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrdersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrdersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersFindFirstArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrdersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OrdersFindFirstArgs<ExtArgs>>
    ): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Orders that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersFindFirstOrThrowArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrdersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrdersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.orders.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.orders.findMany({ take: 10 })
     * 
     * // Only select the `orderID`
     * const ordersWithOrderIDOnly = await prisma.orders.findMany({ select: { orderID: true } })
     * 
    **/
    findMany<T extends OrdersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrdersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Orders.
     * @param {OrdersCreateArgs} args - Arguments to create a Orders.
     * @example
     * // Create one Orders
     * const Orders = await prisma.orders.create({
     *   data: {
     *     // ... data to create a Orders
     *   }
     * })
     * 
    **/
    create<T extends OrdersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OrdersCreateArgs<ExtArgs>>
    ): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Orders.
     *     @param {OrdersCreateManyArgs} args - Arguments to create many Orders.
     *     @example
     *     // Create many Orders
     *     const orders = await prisma.orders.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrdersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrdersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Orders.
     * @param {OrdersDeleteArgs} args - Arguments to delete one Orders.
     * @example
     * // Delete one Orders
     * const Orders = await prisma.orders.delete({
     *   where: {
     *     // ... filter to delete one Orders
     *   }
     * })
     * 
    **/
    delete<T extends OrdersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OrdersDeleteArgs<ExtArgs>>
    ): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Orders.
     * @param {OrdersUpdateArgs} args - Arguments to update one Orders.
     * @example
     * // Update one Orders
     * const orders = await prisma.orders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrdersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OrdersUpdateArgs<ExtArgs>>
    ): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Orders.
     * @param {OrdersDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.orders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrdersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrdersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const orders = await prisma.orders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrdersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OrdersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Orders.
     * @param {OrdersUpsertArgs} args - Arguments to update or create a Orders.
     * @example
     * // Update or create a Orders
     * const orders = await prisma.orders.upsert({
     *   create: {
     *     // ... data to create a Orders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Orders we want to update
     *   }
     * })
    **/
    upsert<T extends OrdersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OrdersUpsertArgs<ExtArgs>>
    ): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.orders.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrdersCountArgs>(
      args?: Subset<T, OrdersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrdersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrdersAggregateArgs>(args: Subset<T, OrdersAggregateArgs>): Prisma.PrismaPromise<GetOrdersAggregateType<T>>

    /**
     * Group by Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrdersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrdersGroupByArgs['orderBy'] }
        : { orderBy?: OrdersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrdersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrdersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Orders model
   */
  readonly fields: OrdersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Orders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrdersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    orderCreator<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    auction<T extends AuctionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuctionDefaultArgs<ExtArgs>>): Prisma__AuctionClient<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    sellingHistory<T extends Orders$sellingHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Orders$sellingHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellingHistoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Orders model
   */ 
  interface OrdersFieldRefs {
    readonly orderID: FieldRef<"Orders", 'Int'>
    readonly orderStatus: FieldRef<"Orders", 'String'>
    readonly paymentDeadline: FieldRef<"Orders", 'DateTime'>
    readonly deliveryType: FieldRef<"Orders", 'String'>
    readonly shippingAddress: FieldRef<"Orders", 'String'>
    readonly orderCreationTime: FieldRef<"Orders", 'DateTime'>
    readonly orderCompletionTime: FieldRef<"Orders", 'DateTime'>
    readonly orderCreatorID: FieldRef<"Orders", 'Int'>
    readonly auctionID: FieldRef<"Orders", 'Int'>
    readonly createdAt: FieldRef<"Orders", 'DateTime'>
    readonly updatedAt: FieldRef<"Orders", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Orders findUnique
   */
  export type OrdersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where: OrdersWhereUniqueInput
  }


  /**
   * Orders findUniqueOrThrow
   */
  export type OrdersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where: OrdersWhereUniqueInput
  }


  /**
   * Orders findFirst
   */
  export type OrdersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrdersOrderByWithRelationInput | OrdersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }


  /**
   * Orders findFirstOrThrow
   */
  export type OrdersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrdersOrderByWithRelationInput | OrdersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }


  /**
   * Orders findMany
   */
  export type OrdersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrdersOrderByWithRelationInput | OrdersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }


  /**
   * Orders create
   */
  export type OrdersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * The data needed to create a Orders.
     */
    data: XOR<OrdersCreateInput, OrdersUncheckedCreateInput>
  }


  /**
   * Orders createMany
   */
  export type OrdersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrdersCreateManyInput | OrdersCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Orders update
   */
  export type OrdersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * The data needed to update a Orders.
     */
    data: XOR<OrdersUpdateInput, OrdersUncheckedUpdateInput>
    /**
     * Choose, which Orders to update.
     */
    where: OrdersWhereUniqueInput
  }


  /**
   * Orders updateMany
   */
  export type OrdersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrdersUpdateManyMutationInput, OrdersUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrdersWhereInput
  }


  /**
   * Orders upsert
   */
  export type OrdersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * The filter to search for the Orders to update in case it exists.
     */
    where: OrdersWhereUniqueInput
    /**
     * In case the Orders found by the `where` argument doesn't exist, create a new Orders with this data.
     */
    create: XOR<OrdersCreateInput, OrdersUncheckedCreateInput>
    /**
     * In case the Orders was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrdersUpdateInput, OrdersUncheckedUpdateInput>
  }


  /**
   * Orders delete
   */
  export type OrdersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * Filter which Orders to delete.
     */
    where: OrdersWhereUniqueInput
  }


  /**
   * Orders deleteMany
   */
  export type OrdersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrdersWhereInput
  }


  /**
   * Orders.sellingHistory
   */
  export type Orders$sellingHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHistory
     */
    select?: SellingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SellingHistoryInclude<ExtArgs> | null
    where?: SellingHistoryWhereInput
    orderBy?: SellingHistoryOrderByWithRelationInput | SellingHistoryOrderByWithRelationInput[]
    cursor?: SellingHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SellingHistoryScalarFieldEnum | SellingHistoryScalarFieldEnum[]
  }


  /**
   * Orders without action
   */
  export type OrdersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrdersInclude<ExtArgs> | null
  }



  /**
   * Model SellingHistory
   */

  export type AggregateSellingHistory = {
    _count: SellingHistoryCountAggregateOutputType | null
    _avg: SellingHistoryAvgAggregateOutputType | null
    _sum: SellingHistorySumAggregateOutputType | null
    _min: SellingHistoryMinAggregateOutputType | null
    _max: SellingHistoryMaxAggregateOutputType | null
  }

  export type SellingHistoryAvgAggregateOutputType = {
    saleID: number | null
    orderID: number | null
    accountID: number | null
  }

  export type SellingHistorySumAggregateOutputType = {
    saleID: number | null
    orderID: number | null
    accountID: number | null
  }

  export type SellingHistoryMinAggregateOutputType = {
    saleID: number | null
    orderID: number | null
    accountID: number | null
  }

  export type SellingHistoryMaxAggregateOutputType = {
    saleID: number | null
    orderID: number | null
    accountID: number | null
  }

  export type SellingHistoryCountAggregateOutputType = {
    saleID: number
    orderID: number
    accountID: number
    _all: number
  }


  export type SellingHistoryAvgAggregateInputType = {
    saleID?: true
    orderID?: true
    accountID?: true
  }

  export type SellingHistorySumAggregateInputType = {
    saleID?: true
    orderID?: true
    accountID?: true
  }

  export type SellingHistoryMinAggregateInputType = {
    saleID?: true
    orderID?: true
    accountID?: true
  }

  export type SellingHistoryMaxAggregateInputType = {
    saleID?: true
    orderID?: true
    accountID?: true
  }

  export type SellingHistoryCountAggregateInputType = {
    saleID?: true
    orderID?: true
    accountID?: true
    _all?: true
  }

  export type SellingHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellingHistory to aggregate.
     */
    where?: SellingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellingHistories to fetch.
     */
    orderBy?: SellingHistoryOrderByWithRelationInput | SellingHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SellingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellingHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SellingHistories
    **/
    _count?: true | SellingHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SellingHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SellingHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SellingHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SellingHistoryMaxAggregateInputType
  }

  export type GetSellingHistoryAggregateType<T extends SellingHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSellingHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSellingHistory[P]>
      : GetScalarType<T[P], AggregateSellingHistory[P]>
  }




  export type SellingHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellingHistoryWhereInput
    orderBy?: SellingHistoryOrderByWithAggregationInput | SellingHistoryOrderByWithAggregationInput[]
    by: SellingHistoryScalarFieldEnum[] | SellingHistoryScalarFieldEnum
    having?: SellingHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SellingHistoryCountAggregateInputType | true
    _avg?: SellingHistoryAvgAggregateInputType
    _sum?: SellingHistorySumAggregateInputType
    _min?: SellingHistoryMinAggregateInputType
    _max?: SellingHistoryMaxAggregateInputType
  }

  export type SellingHistoryGroupByOutputType = {
    saleID: number
    orderID: number
    accountID: number
    _count: SellingHistoryCountAggregateOutputType | null
    _avg: SellingHistoryAvgAggregateOutputType | null
    _sum: SellingHistorySumAggregateOutputType | null
    _min: SellingHistoryMinAggregateOutputType | null
    _max: SellingHistoryMaxAggregateOutputType | null
  }

  type GetSellingHistoryGroupByPayload<T extends SellingHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SellingHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SellingHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SellingHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], SellingHistoryGroupByOutputType[P]>
        }
      >
    >


  export type SellingHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    saleID?: boolean
    orderID?: boolean
    accountID?: boolean
    order?: boolean | OrdersDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sellingHistory"]>

  export type SellingHistorySelectScalar = {
    saleID?: boolean
    orderID?: boolean
    accountID?: boolean
  }

  export type SellingHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrdersDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }


  export type $SellingHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SellingHistory"
    objects: {
      order: Prisma.$OrdersPayload<ExtArgs>
      account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      saleID: number
      orderID: number
      accountID: number
    }, ExtArgs["result"]["sellingHistory"]>
    composites: {}
  }


  type SellingHistoryGetPayload<S extends boolean | null | undefined | SellingHistoryDefaultArgs> = $Result.GetResult<Prisma.$SellingHistoryPayload, S>

  type SellingHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SellingHistoryFindManyArgs, 'select' | 'include'> & {
      select?: SellingHistoryCountAggregateInputType | true
    }

  export interface SellingHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SellingHistory'], meta: { name: 'SellingHistory' } }
    /**
     * Find zero or one SellingHistory that matches the filter.
     * @param {SellingHistoryFindUniqueArgs} args - Arguments to find a SellingHistory
     * @example
     * // Get one SellingHistory
     * const sellingHistory = await prisma.sellingHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SellingHistoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SellingHistoryFindUniqueArgs<ExtArgs>>
    ): Prisma__SellingHistoryClient<$Result.GetResult<Prisma.$SellingHistoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SellingHistory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SellingHistoryFindUniqueOrThrowArgs} args - Arguments to find a SellingHistory
     * @example
     * // Get one SellingHistory
     * const sellingHistory = await prisma.sellingHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SellingHistoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SellingHistoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SellingHistoryClient<$Result.GetResult<Prisma.$SellingHistoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SellingHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingHistoryFindFirstArgs} args - Arguments to find a SellingHistory
     * @example
     * // Get one SellingHistory
     * const sellingHistory = await prisma.sellingHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SellingHistoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SellingHistoryFindFirstArgs<ExtArgs>>
    ): Prisma__SellingHistoryClient<$Result.GetResult<Prisma.$SellingHistoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SellingHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingHistoryFindFirstOrThrowArgs} args - Arguments to find a SellingHistory
     * @example
     * // Get one SellingHistory
     * const sellingHistory = await prisma.sellingHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SellingHistoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SellingHistoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SellingHistoryClient<$Result.GetResult<Prisma.$SellingHistoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SellingHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingHistoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SellingHistories
     * const sellingHistories = await prisma.sellingHistory.findMany()
     * 
     * // Get first 10 SellingHistories
     * const sellingHistories = await prisma.sellingHistory.findMany({ take: 10 })
     * 
     * // Only select the `saleID`
     * const sellingHistoryWithSaleIDOnly = await prisma.sellingHistory.findMany({ select: { saleID: true } })
     * 
    **/
    findMany<T extends SellingHistoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SellingHistoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellingHistoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SellingHistory.
     * @param {SellingHistoryCreateArgs} args - Arguments to create a SellingHistory.
     * @example
     * // Create one SellingHistory
     * const SellingHistory = await prisma.sellingHistory.create({
     *   data: {
     *     // ... data to create a SellingHistory
     *   }
     * })
     * 
    **/
    create<T extends SellingHistoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SellingHistoryCreateArgs<ExtArgs>>
    ): Prisma__SellingHistoryClient<$Result.GetResult<Prisma.$SellingHistoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SellingHistories.
     *     @param {SellingHistoryCreateManyArgs} args - Arguments to create many SellingHistories.
     *     @example
     *     // Create many SellingHistories
     *     const sellingHistory = await prisma.sellingHistory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SellingHistoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SellingHistoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SellingHistory.
     * @param {SellingHistoryDeleteArgs} args - Arguments to delete one SellingHistory.
     * @example
     * // Delete one SellingHistory
     * const SellingHistory = await prisma.sellingHistory.delete({
     *   where: {
     *     // ... filter to delete one SellingHistory
     *   }
     * })
     * 
    **/
    delete<T extends SellingHistoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SellingHistoryDeleteArgs<ExtArgs>>
    ): Prisma__SellingHistoryClient<$Result.GetResult<Prisma.$SellingHistoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SellingHistory.
     * @param {SellingHistoryUpdateArgs} args - Arguments to update one SellingHistory.
     * @example
     * // Update one SellingHistory
     * const sellingHistory = await prisma.sellingHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SellingHistoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SellingHistoryUpdateArgs<ExtArgs>>
    ): Prisma__SellingHistoryClient<$Result.GetResult<Prisma.$SellingHistoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SellingHistories.
     * @param {SellingHistoryDeleteManyArgs} args - Arguments to filter SellingHistories to delete.
     * @example
     * // Delete a few SellingHistories
     * const { count } = await prisma.sellingHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SellingHistoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SellingHistoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellingHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SellingHistories
     * const sellingHistory = await prisma.sellingHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SellingHistoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SellingHistoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SellingHistory.
     * @param {SellingHistoryUpsertArgs} args - Arguments to update or create a SellingHistory.
     * @example
     * // Update or create a SellingHistory
     * const sellingHistory = await prisma.sellingHistory.upsert({
     *   create: {
     *     // ... data to create a SellingHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SellingHistory we want to update
     *   }
     * })
    **/
    upsert<T extends SellingHistoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SellingHistoryUpsertArgs<ExtArgs>>
    ): Prisma__SellingHistoryClient<$Result.GetResult<Prisma.$SellingHistoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SellingHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingHistoryCountArgs} args - Arguments to filter SellingHistories to count.
     * @example
     * // Count the number of SellingHistories
     * const count = await prisma.sellingHistory.count({
     *   where: {
     *     // ... the filter for the SellingHistories we want to count
     *   }
     * })
    **/
    count<T extends SellingHistoryCountArgs>(
      args?: Subset<T, SellingHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SellingHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SellingHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SellingHistoryAggregateArgs>(args: Subset<T, SellingHistoryAggregateArgs>): Prisma.PrismaPromise<GetSellingHistoryAggregateType<T>>

    /**
     * Group by SellingHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SellingHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SellingHistoryGroupByArgs['orderBy'] }
        : { orderBy?: SellingHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SellingHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSellingHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SellingHistory model
   */
  readonly fields: SellingHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SellingHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SellingHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    order<T extends OrdersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrdersDefaultArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SellingHistory model
   */ 
  interface SellingHistoryFieldRefs {
    readonly saleID: FieldRef<"SellingHistory", 'Int'>
    readonly orderID: FieldRef<"SellingHistory", 'Int'>
    readonly accountID: FieldRef<"SellingHistory", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * SellingHistory findUnique
   */
  export type SellingHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHistory
     */
    select?: SellingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SellingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SellingHistory to fetch.
     */
    where: SellingHistoryWhereUniqueInput
  }


  /**
   * SellingHistory findUniqueOrThrow
   */
  export type SellingHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHistory
     */
    select?: SellingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SellingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SellingHistory to fetch.
     */
    where: SellingHistoryWhereUniqueInput
  }


  /**
   * SellingHistory findFirst
   */
  export type SellingHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHistory
     */
    select?: SellingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SellingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SellingHistory to fetch.
     */
    where?: SellingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellingHistories to fetch.
     */
    orderBy?: SellingHistoryOrderByWithRelationInput | SellingHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellingHistories.
     */
    cursor?: SellingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellingHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellingHistories.
     */
    distinct?: SellingHistoryScalarFieldEnum | SellingHistoryScalarFieldEnum[]
  }


  /**
   * SellingHistory findFirstOrThrow
   */
  export type SellingHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHistory
     */
    select?: SellingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SellingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SellingHistory to fetch.
     */
    where?: SellingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellingHistories to fetch.
     */
    orderBy?: SellingHistoryOrderByWithRelationInput | SellingHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellingHistories.
     */
    cursor?: SellingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellingHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellingHistories.
     */
    distinct?: SellingHistoryScalarFieldEnum | SellingHistoryScalarFieldEnum[]
  }


  /**
   * SellingHistory findMany
   */
  export type SellingHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHistory
     */
    select?: SellingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SellingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SellingHistories to fetch.
     */
    where?: SellingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellingHistories to fetch.
     */
    orderBy?: SellingHistoryOrderByWithRelationInput | SellingHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SellingHistories.
     */
    cursor?: SellingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellingHistories.
     */
    skip?: number
    distinct?: SellingHistoryScalarFieldEnum | SellingHistoryScalarFieldEnum[]
  }


  /**
   * SellingHistory create
   */
  export type SellingHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHistory
     */
    select?: SellingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SellingHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a SellingHistory.
     */
    data: XOR<SellingHistoryCreateInput, SellingHistoryUncheckedCreateInput>
  }


  /**
   * SellingHistory createMany
   */
  export type SellingHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SellingHistories.
     */
    data: SellingHistoryCreateManyInput | SellingHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SellingHistory update
   */
  export type SellingHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHistory
     */
    select?: SellingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SellingHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a SellingHistory.
     */
    data: XOR<SellingHistoryUpdateInput, SellingHistoryUncheckedUpdateInput>
    /**
     * Choose, which SellingHistory to update.
     */
    where: SellingHistoryWhereUniqueInput
  }


  /**
   * SellingHistory updateMany
   */
  export type SellingHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SellingHistories.
     */
    data: XOR<SellingHistoryUpdateManyMutationInput, SellingHistoryUncheckedUpdateManyInput>
    /**
     * Filter which SellingHistories to update
     */
    where?: SellingHistoryWhereInput
  }


  /**
   * SellingHistory upsert
   */
  export type SellingHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHistory
     */
    select?: SellingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SellingHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the SellingHistory to update in case it exists.
     */
    where: SellingHistoryWhereUniqueInput
    /**
     * In case the SellingHistory found by the `where` argument doesn't exist, create a new SellingHistory with this data.
     */
    create: XOR<SellingHistoryCreateInput, SellingHistoryUncheckedCreateInput>
    /**
     * In case the SellingHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SellingHistoryUpdateInput, SellingHistoryUncheckedUpdateInput>
  }


  /**
   * SellingHistory delete
   */
  export type SellingHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHistory
     */
    select?: SellingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SellingHistoryInclude<ExtArgs> | null
    /**
     * Filter which SellingHistory to delete.
     */
    where: SellingHistoryWhereUniqueInput
  }


  /**
   * SellingHistory deleteMany
   */
  export type SellingHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellingHistories to delete
     */
    where?: SellingHistoryWhereInput
  }


  /**
   * SellingHistory without action
   */
  export type SellingHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingHistory
     */
    select?: SellingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SellingHistoryInclude<ExtArgs> | null
  }



  /**
   * Model BiddingHistory
   */

  export type AggregateBiddingHistory = {
    _count: BiddingHistoryCountAggregateOutputType | null
    _avg: BiddingHistoryAvgAggregateOutputType | null
    _sum: BiddingHistorySumAggregateOutputType | null
    _min: BiddingHistoryMinAggregateOutputType | null
    _max: BiddingHistoryMaxAggregateOutputType | null
  }

  export type BiddingHistoryAvgAggregateOutputType = {
    bidID: number | null
    bidAmount: number | null
    accountID: number | null
    auctionID: number | null
  }

  export type BiddingHistorySumAggregateOutputType = {
    bidID: number | null
    bidAmount: number | null
    accountID: number | null
    auctionID: number | null
  }

  export type BiddingHistoryMinAggregateOutputType = {
    bidID: number | null
    bidAmount: number | null
    bidTimestamp: Date | null
    bidStatus: string | null
    accountID: number | null
    auctionID: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BiddingHistoryMaxAggregateOutputType = {
    bidID: number | null
    bidAmount: number | null
    bidTimestamp: Date | null
    bidStatus: string | null
    accountID: number | null
    auctionID: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BiddingHistoryCountAggregateOutputType = {
    bidID: number
    bidAmount: number
    bidTimestamp: number
    bidStatus: number
    accountID: number
    auctionID: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BiddingHistoryAvgAggregateInputType = {
    bidID?: true
    bidAmount?: true
    accountID?: true
    auctionID?: true
  }

  export type BiddingHistorySumAggregateInputType = {
    bidID?: true
    bidAmount?: true
    accountID?: true
    auctionID?: true
  }

  export type BiddingHistoryMinAggregateInputType = {
    bidID?: true
    bidAmount?: true
    bidTimestamp?: true
    bidStatus?: true
    accountID?: true
    auctionID?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BiddingHistoryMaxAggregateInputType = {
    bidID?: true
    bidAmount?: true
    bidTimestamp?: true
    bidStatus?: true
    accountID?: true
    auctionID?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BiddingHistoryCountAggregateInputType = {
    bidID?: true
    bidAmount?: true
    bidTimestamp?: true
    bidStatus?: true
    accountID?: true
    auctionID?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BiddingHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BiddingHistory to aggregate.
     */
    where?: BiddingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BiddingHistories to fetch.
     */
    orderBy?: BiddingHistoryOrderByWithRelationInput | BiddingHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BiddingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BiddingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BiddingHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BiddingHistories
    **/
    _count?: true | BiddingHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BiddingHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BiddingHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BiddingHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BiddingHistoryMaxAggregateInputType
  }

  export type GetBiddingHistoryAggregateType<T extends BiddingHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateBiddingHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBiddingHistory[P]>
      : GetScalarType<T[P], AggregateBiddingHistory[P]>
  }




  export type BiddingHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BiddingHistoryWhereInput
    orderBy?: BiddingHistoryOrderByWithAggregationInput | BiddingHistoryOrderByWithAggregationInput[]
    by: BiddingHistoryScalarFieldEnum[] | BiddingHistoryScalarFieldEnum
    having?: BiddingHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BiddingHistoryCountAggregateInputType | true
    _avg?: BiddingHistoryAvgAggregateInputType
    _sum?: BiddingHistorySumAggregateInputType
    _min?: BiddingHistoryMinAggregateInputType
    _max?: BiddingHistoryMaxAggregateInputType
  }

  export type BiddingHistoryGroupByOutputType = {
    bidID: number
    bidAmount: number
    bidTimestamp: Date
    bidStatus: string
    accountID: number
    auctionID: number
    createdAt: Date
    updatedAt: Date
    _count: BiddingHistoryCountAggregateOutputType | null
    _avg: BiddingHistoryAvgAggregateOutputType | null
    _sum: BiddingHistorySumAggregateOutputType | null
    _min: BiddingHistoryMinAggregateOutputType | null
    _max: BiddingHistoryMaxAggregateOutputType | null
  }

  type GetBiddingHistoryGroupByPayload<T extends BiddingHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BiddingHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BiddingHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BiddingHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], BiddingHistoryGroupByOutputType[P]>
        }
      >
    >


  export type BiddingHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bidID?: boolean
    bidAmount?: boolean
    bidTimestamp?: boolean
    bidStatus?: boolean
    accountID?: boolean
    auctionID?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    auction?: boolean | AuctionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["biddingHistory"]>

  export type BiddingHistorySelectScalar = {
    bidID?: boolean
    bidAmount?: boolean
    bidTimestamp?: boolean
    bidStatus?: boolean
    accountID?: boolean
    auctionID?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BiddingHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    auction?: boolean | AuctionDefaultArgs<ExtArgs>
  }


  export type $BiddingHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BiddingHistory"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      auction: Prisma.$AuctionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      bidID: number
      bidAmount: number
      bidTimestamp: Date
      bidStatus: string
      accountID: number
      auctionID: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["biddingHistory"]>
    composites: {}
  }


  type BiddingHistoryGetPayload<S extends boolean | null | undefined | BiddingHistoryDefaultArgs> = $Result.GetResult<Prisma.$BiddingHistoryPayload, S>

  type BiddingHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BiddingHistoryFindManyArgs, 'select' | 'include'> & {
      select?: BiddingHistoryCountAggregateInputType | true
    }

  export interface BiddingHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BiddingHistory'], meta: { name: 'BiddingHistory' } }
    /**
     * Find zero or one BiddingHistory that matches the filter.
     * @param {BiddingHistoryFindUniqueArgs} args - Arguments to find a BiddingHistory
     * @example
     * // Get one BiddingHistory
     * const biddingHistory = await prisma.biddingHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BiddingHistoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BiddingHistoryFindUniqueArgs<ExtArgs>>
    ): Prisma__BiddingHistoryClient<$Result.GetResult<Prisma.$BiddingHistoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BiddingHistory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BiddingHistoryFindUniqueOrThrowArgs} args - Arguments to find a BiddingHistory
     * @example
     * // Get one BiddingHistory
     * const biddingHistory = await prisma.biddingHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BiddingHistoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BiddingHistoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BiddingHistoryClient<$Result.GetResult<Prisma.$BiddingHistoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BiddingHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiddingHistoryFindFirstArgs} args - Arguments to find a BiddingHistory
     * @example
     * // Get one BiddingHistory
     * const biddingHistory = await prisma.biddingHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BiddingHistoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BiddingHistoryFindFirstArgs<ExtArgs>>
    ): Prisma__BiddingHistoryClient<$Result.GetResult<Prisma.$BiddingHistoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BiddingHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiddingHistoryFindFirstOrThrowArgs} args - Arguments to find a BiddingHistory
     * @example
     * // Get one BiddingHistory
     * const biddingHistory = await prisma.biddingHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BiddingHistoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BiddingHistoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BiddingHistoryClient<$Result.GetResult<Prisma.$BiddingHistoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BiddingHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiddingHistoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BiddingHistories
     * const biddingHistories = await prisma.biddingHistory.findMany()
     * 
     * // Get first 10 BiddingHistories
     * const biddingHistories = await prisma.biddingHistory.findMany({ take: 10 })
     * 
     * // Only select the `bidID`
     * const biddingHistoryWithBidIDOnly = await prisma.biddingHistory.findMany({ select: { bidID: true } })
     * 
    **/
    findMany<T extends BiddingHistoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BiddingHistoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiddingHistoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BiddingHistory.
     * @param {BiddingHistoryCreateArgs} args - Arguments to create a BiddingHistory.
     * @example
     * // Create one BiddingHistory
     * const BiddingHistory = await prisma.biddingHistory.create({
     *   data: {
     *     // ... data to create a BiddingHistory
     *   }
     * })
     * 
    **/
    create<T extends BiddingHistoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BiddingHistoryCreateArgs<ExtArgs>>
    ): Prisma__BiddingHistoryClient<$Result.GetResult<Prisma.$BiddingHistoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BiddingHistories.
     *     @param {BiddingHistoryCreateManyArgs} args - Arguments to create many BiddingHistories.
     *     @example
     *     // Create many BiddingHistories
     *     const biddingHistory = await prisma.biddingHistory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BiddingHistoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BiddingHistoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BiddingHistory.
     * @param {BiddingHistoryDeleteArgs} args - Arguments to delete one BiddingHistory.
     * @example
     * // Delete one BiddingHistory
     * const BiddingHistory = await prisma.biddingHistory.delete({
     *   where: {
     *     // ... filter to delete one BiddingHistory
     *   }
     * })
     * 
    **/
    delete<T extends BiddingHistoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BiddingHistoryDeleteArgs<ExtArgs>>
    ): Prisma__BiddingHistoryClient<$Result.GetResult<Prisma.$BiddingHistoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BiddingHistory.
     * @param {BiddingHistoryUpdateArgs} args - Arguments to update one BiddingHistory.
     * @example
     * // Update one BiddingHistory
     * const biddingHistory = await prisma.biddingHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BiddingHistoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BiddingHistoryUpdateArgs<ExtArgs>>
    ): Prisma__BiddingHistoryClient<$Result.GetResult<Prisma.$BiddingHistoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BiddingHistories.
     * @param {BiddingHistoryDeleteManyArgs} args - Arguments to filter BiddingHistories to delete.
     * @example
     * // Delete a few BiddingHistories
     * const { count } = await prisma.biddingHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BiddingHistoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BiddingHistoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BiddingHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiddingHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BiddingHistories
     * const biddingHistory = await prisma.biddingHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BiddingHistoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BiddingHistoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BiddingHistory.
     * @param {BiddingHistoryUpsertArgs} args - Arguments to update or create a BiddingHistory.
     * @example
     * // Update or create a BiddingHistory
     * const biddingHistory = await prisma.biddingHistory.upsert({
     *   create: {
     *     // ... data to create a BiddingHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BiddingHistory we want to update
     *   }
     * })
    **/
    upsert<T extends BiddingHistoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BiddingHistoryUpsertArgs<ExtArgs>>
    ): Prisma__BiddingHistoryClient<$Result.GetResult<Prisma.$BiddingHistoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BiddingHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiddingHistoryCountArgs} args - Arguments to filter BiddingHistories to count.
     * @example
     * // Count the number of BiddingHistories
     * const count = await prisma.biddingHistory.count({
     *   where: {
     *     // ... the filter for the BiddingHistories we want to count
     *   }
     * })
    **/
    count<T extends BiddingHistoryCountArgs>(
      args?: Subset<T, BiddingHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BiddingHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BiddingHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiddingHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BiddingHistoryAggregateArgs>(args: Subset<T, BiddingHistoryAggregateArgs>): Prisma.PrismaPromise<GetBiddingHistoryAggregateType<T>>

    /**
     * Group by BiddingHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiddingHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BiddingHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BiddingHistoryGroupByArgs['orderBy'] }
        : { orderBy?: BiddingHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BiddingHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBiddingHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BiddingHistory model
   */
  readonly fields: BiddingHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BiddingHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BiddingHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    auction<T extends AuctionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuctionDefaultArgs<ExtArgs>>): Prisma__AuctionClient<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the BiddingHistory model
   */ 
  interface BiddingHistoryFieldRefs {
    readonly bidID: FieldRef<"BiddingHistory", 'Int'>
    readonly bidAmount: FieldRef<"BiddingHistory", 'Float'>
    readonly bidTimestamp: FieldRef<"BiddingHistory", 'DateTime'>
    readonly bidStatus: FieldRef<"BiddingHistory", 'String'>
    readonly accountID: FieldRef<"BiddingHistory", 'Int'>
    readonly auctionID: FieldRef<"BiddingHistory", 'Int'>
    readonly createdAt: FieldRef<"BiddingHistory", 'DateTime'>
    readonly updatedAt: FieldRef<"BiddingHistory", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * BiddingHistory findUnique
   */
  export type BiddingHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiddingHistory
     */
    select?: BiddingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BiddingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which BiddingHistory to fetch.
     */
    where: BiddingHistoryWhereUniqueInput
  }


  /**
   * BiddingHistory findUniqueOrThrow
   */
  export type BiddingHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiddingHistory
     */
    select?: BiddingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BiddingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which BiddingHistory to fetch.
     */
    where: BiddingHistoryWhereUniqueInput
  }


  /**
   * BiddingHistory findFirst
   */
  export type BiddingHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiddingHistory
     */
    select?: BiddingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BiddingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which BiddingHistory to fetch.
     */
    where?: BiddingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BiddingHistories to fetch.
     */
    orderBy?: BiddingHistoryOrderByWithRelationInput | BiddingHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BiddingHistories.
     */
    cursor?: BiddingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BiddingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BiddingHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BiddingHistories.
     */
    distinct?: BiddingHistoryScalarFieldEnum | BiddingHistoryScalarFieldEnum[]
  }


  /**
   * BiddingHistory findFirstOrThrow
   */
  export type BiddingHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiddingHistory
     */
    select?: BiddingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BiddingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which BiddingHistory to fetch.
     */
    where?: BiddingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BiddingHistories to fetch.
     */
    orderBy?: BiddingHistoryOrderByWithRelationInput | BiddingHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BiddingHistories.
     */
    cursor?: BiddingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BiddingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BiddingHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BiddingHistories.
     */
    distinct?: BiddingHistoryScalarFieldEnum | BiddingHistoryScalarFieldEnum[]
  }


  /**
   * BiddingHistory findMany
   */
  export type BiddingHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiddingHistory
     */
    select?: BiddingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BiddingHistoryInclude<ExtArgs> | null
    /**
     * Filter, which BiddingHistories to fetch.
     */
    where?: BiddingHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BiddingHistories to fetch.
     */
    orderBy?: BiddingHistoryOrderByWithRelationInput | BiddingHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BiddingHistories.
     */
    cursor?: BiddingHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BiddingHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BiddingHistories.
     */
    skip?: number
    distinct?: BiddingHistoryScalarFieldEnum | BiddingHistoryScalarFieldEnum[]
  }


  /**
   * BiddingHistory create
   */
  export type BiddingHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiddingHistory
     */
    select?: BiddingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BiddingHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a BiddingHistory.
     */
    data: XOR<BiddingHistoryCreateInput, BiddingHistoryUncheckedCreateInput>
  }


  /**
   * BiddingHistory createMany
   */
  export type BiddingHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BiddingHistories.
     */
    data: BiddingHistoryCreateManyInput | BiddingHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * BiddingHistory update
   */
  export type BiddingHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiddingHistory
     */
    select?: BiddingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BiddingHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a BiddingHistory.
     */
    data: XOR<BiddingHistoryUpdateInput, BiddingHistoryUncheckedUpdateInput>
    /**
     * Choose, which BiddingHistory to update.
     */
    where: BiddingHistoryWhereUniqueInput
  }


  /**
   * BiddingHistory updateMany
   */
  export type BiddingHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BiddingHistories.
     */
    data: XOR<BiddingHistoryUpdateManyMutationInput, BiddingHistoryUncheckedUpdateManyInput>
    /**
     * Filter which BiddingHistories to update
     */
    where?: BiddingHistoryWhereInput
  }


  /**
   * BiddingHistory upsert
   */
  export type BiddingHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiddingHistory
     */
    select?: BiddingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BiddingHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the BiddingHistory to update in case it exists.
     */
    where: BiddingHistoryWhereUniqueInput
    /**
     * In case the BiddingHistory found by the `where` argument doesn't exist, create a new BiddingHistory with this data.
     */
    create: XOR<BiddingHistoryCreateInput, BiddingHistoryUncheckedCreateInput>
    /**
     * In case the BiddingHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BiddingHistoryUpdateInput, BiddingHistoryUncheckedUpdateInput>
  }


  /**
   * BiddingHistory delete
   */
  export type BiddingHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiddingHistory
     */
    select?: BiddingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BiddingHistoryInclude<ExtArgs> | null
    /**
     * Filter which BiddingHistory to delete.
     */
    where: BiddingHistoryWhereUniqueInput
  }


  /**
   * BiddingHistory deleteMany
   */
  export type BiddingHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BiddingHistories to delete
     */
    where?: BiddingHistoryWhereInput
  }


  /**
   * BiddingHistory without action
   */
  export type BiddingHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiddingHistory
     */
    select?: BiddingHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BiddingHistoryInclude<ExtArgs> | null
  }



  /**
   * Model Request
   */

  export type AggregateRequest = {
    _count: RequestCountAggregateOutputType | null
    _avg: RequestAvgAggregateOutputType | null
    _sum: RequestSumAggregateOutputType | null
    _min: RequestMinAggregateOutputType | null
    _max: RequestMaxAggregateOutputType | null
  }

  export type RequestAvgAggregateOutputType = {
    requestID: number | null
    startingBid: number | null
    reservePrice: number | null
    accountID: number | null
  }

  export type RequestSumAggregateOutputType = {
    requestID: number | null
    startingBid: number | null
    reservePrice: number | null
    accountID: number | null
  }

  export type RequestMinAggregateOutputType = {
    requestID: number | null
    requestStatus: string | null
    submissionTime: Date | null
    vehicleNumber: string | null
    carImage: Buffer | null
    highlights: string | null
    equipment: string | null
    modifications: string | null
    knownFlaws: string | null
    make: string | null
    model: string | null
    interiorColor: string | null
    exteriorColor: string | null
    startingBid: number | null
    reservePrice: number | null
    accountID: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RequestMaxAggregateOutputType = {
    requestID: number | null
    requestStatus: string | null
    submissionTime: Date | null
    vehicleNumber: string | null
    carImage: Buffer | null
    highlights: string | null
    equipment: string | null
    modifications: string | null
    knownFlaws: string | null
    make: string | null
    model: string | null
    interiorColor: string | null
    exteriorColor: string | null
    startingBid: number | null
    reservePrice: number | null
    accountID: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RequestCountAggregateOutputType = {
    requestID: number
    requestStatus: number
    submissionTime: number
    vehicleNumber: number
    carImage: number
    highlights: number
    equipment: number
    modifications: number
    knownFlaws: number
    make: number
    model: number
    interiorColor: number
    exteriorColor: number
    startingBid: number
    reservePrice: number
    accountID: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RequestAvgAggregateInputType = {
    requestID?: true
    startingBid?: true
    reservePrice?: true
    accountID?: true
  }

  export type RequestSumAggregateInputType = {
    requestID?: true
    startingBid?: true
    reservePrice?: true
    accountID?: true
  }

  export type RequestMinAggregateInputType = {
    requestID?: true
    requestStatus?: true
    submissionTime?: true
    vehicleNumber?: true
    carImage?: true
    highlights?: true
    equipment?: true
    modifications?: true
    knownFlaws?: true
    make?: true
    model?: true
    interiorColor?: true
    exteriorColor?: true
    startingBid?: true
    reservePrice?: true
    accountID?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RequestMaxAggregateInputType = {
    requestID?: true
    requestStatus?: true
    submissionTime?: true
    vehicleNumber?: true
    carImage?: true
    highlights?: true
    equipment?: true
    modifications?: true
    knownFlaws?: true
    make?: true
    model?: true
    interiorColor?: true
    exteriorColor?: true
    startingBid?: true
    reservePrice?: true
    accountID?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RequestCountAggregateInputType = {
    requestID?: true
    requestStatus?: true
    submissionTime?: true
    vehicleNumber?: true
    carImage?: true
    highlights?: true
    equipment?: true
    modifications?: true
    knownFlaws?: true
    make?: true
    model?: true
    interiorColor?: true
    exteriorColor?: true
    startingBid?: true
    reservePrice?: true
    accountID?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Request to aggregate.
     */
    where?: RequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requests to fetch.
     */
    orderBy?: RequestOrderByWithRelationInput | RequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Requests
    **/
    _count?: true | RequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestMaxAggregateInputType
  }

  export type GetRequestAggregateType<T extends RequestAggregateArgs> = {
        [P in keyof T & keyof AggregateRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequest[P]>
      : GetScalarType<T[P], AggregateRequest[P]>
  }




  export type RequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestWhereInput
    orderBy?: RequestOrderByWithAggregationInput | RequestOrderByWithAggregationInput[]
    by: RequestScalarFieldEnum[] | RequestScalarFieldEnum
    having?: RequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestCountAggregateInputType | true
    _avg?: RequestAvgAggregateInputType
    _sum?: RequestSumAggregateInputType
    _min?: RequestMinAggregateInputType
    _max?: RequestMaxAggregateInputType
  }

  export type RequestGroupByOutputType = {
    requestID: number
    requestStatus: string
    submissionTime: Date
    vehicleNumber: string
    carImage: Buffer
    highlights: string | null
    equipment: string | null
    modifications: string | null
    knownFlaws: string | null
    make: string
    model: string
    interiorColor: string | null
    exteriorColor: string | null
    startingBid: number
    reservePrice: number
    accountID: number
    createdAt: Date
    updatedAt: Date
    _count: RequestCountAggregateOutputType | null
    _avg: RequestAvgAggregateOutputType | null
    _sum: RequestSumAggregateOutputType | null
    _min: RequestMinAggregateOutputType | null
    _max: RequestMaxAggregateOutputType | null
  }

  type GetRequestGroupByPayload<T extends RequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestGroupByOutputType[P]>
            : GetScalarType<T[P], RequestGroupByOutputType[P]>
        }
      >
    >


  export type RequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    requestID?: boolean
    requestStatus?: boolean
    submissionTime?: boolean
    vehicleNumber?: boolean
    carImage?: boolean
    highlights?: boolean
    equipment?: boolean
    modifications?: boolean
    knownFlaws?: boolean
    make?: boolean
    model?: boolean
    interiorColor?: boolean
    exteriorColor?: boolean
    startingBid?: boolean
    reservePrice?: boolean
    accountID?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["request"]>

  export type RequestSelectScalar = {
    requestID?: boolean
    requestStatus?: boolean
    submissionTime?: boolean
    vehicleNumber?: boolean
    carImage?: boolean
    highlights?: boolean
    equipment?: boolean
    modifications?: boolean
    knownFlaws?: boolean
    make?: boolean
    model?: boolean
    interiorColor?: boolean
    exteriorColor?: boolean
    startingBid?: boolean
    reservePrice?: boolean
    accountID?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }


  export type $RequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Request"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      requestID: number
      requestStatus: string
      submissionTime: Date
      vehicleNumber: string
      carImage: Buffer
      highlights: string | null
      equipment: string | null
      modifications: string | null
      knownFlaws: string | null
      make: string
      model: string
      interiorColor: string | null
      exteriorColor: string | null
      startingBid: number
      reservePrice: number
      accountID: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["request"]>
    composites: {}
  }


  type RequestGetPayload<S extends boolean | null | undefined | RequestDefaultArgs> = $Result.GetResult<Prisma.$RequestPayload, S>

  type RequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RequestFindManyArgs, 'select' | 'include'> & {
      select?: RequestCountAggregateInputType | true
    }

  export interface RequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Request'], meta: { name: 'Request' } }
    /**
     * Find zero or one Request that matches the filter.
     * @param {RequestFindUniqueArgs} args - Arguments to find a Request
     * @example
     * // Get one Request
     * const request = await prisma.request.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RequestFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RequestFindUniqueArgs<ExtArgs>>
    ): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Request that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RequestFindUniqueOrThrowArgs} args - Arguments to find a Request
     * @example
     * // Get one Request
     * const request = await prisma.request.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RequestFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RequestFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Request that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestFindFirstArgs} args - Arguments to find a Request
     * @example
     * // Get one Request
     * const request = await prisma.request.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RequestFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RequestFindFirstArgs<ExtArgs>>
    ): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Request that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestFindFirstOrThrowArgs} args - Arguments to find a Request
     * @example
     * // Get one Request
     * const request = await prisma.request.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RequestFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RequestFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Requests
     * const requests = await prisma.request.findMany()
     * 
     * // Get first 10 Requests
     * const requests = await prisma.request.findMany({ take: 10 })
     * 
     * // Only select the `requestID`
     * const requestWithRequestIDOnly = await prisma.request.findMany({ select: { requestID: true } })
     * 
    **/
    findMany<T extends RequestFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RequestFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Request.
     * @param {RequestCreateArgs} args - Arguments to create a Request.
     * @example
     * // Create one Request
     * const Request = await prisma.request.create({
     *   data: {
     *     // ... data to create a Request
     *   }
     * })
     * 
    **/
    create<T extends RequestCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RequestCreateArgs<ExtArgs>>
    ): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Requests.
     *     @param {RequestCreateManyArgs} args - Arguments to create many Requests.
     *     @example
     *     // Create many Requests
     *     const request = await prisma.request.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RequestCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RequestCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Request.
     * @param {RequestDeleteArgs} args - Arguments to delete one Request.
     * @example
     * // Delete one Request
     * const Request = await prisma.request.delete({
     *   where: {
     *     // ... filter to delete one Request
     *   }
     * })
     * 
    **/
    delete<T extends RequestDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RequestDeleteArgs<ExtArgs>>
    ): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Request.
     * @param {RequestUpdateArgs} args - Arguments to update one Request.
     * @example
     * // Update one Request
     * const request = await prisma.request.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RequestUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RequestUpdateArgs<ExtArgs>>
    ): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Requests.
     * @param {RequestDeleteManyArgs} args - Arguments to filter Requests to delete.
     * @example
     * // Delete a few Requests
     * const { count } = await prisma.request.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RequestDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RequestDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Requests
     * const request = await prisma.request.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RequestUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RequestUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Request.
     * @param {RequestUpsertArgs} args - Arguments to update or create a Request.
     * @example
     * // Update or create a Request
     * const request = await prisma.request.upsert({
     *   create: {
     *     // ... data to create a Request
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Request we want to update
     *   }
     * })
    **/
    upsert<T extends RequestUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RequestUpsertArgs<ExtArgs>>
    ): Prisma__RequestClient<$Result.GetResult<Prisma.$RequestPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestCountArgs} args - Arguments to filter Requests to count.
     * @example
     * // Count the number of Requests
     * const count = await prisma.request.count({
     *   where: {
     *     // ... the filter for the Requests we want to count
     *   }
     * })
    **/
    count<T extends RequestCountArgs>(
      args?: Subset<T, RequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Request.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestAggregateArgs>(args: Subset<T, RequestAggregateArgs>): Prisma.PrismaPromise<GetRequestAggregateType<T>>

    /**
     * Group by Request.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestGroupByArgs['orderBy'] }
        : { orderBy?: RequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Request model
   */
  readonly fields: RequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Request.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Request model
   */ 
  interface RequestFieldRefs {
    readonly requestID: FieldRef<"Request", 'Int'>
    readonly requestStatus: FieldRef<"Request", 'String'>
    readonly submissionTime: FieldRef<"Request", 'DateTime'>
    readonly vehicleNumber: FieldRef<"Request", 'String'>
    readonly carImage: FieldRef<"Request", 'Bytes'>
    readonly highlights: FieldRef<"Request", 'String'>
    readonly equipment: FieldRef<"Request", 'String'>
    readonly modifications: FieldRef<"Request", 'String'>
    readonly knownFlaws: FieldRef<"Request", 'String'>
    readonly make: FieldRef<"Request", 'String'>
    readonly model: FieldRef<"Request", 'String'>
    readonly interiorColor: FieldRef<"Request", 'String'>
    readonly exteriorColor: FieldRef<"Request", 'String'>
    readonly startingBid: FieldRef<"Request", 'Float'>
    readonly reservePrice: FieldRef<"Request", 'Float'>
    readonly accountID: FieldRef<"Request", 'Int'>
    readonly createdAt: FieldRef<"Request", 'DateTime'>
    readonly updatedAt: FieldRef<"Request", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Request findUnique
   */
  export type RequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * Filter, which Request to fetch.
     */
    where: RequestWhereUniqueInput
  }


  /**
   * Request findUniqueOrThrow
   */
  export type RequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * Filter, which Request to fetch.
     */
    where: RequestWhereUniqueInput
  }


  /**
   * Request findFirst
   */
  export type RequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * Filter, which Request to fetch.
     */
    where?: RequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requests to fetch.
     */
    orderBy?: RequestOrderByWithRelationInput | RequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Requests.
     */
    cursor?: RequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Requests.
     */
    distinct?: RequestScalarFieldEnum | RequestScalarFieldEnum[]
  }


  /**
   * Request findFirstOrThrow
   */
  export type RequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * Filter, which Request to fetch.
     */
    where?: RequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requests to fetch.
     */
    orderBy?: RequestOrderByWithRelationInput | RequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Requests.
     */
    cursor?: RequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Requests.
     */
    distinct?: RequestScalarFieldEnum | RequestScalarFieldEnum[]
  }


  /**
   * Request findMany
   */
  export type RequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * Filter, which Requests to fetch.
     */
    where?: RequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requests to fetch.
     */
    orderBy?: RequestOrderByWithRelationInput | RequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Requests.
     */
    cursor?: RequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requests.
     */
    skip?: number
    distinct?: RequestScalarFieldEnum | RequestScalarFieldEnum[]
  }


  /**
   * Request create
   */
  export type RequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * The data needed to create a Request.
     */
    data: XOR<RequestCreateInput, RequestUncheckedCreateInput>
  }


  /**
   * Request createMany
   */
  export type RequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Requests.
     */
    data: RequestCreateManyInput | RequestCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Request update
   */
  export type RequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * The data needed to update a Request.
     */
    data: XOR<RequestUpdateInput, RequestUncheckedUpdateInput>
    /**
     * Choose, which Request to update.
     */
    where: RequestWhereUniqueInput
  }


  /**
   * Request updateMany
   */
  export type RequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Requests.
     */
    data: XOR<RequestUpdateManyMutationInput, RequestUncheckedUpdateManyInput>
    /**
     * Filter which Requests to update
     */
    where?: RequestWhereInput
  }


  /**
   * Request upsert
   */
  export type RequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * The filter to search for the Request to update in case it exists.
     */
    where: RequestWhereUniqueInput
    /**
     * In case the Request found by the `where` argument doesn't exist, create a new Request with this data.
     */
    create: XOR<RequestCreateInput, RequestUncheckedCreateInput>
    /**
     * In case the Request was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequestUpdateInput, RequestUncheckedUpdateInput>
  }


  /**
   * Request delete
   */
  export type RequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestInclude<ExtArgs> | null
    /**
     * Filter which Request to delete.
     */
    where: RequestWhereUniqueInput
  }


  /**
   * Request deleteMany
   */
  export type RequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Requests to delete
     */
    where?: RequestWhereInput
  }


  /**
   * Request without action
   */
  export type RequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Request
     */
    select?: RequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RequestInclude<ExtArgs> | null
  }



  /**
   * Model FAQ
   */

  export type AggregateFAQ = {
    _count: FAQCountAggregateOutputType | null
    _avg: FAQAvgAggregateOutputType | null
    _sum: FAQSumAggregateOutputType | null
    _min: FAQMinAggregateOutputType | null
    _max: FAQMaxAggregateOutputType | null
  }

  export type FAQAvgAggregateOutputType = {
    questionID: number | null
  }

  export type FAQSumAggregateOutputType = {
    questionID: number | null
  }

  export type FAQMinAggregateOutputType = {
    questionID: number | null
    questionType: string | null
    questionAns: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FAQMaxAggregateOutputType = {
    questionID: number | null
    questionType: string | null
    questionAns: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FAQCountAggregateOutputType = {
    questionID: number
    questionType: number
    questionAns: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FAQAvgAggregateInputType = {
    questionID?: true
  }

  export type FAQSumAggregateInputType = {
    questionID?: true
  }

  export type FAQMinAggregateInputType = {
    questionID?: true
    questionType?: true
    questionAns?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FAQMaxAggregateInputType = {
    questionID?: true
    questionType?: true
    questionAns?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FAQCountAggregateInputType = {
    questionID?: true
    questionType?: true
    questionAns?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FAQAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FAQ to aggregate.
     */
    where?: FAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FAQS
    **/
    _count?: true | FAQCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FAQAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FAQSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FAQMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FAQMaxAggregateInputType
  }

  export type GetFAQAggregateType<T extends FAQAggregateArgs> = {
        [P in keyof T & keyof AggregateFAQ]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFAQ[P]>
      : GetScalarType<T[P], AggregateFAQ[P]>
  }




  export type FAQGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FAQWhereInput
    orderBy?: FAQOrderByWithAggregationInput | FAQOrderByWithAggregationInput[]
    by: FAQScalarFieldEnum[] | FAQScalarFieldEnum
    having?: FAQScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FAQCountAggregateInputType | true
    _avg?: FAQAvgAggregateInputType
    _sum?: FAQSumAggregateInputType
    _min?: FAQMinAggregateInputType
    _max?: FAQMaxAggregateInputType
  }

  export type FAQGroupByOutputType = {
    questionID: number
    questionType: string
    questionAns: string
    createdAt: Date
    updatedAt: Date
    _count: FAQCountAggregateOutputType | null
    _avg: FAQAvgAggregateOutputType | null
    _sum: FAQSumAggregateOutputType | null
    _min: FAQMinAggregateOutputType | null
    _max: FAQMaxAggregateOutputType | null
  }

  type GetFAQGroupByPayload<T extends FAQGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FAQGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FAQGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FAQGroupByOutputType[P]>
            : GetScalarType<T[P], FAQGroupByOutputType[P]>
        }
      >
    >


  export type FAQSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    questionID?: boolean
    questionType?: boolean
    questionAns?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["fAQ"]>

  export type FAQSelectScalar = {
    questionID?: boolean
    questionType?: boolean
    questionAns?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $FAQPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FAQ"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      questionID: number
      questionType: string
      questionAns: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fAQ"]>
    composites: {}
  }


  type FAQGetPayload<S extends boolean | null | undefined | FAQDefaultArgs> = $Result.GetResult<Prisma.$FAQPayload, S>

  type FAQCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FAQFindManyArgs, 'select' | 'include'> & {
      select?: FAQCountAggregateInputType | true
    }

  export interface FAQDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FAQ'], meta: { name: 'FAQ' } }
    /**
     * Find zero or one FAQ that matches the filter.
     * @param {FAQFindUniqueArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FAQFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FAQFindUniqueArgs<ExtArgs>>
    ): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one FAQ that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FAQFindUniqueOrThrowArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FAQFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FAQFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first FAQ that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQFindFirstArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FAQFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FAQFindFirstArgs<ExtArgs>>
    ): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first FAQ that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQFindFirstOrThrowArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FAQFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FAQFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more FAQS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FAQS
     * const fAQS = await prisma.fAQ.findMany()
     * 
     * // Get first 10 FAQS
     * const fAQS = await prisma.fAQ.findMany({ take: 10 })
     * 
     * // Only select the `questionID`
     * const fAQWithQuestionIDOnly = await prisma.fAQ.findMany({ select: { questionID: true } })
     * 
    **/
    findMany<T extends FAQFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FAQFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a FAQ.
     * @param {FAQCreateArgs} args - Arguments to create a FAQ.
     * @example
     * // Create one FAQ
     * const FAQ = await prisma.fAQ.create({
     *   data: {
     *     // ... data to create a FAQ
     *   }
     * })
     * 
    **/
    create<T extends FAQCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FAQCreateArgs<ExtArgs>>
    ): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many FAQS.
     *     @param {FAQCreateManyArgs} args - Arguments to create many FAQS.
     *     @example
     *     // Create many FAQS
     *     const fAQ = await prisma.fAQ.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FAQCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FAQCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FAQ.
     * @param {FAQDeleteArgs} args - Arguments to delete one FAQ.
     * @example
     * // Delete one FAQ
     * const FAQ = await prisma.fAQ.delete({
     *   where: {
     *     // ... filter to delete one FAQ
     *   }
     * })
     * 
    **/
    delete<T extends FAQDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FAQDeleteArgs<ExtArgs>>
    ): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one FAQ.
     * @param {FAQUpdateArgs} args - Arguments to update one FAQ.
     * @example
     * // Update one FAQ
     * const fAQ = await prisma.fAQ.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FAQUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FAQUpdateArgs<ExtArgs>>
    ): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more FAQS.
     * @param {FAQDeleteManyArgs} args - Arguments to filter FAQS to delete.
     * @example
     * // Delete a few FAQS
     * const { count } = await prisma.fAQ.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FAQDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FAQDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FAQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FAQS
     * const fAQ = await prisma.fAQ.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FAQUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FAQUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FAQ.
     * @param {FAQUpsertArgs} args - Arguments to update or create a FAQ.
     * @example
     * // Update or create a FAQ
     * const fAQ = await prisma.fAQ.upsert({
     *   create: {
     *     // ... data to create a FAQ
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FAQ we want to update
     *   }
     * })
    **/
    upsert<T extends FAQUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FAQUpsertArgs<ExtArgs>>
    ): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of FAQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQCountArgs} args - Arguments to filter FAQS to count.
     * @example
     * // Count the number of FAQS
     * const count = await prisma.fAQ.count({
     *   where: {
     *     // ... the filter for the FAQS we want to count
     *   }
     * })
    **/
    count<T extends FAQCountArgs>(
      args?: Subset<T, FAQCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FAQCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FAQ.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FAQAggregateArgs>(args: Subset<T, FAQAggregateArgs>): Prisma.PrismaPromise<GetFAQAggregateType<T>>

    /**
     * Group by FAQ.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FAQGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FAQGroupByArgs['orderBy'] }
        : { orderBy?: FAQGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FAQGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFAQGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FAQ model
   */
  readonly fields: FAQFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FAQ.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FAQClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the FAQ model
   */ 
  interface FAQFieldRefs {
    readonly questionID: FieldRef<"FAQ", 'Int'>
    readonly questionType: FieldRef<"FAQ", 'String'>
    readonly questionAns: FieldRef<"FAQ", 'String'>
    readonly createdAt: FieldRef<"FAQ", 'DateTime'>
    readonly updatedAt: FieldRef<"FAQ", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * FAQ findUnique
   */
  export type FAQFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Filter, which FAQ to fetch.
     */
    where: FAQWhereUniqueInput
  }


  /**
   * FAQ findUniqueOrThrow
   */
  export type FAQFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Filter, which FAQ to fetch.
     */
    where: FAQWhereUniqueInput
  }


  /**
   * FAQ findFirst
   */
  export type FAQFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Filter, which FAQ to fetch.
     */
    where?: FAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FAQS.
     */
    cursor?: FAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FAQS.
     */
    distinct?: FAQScalarFieldEnum | FAQScalarFieldEnum[]
  }


  /**
   * FAQ findFirstOrThrow
   */
  export type FAQFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Filter, which FAQ to fetch.
     */
    where?: FAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FAQS.
     */
    cursor?: FAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FAQS.
     */
    distinct?: FAQScalarFieldEnum | FAQScalarFieldEnum[]
  }


  /**
   * FAQ findMany
   */
  export type FAQFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Filter, which FAQS to fetch.
     */
    where?: FAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FAQS.
     */
    cursor?: FAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    distinct?: FAQScalarFieldEnum | FAQScalarFieldEnum[]
  }


  /**
   * FAQ create
   */
  export type FAQCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * The data needed to create a FAQ.
     */
    data: XOR<FAQCreateInput, FAQUncheckedCreateInput>
  }


  /**
   * FAQ createMany
   */
  export type FAQCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FAQS.
     */
    data: FAQCreateManyInput | FAQCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * FAQ update
   */
  export type FAQUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * The data needed to update a FAQ.
     */
    data: XOR<FAQUpdateInput, FAQUncheckedUpdateInput>
    /**
     * Choose, which FAQ to update.
     */
    where: FAQWhereUniqueInput
  }


  /**
   * FAQ updateMany
   */
  export type FAQUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FAQS.
     */
    data: XOR<FAQUpdateManyMutationInput, FAQUncheckedUpdateManyInput>
    /**
     * Filter which FAQS to update
     */
    where?: FAQWhereInput
  }


  /**
   * FAQ upsert
   */
  export type FAQUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * The filter to search for the FAQ to update in case it exists.
     */
    where: FAQWhereUniqueInput
    /**
     * In case the FAQ found by the `where` argument doesn't exist, create a new FAQ with this data.
     */
    create: XOR<FAQCreateInput, FAQUncheckedCreateInput>
    /**
     * In case the FAQ was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FAQUpdateInput, FAQUncheckedUpdateInput>
  }


  /**
   * FAQ delete
   */
  export type FAQDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Filter which FAQ to delete.
     */
    where: FAQWhereUniqueInput
  }


  /**
   * FAQ deleteMany
   */
  export type FAQDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FAQS to delete
     */
    where?: FAQWhereInput
  }


  /**
   * FAQ without action
   */
  export type FAQDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    userID: 'userID',
    firstName: 'firstName',
    lastName: 'lastName',
    address: 'address',
    phoneNumber: 'phoneNumber',
    emailAddress: 'emailAddress',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    accountID: 'accountID',
    accountType: 'accountType',
    accountStatus: 'accountStatus',
    username: 'username',
    password: 'password',
    userID: 'userID',
    token2fa: 'token2fa',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const CarScalarFieldEnum: {
    carID: 'carID',
    vehicleNumber: 'vehicleNumber',
    carImage: 'carImage',
    highlights: 'highlights',
    equipment: 'equipment',
    modifications: 'modifications',
    knownFlaws: 'knownFlaws',
    make: 'make',
    model: 'model',
    interiorColor: 'interiorColor',
    exteriorColor: 'exteriorColor',
    startingBid: 'startingBid',
    reservePrice: 'reservePrice',
    accountID: 'accountID',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CarScalarFieldEnum = (typeof CarScalarFieldEnum)[keyof typeof CarScalarFieldEnum]


  export const AuctionScalarFieldEnum: {
    auctionID: 'auctionID',
    auctionStatus: 'auctionStatus',
    startDate: 'startDate',
    endDate: 'endDate',
    currentHighestBid: 'currentHighestBid',
    auctionCreationTime: 'auctionCreationTime',
    auctionCreatorID: 'auctionCreatorID',
    carID: 'carID',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuctionScalarFieldEnum = (typeof AuctionScalarFieldEnum)[keyof typeof AuctionScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    commentID: 'commentID',
    details: 'details',
    accountID: 'accountID',
    auctionID: 'auctionID',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const OrdersScalarFieldEnum: {
    orderID: 'orderID',
    orderStatus: 'orderStatus',
    paymentDeadline: 'paymentDeadline',
    deliveryType: 'deliveryType',
    shippingAddress: 'shippingAddress',
    orderCreationTime: 'orderCreationTime',
    orderCompletionTime: 'orderCompletionTime',
    orderCreatorID: 'orderCreatorID',
    auctionID: 'auctionID',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrdersScalarFieldEnum = (typeof OrdersScalarFieldEnum)[keyof typeof OrdersScalarFieldEnum]


  export const SellingHistoryScalarFieldEnum: {
    saleID: 'saleID',
    orderID: 'orderID',
    accountID: 'accountID'
  };

  export type SellingHistoryScalarFieldEnum = (typeof SellingHistoryScalarFieldEnum)[keyof typeof SellingHistoryScalarFieldEnum]


  export const BiddingHistoryScalarFieldEnum: {
    bidID: 'bidID',
    bidAmount: 'bidAmount',
    bidTimestamp: 'bidTimestamp',
    bidStatus: 'bidStatus',
    accountID: 'accountID',
    auctionID: 'auctionID',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BiddingHistoryScalarFieldEnum = (typeof BiddingHistoryScalarFieldEnum)[keyof typeof BiddingHistoryScalarFieldEnum]


  export const RequestScalarFieldEnum: {
    requestID: 'requestID',
    requestStatus: 'requestStatus',
    submissionTime: 'submissionTime',
    vehicleNumber: 'vehicleNumber',
    carImage: 'carImage',
    highlights: 'highlights',
    equipment: 'equipment',
    modifications: 'modifications',
    knownFlaws: 'knownFlaws',
    make: 'make',
    model: 'model',
    interiorColor: 'interiorColor',
    exteriorColor: 'exteriorColor',
    startingBid: 'startingBid',
    reservePrice: 'reservePrice',
    accountID: 'accountID',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RequestScalarFieldEnum = (typeof RequestScalarFieldEnum)[keyof typeof RequestScalarFieldEnum]


  export const FAQScalarFieldEnum: {
    questionID: 'questionID',
    questionType: 'questionType',
    questionAns: 'questionAns',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FAQScalarFieldEnum = (typeof FAQScalarFieldEnum)[keyof typeof FAQScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    userID?: IntFilter<"User"> | number
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    address?: StringNullableFilter<"User"> | string | null
    phoneNumber?: StringFilter<"User"> | string
    emailAddress?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    userID?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    address?: SortOrderInput | SortOrder
    phoneNumber?: SortOrder
    emailAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    userID?: number
    emailAddress?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    address?: StringNullableFilter<"User"> | string | null
    phoneNumber?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
  }, "userID" | "emailAddress">

  export type UserOrderByWithAggregationInput = {
    userID?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    address?: SortOrderInput | SortOrder
    phoneNumber?: SortOrder
    emailAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    userID?: IntWithAggregatesFilter<"User"> | number
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
    phoneNumber?: StringWithAggregatesFilter<"User"> | string
    emailAddress?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    accountID?: IntFilter<"Account"> | number
    accountType?: StringFilter<"Account"> | string
    accountStatus?: StringFilter<"Account"> | string
    username?: StringFilter<"Account"> | string
    password?: StringFilter<"Account"> | string
    userID?: IntNullableFilter<"Account"> | number | null
    token2fa?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    cars?: CarListRelationFilter
    auctions?: AuctionListRelationFilter
    comments?: CommentListRelationFilter
    orders?: OrdersListRelationFilter
    sellingHistory?: SellingHistoryListRelationFilter
    biddingHistory?: BiddingHistoryListRelationFilter
    requests?: RequestListRelationFilter
  }

  export type AccountOrderByWithRelationInput = {
    accountID?: SortOrder
    accountType?: SortOrder
    accountStatus?: SortOrder
    username?: SortOrder
    password?: SortOrder
    userID?: SortOrderInput | SortOrder
    token2fa?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    cars?: CarOrderByRelationAggregateInput
    auctions?: AuctionOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    orders?: OrdersOrderByRelationAggregateInput
    sellingHistory?: SellingHistoryOrderByRelationAggregateInput
    biddingHistory?: BiddingHistoryOrderByRelationAggregateInput
    requests?: RequestOrderByRelationAggregateInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    accountID?: number
    username?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    accountType?: StringFilter<"Account"> | string
    accountStatus?: StringFilter<"Account"> | string
    password?: StringFilter<"Account"> | string
    userID?: IntNullableFilter<"Account"> | number | null
    token2fa?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    cars?: CarListRelationFilter
    auctions?: AuctionListRelationFilter
    comments?: CommentListRelationFilter
    orders?: OrdersListRelationFilter
    sellingHistory?: SellingHistoryListRelationFilter
    biddingHistory?: BiddingHistoryListRelationFilter
    requests?: RequestListRelationFilter
  }, "accountID" | "username">

  export type AccountOrderByWithAggregationInput = {
    accountID?: SortOrder
    accountType?: SortOrder
    accountStatus?: SortOrder
    username?: SortOrder
    password?: SortOrder
    userID?: SortOrderInput | SortOrder
    token2fa?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    accountID?: IntWithAggregatesFilter<"Account"> | number
    accountType?: StringWithAggregatesFilter<"Account"> | string
    accountStatus?: StringWithAggregatesFilter<"Account"> | string
    username?: StringWithAggregatesFilter<"Account"> | string
    password?: StringWithAggregatesFilter<"Account"> | string
    userID?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token2fa?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type CarWhereInput = {
    AND?: CarWhereInput | CarWhereInput[]
    OR?: CarWhereInput[]
    NOT?: CarWhereInput | CarWhereInput[]
    carID?: IntFilter<"Car"> | number
    vehicleNumber?: StringFilter<"Car"> | string
    carImage?: BytesNullableFilter<"Car"> | Buffer | null
    highlights?: StringNullableFilter<"Car"> | string | null
    equipment?: StringNullableFilter<"Car"> | string | null
    modifications?: StringNullableFilter<"Car"> | string | null
    knownFlaws?: StringNullableFilter<"Car"> | string | null
    make?: StringFilter<"Car"> | string
    model?: StringFilter<"Car"> | string
    interiorColor?: StringNullableFilter<"Car"> | string | null
    exteriorColor?: StringNullableFilter<"Car"> | string | null
    startingBid?: FloatFilter<"Car"> | number
    reservePrice?: FloatFilter<"Car"> | number
    accountID?: IntFilter<"Car"> | number
    createdAt?: DateTimeFilter<"Car"> | Date | string
    updatedAt?: DateTimeFilter<"Car"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    auctions?: AuctionListRelationFilter
  }

  export type CarOrderByWithRelationInput = {
    carID?: SortOrder
    vehicleNumber?: SortOrder
    carImage?: SortOrderInput | SortOrder
    highlights?: SortOrderInput | SortOrder
    equipment?: SortOrderInput | SortOrder
    modifications?: SortOrderInput | SortOrder
    knownFlaws?: SortOrderInput | SortOrder
    make?: SortOrder
    model?: SortOrder
    interiorColor?: SortOrderInput | SortOrder
    exteriorColor?: SortOrderInput | SortOrder
    startingBid?: SortOrder
    reservePrice?: SortOrder
    accountID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
    auctions?: AuctionOrderByRelationAggregateInput
  }

  export type CarWhereUniqueInput = Prisma.AtLeast<{
    carID?: number
    AND?: CarWhereInput | CarWhereInput[]
    OR?: CarWhereInput[]
    NOT?: CarWhereInput | CarWhereInput[]
    vehicleNumber?: StringFilter<"Car"> | string
    carImage?: BytesNullableFilter<"Car"> | Buffer | null
    highlights?: StringNullableFilter<"Car"> | string | null
    equipment?: StringNullableFilter<"Car"> | string | null
    modifications?: StringNullableFilter<"Car"> | string | null
    knownFlaws?: StringNullableFilter<"Car"> | string | null
    make?: StringFilter<"Car"> | string
    model?: StringFilter<"Car"> | string
    interiorColor?: StringNullableFilter<"Car"> | string | null
    exteriorColor?: StringNullableFilter<"Car"> | string | null
    startingBid?: FloatFilter<"Car"> | number
    reservePrice?: FloatFilter<"Car"> | number
    accountID?: IntFilter<"Car"> | number
    createdAt?: DateTimeFilter<"Car"> | Date | string
    updatedAt?: DateTimeFilter<"Car"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    auctions?: AuctionListRelationFilter
  }, "carID">

  export type CarOrderByWithAggregationInput = {
    carID?: SortOrder
    vehicleNumber?: SortOrder
    carImage?: SortOrderInput | SortOrder
    highlights?: SortOrderInput | SortOrder
    equipment?: SortOrderInput | SortOrder
    modifications?: SortOrderInput | SortOrder
    knownFlaws?: SortOrderInput | SortOrder
    make?: SortOrder
    model?: SortOrder
    interiorColor?: SortOrderInput | SortOrder
    exteriorColor?: SortOrderInput | SortOrder
    startingBid?: SortOrder
    reservePrice?: SortOrder
    accountID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CarCountOrderByAggregateInput
    _avg?: CarAvgOrderByAggregateInput
    _max?: CarMaxOrderByAggregateInput
    _min?: CarMinOrderByAggregateInput
    _sum?: CarSumOrderByAggregateInput
  }

  export type CarScalarWhereWithAggregatesInput = {
    AND?: CarScalarWhereWithAggregatesInput | CarScalarWhereWithAggregatesInput[]
    OR?: CarScalarWhereWithAggregatesInput[]
    NOT?: CarScalarWhereWithAggregatesInput | CarScalarWhereWithAggregatesInput[]
    carID?: IntWithAggregatesFilter<"Car"> | number
    vehicleNumber?: StringWithAggregatesFilter<"Car"> | string
    carImage?: BytesNullableWithAggregatesFilter<"Car"> | Buffer | null
    highlights?: StringNullableWithAggregatesFilter<"Car"> | string | null
    equipment?: StringNullableWithAggregatesFilter<"Car"> | string | null
    modifications?: StringNullableWithAggregatesFilter<"Car"> | string | null
    knownFlaws?: StringNullableWithAggregatesFilter<"Car"> | string | null
    make?: StringWithAggregatesFilter<"Car"> | string
    model?: StringWithAggregatesFilter<"Car"> | string
    interiorColor?: StringNullableWithAggregatesFilter<"Car"> | string | null
    exteriorColor?: StringNullableWithAggregatesFilter<"Car"> | string | null
    startingBid?: FloatWithAggregatesFilter<"Car"> | number
    reservePrice?: FloatWithAggregatesFilter<"Car"> | number
    accountID?: IntWithAggregatesFilter<"Car"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Car"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Car"> | Date | string
  }

  export type AuctionWhereInput = {
    AND?: AuctionWhereInput | AuctionWhereInput[]
    OR?: AuctionWhereInput[]
    NOT?: AuctionWhereInput | AuctionWhereInput[]
    auctionID?: IntFilter<"Auction"> | number
    auctionStatus?: StringFilter<"Auction"> | string
    startDate?: DateTimeFilter<"Auction"> | Date | string
    endDate?: DateTimeFilter<"Auction"> | Date | string
    currentHighestBid?: FloatFilter<"Auction"> | number
    auctionCreationTime?: DateTimeFilter<"Auction"> | Date | string
    auctionCreatorID?: IntFilter<"Auction"> | number
    carID?: IntFilter<"Auction"> | number
    createdAt?: DateTimeFilter<"Auction"> | Date | string
    updatedAt?: DateTimeFilter<"Auction"> | Date | string
    auctionCreator?: XOR<AccountRelationFilter, AccountWhereInput>
    car?: XOR<CarRelationFilter, CarWhereInput>
    comments?: CommentListRelationFilter
    orders?: OrdersListRelationFilter
    biddingHistories?: BiddingHistoryListRelationFilter
  }

  export type AuctionOrderByWithRelationInput = {
    auctionID?: SortOrder
    auctionStatus?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    currentHighestBid?: SortOrder
    auctionCreationTime?: SortOrder
    auctionCreatorID?: SortOrder
    carID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    auctionCreator?: AccountOrderByWithRelationInput
    car?: CarOrderByWithRelationInput
    comments?: CommentOrderByRelationAggregateInput
    orders?: OrdersOrderByRelationAggregateInput
    biddingHistories?: BiddingHistoryOrderByRelationAggregateInput
  }

  export type AuctionWhereUniqueInput = Prisma.AtLeast<{
    auctionID?: number
    AND?: AuctionWhereInput | AuctionWhereInput[]
    OR?: AuctionWhereInput[]
    NOT?: AuctionWhereInput | AuctionWhereInput[]
    auctionStatus?: StringFilter<"Auction"> | string
    startDate?: DateTimeFilter<"Auction"> | Date | string
    endDate?: DateTimeFilter<"Auction"> | Date | string
    currentHighestBid?: FloatFilter<"Auction"> | number
    auctionCreationTime?: DateTimeFilter<"Auction"> | Date | string
    auctionCreatorID?: IntFilter<"Auction"> | number
    carID?: IntFilter<"Auction"> | number
    createdAt?: DateTimeFilter<"Auction"> | Date | string
    updatedAt?: DateTimeFilter<"Auction"> | Date | string
    auctionCreator?: XOR<AccountRelationFilter, AccountWhereInput>
    car?: XOR<CarRelationFilter, CarWhereInput>
    comments?: CommentListRelationFilter
    orders?: OrdersListRelationFilter
    biddingHistories?: BiddingHistoryListRelationFilter
  }, "auctionID">

  export type AuctionOrderByWithAggregationInput = {
    auctionID?: SortOrder
    auctionStatus?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    currentHighestBid?: SortOrder
    auctionCreationTime?: SortOrder
    auctionCreatorID?: SortOrder
    carID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AuctionCountOrderByAggregateInput
    _avg?: AuctionAvgOrderByAggregateInput
    _max?: AuctionMaxOrderByAggregateInput
    _min?: AuctionMinOrderByAggregateInput
    _sum?: AuctionSumOrderByAggregateInput
  }

  export type AuctionScalarWhereWithAggregatesInput = {
    AND?: AuctionScalarWhereWithAggregatesInput | AuctionScalarWhereWithAggregatesInput[]
    OR?: AuctionScalarWhereWithAggregatesInput[]
    NOT?: AuctionScalarWhereWithAggregatesInput | AuctionScalarWhereWithAggregatesInput[]
    auctionID?: IntWithAggregatesFilter<"Auction"> | number
    auctionStatus?: StringWithAggregatesFilter<"Auction"> | string
    startDate?: DateTimeWithAggregatesFilter<"Auction"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Auction"> | Date | string
    currentHighestBid?: FloatWithAggregatesFilter<"Auction"> | number
    auctionCreationTime?: DateTimeWithAggregatesFilter<"Auction"> | Date | string
    auctionCreatorID?: IntWithAggregatesFilter<"Auction"> | number
    carID?: IntWithAggregatesFilter<"Auction"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Auction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Auction"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    commentID?: IntFilter<"Comment"> | number
    details?: StringFilter<"Comment"> | string
    accountID?: IntFilter<"Comment"> | number
    auctionID?: IntFilter<"Comment"> | number
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    auction?: XOR<AuctionRelationFilter, AuctionWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    commentID?: SortOrder
    details?: SortOrder
    accountID?: SortOrder
    auctionID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
    auction?: AuctionOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    commentID?: number
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    details?: StringFilter<"Comment"> | string
    accountID?: IntFilter<"Comment"> | number
    auctionID?: IntFilter<"Comment"> | number
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    auction?: XOR<AuctionRelationFilter, AuctionWhereInput>
  }, "commentID">

  export type CommentOrderByWithAggregationInput = {
    commentID?: SortOrder
    details?: SortOrder
    accountID?: SortOrder
    auctionID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    commentID?: IntWithAggregatesFilter<"Comment"> | number
    details?: StringWithAggregatesFilter<"Comment"> | string
    accountID?: IntWithAggregatesFilter<"Comment"> | number
    auctionID?: IntWithAggregatesFilter<"Comment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type OrdersWhereInput = {
    AND?: OrdersWhereInput | OrdersWhereInput[]
    OR?: OrdersWhereInput[]
    NOT?: OrdersWhereInput | OrdersWhereInput[]
    orderID?: IntFilter<"Orders"> | number
    orderStatus?: StringFilter<"Orders"> | string
    paymentDeadline?: DateTimeFilter<"Orders"> | Date | string
    deliveryType?: StringFilter<"Orders"> | string
    shippingAddress?: StringNullableFilter<"Orders"> | string | null
    orderCreationTime?: DateTimeFilter<"Orders"> | Date | string
    orderCompletionTime?: DateTimeNullableFilter<"Orders"> | Date | string | null
    orderCreatorID?: IntFilter<"Orders"> | number
    auctionID?: IntFilter<"Orders"> | number
    createdAt?: DateTimeFilter<"Orders"> | Date | string
    updatedAt?: DateTimeFilter<"Orders"> | Date | string
    orderCreator?: XOR<AccountRelationFilter, AccountWhereInput>
    auction?: XOR<AuctionRelationFilter, AuctionWhereInput>
    sellingHistory?: SellingHistoryListRelationFilter
  }

  export type OrdersOrderByWithRelationInput = {
    orderID?: SortOrder
    orderStatus?: SortOrder
    paymentDeadline?: SortOrder
    deliveryType?: SortOrder
    shippingAddress?: SortOrderInput | SortOrder
    orderCreationTime?: SortOrder
    orderCompletionTime?: SortOrderInput | SortOrder
    orderCreatorID?: SortOrder
    auctionID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderCreator?: AccountOrderByWithRelationInput
    auction?: AuctionOrderByWithRelationInput
    sellingHistory?: SellingHistoryOrderByRelationAggregateInput
  }

  export type OrdersWhereUniqueInput = Prisma.AtLeast<{
    orderID?: number
    AND?: OrdersWhereInput | OrdersWhereInput[]
    OR?: OrdersWhereInput[]
    NOT?: OrdersWhereInput | OrdersWhereInput[]
    orderStatus?: StringFilter<"Orders"> | string
    paymentDeadline?: DateTimeFilter<"Orders"> | Date | string
    deliveryType?: StringFilter<"Orders"> | string
    shippingAddress?: StringNullableFilter<"Orders"> | string | null
    orderCreationTime?: DateTimeFilter<"Orders"> | Date | string
    orderCompletionTime?: DateTimeNullableFilter<"Orders"> | Date | string | null
    orderCreatorID?: IntFilter<"Orders"> | number
    auctionID?: IntFilter<"Orders"> | number
    createdAt?: DateTimeFilter<"Orders"> | Date | string
    updatedAt?: DateTimeFilter<"Orders"> | Date | string
    orderCreator?: XOR<AccountRelationFilter, AccountWhereInput>
    auction?: XOR<AuctionRelationFilter, AuctionWhereInput>
    sellingHistory?: SellingHistoryListRelationFilter
  }, "orderID">

  export type OrdersOrderByWithAggregationInput = {
    orderID?: SortOrder
    orderStatus?: SortOrder
    paymentDeadline?: SortOrder
    deliveryType?: SortOrder
    shippingAddress?: SortOrderInput | SortOrder
    orderCreationTime?: SortOrder
    orderCompletionTime?: SortOrderInput | SortOrder
    orderCreatorID?: SortOrder
    auctionID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrdersCountOrderByAggregateInput
    _avg?: OrdersAvgOrderByAggregateInput
    _max?: OrdersMaxOrderByAggregateInput
    _min?: OrdersMinOrderByAggregateInput
    _sum?: OrdersSumOrderByAggregateInput
  }

  export type OrdersScalarWhereWithAggregatesInput = {
    AND?: OrdersScalarWhereWithAggregatesInput | OrdersScalarWhereWithAggregatesInput[]
    OR?: OrdersScalarWhereWithAggregatesInput[]
    NOT?: OrdersScalarWhereWithAggregatesInput | OrdersScalarWhereWithAggregatesInput[]
    orderID?: IntWithAggregatesFilter<"Orders"> | number
    orderStatus?: StringWithAggregatesFilter<"Orders"> | string
    paymentDeadline?: DateTimeWithAggregatesFilter<"Orders"> | Date | string
    deliveryType?: StringWithAggregatesFilter<"Orders"> | string
    shippingAddress?: StringNullableWithAggregatesFilter<"Orders"> | string | null
    orderCreationTime?: DateTimeWithAggregatesFilter<"Orders"> | Date | string
    orderCompletionTime?: DateTimeNullableWithAggregatesFilter<"Orders"> | Date | string | null
    orderCreatorID?: IntWithAggregatesFilter<"Orders"> | number
    auctionID?: IntWithAggregatesFilter<"Orders"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Orders"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Orders"> | Date | string
  }

  export type SellingHistoryWhereInput = {
    AND?: SellingHistoryWhereInput | SellingHistoryWhereInput[]
    OR?: SellingHistoryWhereInput[]
    NOT?: SellingHistoryWhereInput | SellingHistoryWhereInput[]
    saleID?: IntFilter<"SellingHistory"> | number
    orderID?: IntFilter<"SellingHistory"> | number
    accountID?: IntFilter<"SellingHistory"> | number
    order?: XOR<OrdersRelationFilter, OrdersWhereInput>
    account?: XOR<AccountRelationFilter, AccountWhereInput>
  }

  export type SellingHistoryOrderByWithRelationInput = {
    saleID?: SortOrder
    orderID?: SortOrder
    accountID?: SortOrder
    order?: OrdersOrderByWithRelationInput
    account?: AccountOrderByWithRelationInput
  }

  export type SellingHistoryWhereUniqueInput = Prisma.AtLeast<{
    saleID?: number
    AND?: SellingHistoryWhereInput | SellingHistoryWhereInput[]
    OR?: SellingHistoryWhereInput[]
    NOT?: SellingHistoryWhereInput | SellingHistoryWhereInput[]
    orderID?: IntFilter<"SellingHistory"> | number
    accountID?: IntFilter<"SellingHistory"> | number
    order?: XOR<OrdersRelationFilter, OrdersWhereInput>
    account?: XOR<AccountRelationFilter, AccountWhereInput>
  }, "saleID">

  export type SellingHistoryOrderByWithAggregationInput = {
    saleID?: SortOrder
    orderID?: SortOrder
    accountID?: SortOrder
    _count?: SellingHistoryCountOrderByAggregateInput
    _avg?: SellingHistoryAvgOrderByAggregateInput
    _max?: SellingHistoryMaxOrderByAggregateInput
    _min?: SellingHistoryMinOrderByAggregateInput
    _sum?: SellingHistorySumOrderByAggregateInput
  }

  export type SellingHistoryScalarWhereWithAggregatesInput = {
    AND?: SellingHistoryScalarWhereWithAggregatesInput | SellingHistoryScalarWhereWithAggregatesInput[]
    OR?: SellingHistoryScalarWhereWithAggregatesInput[]
    NOT?: SellingHistoryScalarWhereWithAggregatesInput | SellingHistoryScalarWhereWithAggregatesInput[]
    saleID?: IntWithAggregatesFilter<"SellingHistory"> | number
    orderID?: IntWithAggregatesFilter<"SellingHistory"> | number
    accountID?: IntWithAggregatesFilter<"SellingHistory"> | number
  }

  export type BiddingHistoryWhereInput = {
    AND?: BiddingHistoryWhereInput | BiddingHistoryWhereInput[]
    OR?: BiddingHistoryWhereInput[]
    NOT?: BiddingHistoryWhereInput | BiddingHistoryWhereInput[]
    bidID?: IntFilter<"BiddingHistory"> | number
    bidAmount?: FloatFilter<"BiddingHistory"> | number
    bidTimestamp?: DateTimeFilter<"BiddingHistory"> | Date | string
    bidStatus?: StringFilter<"BiddingHistory"> | string
    accountID?: IntFilter<"BiddingHistory"> | number
    auctionID?: IntFilter<"BiddingHistory"> | number
    createdAt?: DateTimeFilter<"BiddingHistory"> | Date | string
    updatedAt?: DateTimeFilter<"BiddingHistory"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    auction?: XOR<AuctionRelationFilter, AuctionWhereInput>
  }

  export type BiddingHistoryOrderByWithRelationInput = {
    bidID?: SortOrder
    bidAmount?: SortOrder
    bidTimestamp?: SortOrder
    bidStatus?: SortOrder
    accountID?: SortOrder
    auctionID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
    auction?: AuctionOrderByWithRelationInput
  }

  export type BiddingHistoryWhereUniqueInput = Prisma.AtLeast<{
    bidID?: number
    AND?: BiddingHistoryWhereInput | BiddingHistoryWhereInput[]
    OR?: BiddingHistoryWhereInput[]
    NOT?: BiddingHistoryWhereInput | BiddingHistoryWhereInput[]
    bidAmount?: FloatFilter<"BiddingHistory"> | number
    bidTimestamp?: DateTimeFilter<"BiddingHistory"> | Date | string
    bidStatus?: StringFilter<"BiddingHistory"> | string
    accountID?: IntFilter<"BiddingHistory"> | number
    auctionID?: IntFilter<"BiddingHistory"> | number
    createdAt?: DateTimeFilter<"BiddingHistory"> | Date | string
    updatedAt?: DateTimeFilter<"BiddingHistory"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    auction?: XOR<AuctionRelationFilter, AuctionWhereInput>
  }, "bidID">

  export type BiddingHistoryOrderByWithAggregationInput = {
    bidID?: SortOrder
    bidAmount?: SortOrder
    bidTimestamp?: SortOrder
    bidStatus?: SortOrder
    accountID?: SortOrder
    auctionID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BiddingHistoryCountOrderByAggregateInput
    _avg?: BiddingHistoryAvgOrderByAggregateInput
    _max?: BiddingHistoryMaxOrderByAggregateInput
    _min?: BiddingHistoryMinOrderByAggregateInput
    _sum?: BiddingHistorySumOrderByAggregateInput
  }

  export type BiddingHistoryScalarWhereWithAggregatesInput = {
    AND?: BiddingHistoryScalarWhereWithAggregatesInput | BiddingHistoryScalarWhereWithAggregatesInput[]
    OR?: BiddingHistoryScalarWhereWithAggregatesInput[]
    NOT?: BiddingHistoryScalarWhereWithAggregatesInput | BiddingHistoryScalarWhereWithAggregatesInput[]
    bidID?: IntWithAggregatesFilter<"BiddingHistory"> | number
    bidAmount?: FloatWithAggregatesFilter<"BiddingHistory"> | number
    bidTimestamp?: DateTimeWithAggregatesFilter<"BiddingHistory"> | Date | string
    bidStatus?: StringWithAggregatesFilter<"BiddingHistory"> | string
    accountID?: IntWithAggregatesFilter<"BiddingHistory"> | number
    auctionID?: IntWithAggregatesFilter<"BiddingHistory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BiddingHistory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BiddingHistory"> | Date | string
  }

  export type RequestWhereInput = {
    AND?: RequestWhereInput | RequestWhereInput[]
    OR?: RequestWhereInput[]
    NOT?: RequestWhereInput | RequestWhereInput[]
    requestID?: IntFilter<"Request"> | number
    requestStatus?: StringFilter<"Request"> | string
    submissionTime?: DateTimeFilter<"Request"> | Date | string
    vehicleNumber?: StringFilter<"Request"> | string
    carImage?: BytesFilter<"Request"> | Buffer
    highlights?: StringNullableFilter<"Request"> | string | null
    equipment?: StringNullableFilter<"Request"> | string | null
    modifications?: StringNullableFilter<"Request"> | string | null
    knownFlaws?: StringNullableFilter<"Request"> | string | null
    make?: StringFilter<"Request"> | string
    model?: StringFilter<"Request"> | string
    interiorColor?: StringNullableFilter<"Request"> | string | null
    exteriorColor?: StringNullableFilter<"Request"> | string | null
    startingBid?: FloatFilter<"Request"> | number
    reservePrice?: FloatFilter<"Request"> | number
    accountID?: IntFilter<"Request"> | number
    createdAt?: DateTimeFilter<"Request"> | Date | string
    updatedAt?: DateTimeFilter<"Request"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
  }

  export type RequestOrderByWithRelationInput = {
    requestID?: SortOrder
    requestStatus?: SortOrder
    submissionTime?: SortOrder
    vehicleNumber?: SortOrder
    carImage?: SortOrder
    highlights?: SortOrderInput | SortOrder
    equipment?: SortOrderInput | SortOrder
    modifications?: SortOrderInput | SortOrder
    knownFlaws?: SortOrderInput | SortOrder
    make?: SortOrder
    model?: SortOrder
    interiorColor?: SortOrderInput | SortOrder
    exteriorColor?: SortOrderInput | SortOrder
    startingBid?: SortOrder
    reservePrice?: SortOrder
    accountID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
  }

  export type RequestWhereUniqueInput = Prisma.AtLeast<{
    requestID?: number
    AND?: RequestWhereInput | RequestWhereInput[]
    OR?: RequestWhereInput[]
    NOT?: RequestWhereInput | RequestWhereInput[]
    requestStatus?: StringFilter<"Request"> | string
    submissionTime?: DateTimeFilter<"Request"> | Date | string
    vehicleNumber?: StringFilter<"Request"> | string
    carImage?: BytesFilter<"Request"> | Buffer
    highlights?: StringNullableFilter<"Request"> | string | null
    equipment?: StringNullableFilter<"Request"> | string | null
    modifications?: StringNullableFilter<"Request"> | string | null
    knownFlaws?: StringNullableFilter<"Request"> | string | null
    make?: StringFilter<"Request"> | string
    model?: StringFilter<"Request"> | string
    interiorColor?: StringNullableFilter<"Request"> | string | null
    exteriorColor?: StringNullableFilter<"Request"> | string | null
    startingBid?: FloatFilter<"Request"> | number
    reservePrice?: FloatFilter<"Request"> | number
    accountID?: IntFilter<"Request"> | number
    createdAt?: DateTimeFilter<"Request"> | Date | string
    updatedAt?: DateTimeFilter<"Request"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
  }, "requestID">

  export type RequestOrderByWithAggregationInput = {
    requestID?: SortOrder
    requestStatus?: SortOrder
    submissionTime?: SortOrder
    vehicleNumber?: SortOrder
    carImage?: SortOrder
    highlights?: SortOrderInput | SortOrder
    equipment?: SortOrderInput | SortOrder
    modifications?: SortOrderInput | SortOrder
    knownFlaws?: SortOrderInput | SortOrder
    make?: SortOrder
    model?: SortOrder
    interiorColor?: SortOrderInput | SortOrder
    exteriorColor?: SortOrderInput | SortOrder
    startingBid?: SortOrder
    reservePrice?: SortOrder
    accountID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RequestCountOrderByAggregateInput
    _avg?: RequestAvgOrderByAggregateInput
    _max?: RequestMaxOrderByAggregateInput
    _min?: RequestMinOrderByAggregateInput
    _sum?: RequestSumOrderByAggregateInput
  }

  export type RequestScalarWhereWithAggregatesInput = {
    AND?: RequestScalarWhereWithAggregatesInput | RequestScalarWhereWithAggregatesInput[]
    OR?: RequestScalarWhereWithAggregatesInput[]
    NOT?: RequestScalarWhereWithAggregatesInput | RequestScalarWhereWithAggregatesInput[]
    requestID?: IntWithAggregatesFilter<"Request"> | number
    requestStatus?: StringWithAggregatesFilter<"Request"> | string
    submissionTime?: DateTimeWithAggregatesFilter<"Request"> | Date | string
    vehicleNumber?: StringWithAggregatesFilter<"Request"> | string
    carImage?: BytesWithAggregatesFilter<"Request"> | Buffer
    highlights?: StringNullableWithAggregatesFilter<"Request"> | string | null
    equipment?: StringNullableWithAggregatesFilter<"Request"> | string | null
    modifications?: StringNullableWithAggregatesFilter<"Request"> | string | null
    knownFlaws?: StringNullableWithAggregatesFilter<"Request"> | string | null
    make?: StringWithAggregatesFilter<"Request"> | string
    model?: StringWithAggregatesFilter<"Request"> | string
    interiorColor?: StringNullableWithAggregatesFilter<"Request"> | string | null
    exteriorColor?: StringNullableWithAggregatesFilter<"Request"> | string | null
    startingBid?: FloatWithAggregatesFilter<"Request"> | number
    reservePrice?: FloatWithAggregatesFilter<"Request"> | number
    accountID?: IntWithAggregatesFilter<"Request"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Request"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Request"> | Date | string
  }

  export type FAQWhereInput = {
    AND?: FAQWhereInput | FAQWhereInput[]
    OR?: FAQWhereInput[]
    NOT?: FAQWhereInput | FAQWhereInput[]
    questionID?: IntFilter<"FAQ"> | number
    questionType?: StringFilter<"FAQ"> | string
    questionAns?: StringFilter<"FAQ"> | string
    createdAt?: DateTimeFilter<"FAQ"> | Date | string
    updatedAt?: DateTimeFilter<"FAQ"> | Date | string
  }

  export type FAQOrderByWithRelationInput = {
    questionID?: SortOrder
    questionType?: SortOrder
    questionAns?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FAQWhereUniqueInput = Prisma.AtLeast<{
    questionID?: number
    AND?: FAQWhereInput | FAQWhereInput[]
    OR?: FAQWhereInput[]
    NOT?: FAQWhereInput | FAQWhereInput[]
    questionType?: StringFilter<"FAQ"> | string
    questionAns?: StringFilter<"FAQ"> | string
    createdAt?: DateTimeFilter<"FAQ"> | Date | string
    updatedAt?: DateTimeFilter<"FAQ"> | Date | string
  }, "questionID">

  export type FAQOrderByWithAggregationInput = {
    questionID?: SortOrder
    questionType?: SortOrder
    questionAns?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FAQCountOrderByAggregateInput
    _avg?: FAQAvgOrderByAggregateInput
    _max?: FAQMaxOrderByAggregateInput
    _min?: FAQMinOrderByAggregateInput
    _sum?: FAQSumOrderByAggregateInput
  }

  export type FAQScalarWhereWithAggregatesInput = {
    AND?: FAQScalarWhereWithAggregatesInput | FAQScalarWhereWithAggregatesInput[]
    OR?: FAQScalarWhereWithAggregatesInput[]
    NOT?: FAQScalarWhereWithAggregatesInput | FAQScalarWhereWithAggregatesInput[]
    questionID?: IntWithAggregatesFilter<"FAQ"> | number
    questionType?: StringWithAggregatesFilter<"FAQ"> | string
    questionAns?: StringWithAggregatesFilter<"FAQ"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FAQ"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FAQ"> | Date | string
  }

  export type UserCreateInput = {
    firstName: string
    lastName: string
    address?: string | null
    phoneNumber: string
    emailAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    userID?: number
    firstName: string
    lastName: string
    address?: string | null
    phoneNumber: string
    emailAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    emailAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    userID?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    emailAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    userID?: number
    firstName: string
    lastName: string
    address?: string | null
    phoneNumber: string
    emailAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    emailAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    userID?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    emailAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    accountType: string
    accountStatus: string
    username: string
    password: string
    token2fa?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAccountsInput
    cars?: CarCreateNestedManyWithoutAccountInput
    auctions?: AuctionCreateNestedManyWithoutAuctionCreatorInput
    comments?: CommentCreateNestedManyWithoutAccountInput
    orders?: OrdersCreateNestedManyWithoutOrderCreatorInput
    sellingHistory?: SellingHistoryCreateNestedManyWithoutAccountInput
    biddingHistory?: BiddingHistoryCreateNestedManyWithoutAccountInput
    requests?: RequestCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateInput = {
    accountID?: number
    accountType: string
    accountStatus: string
    username: string
    password: string
    userID?: number | null
    token2fa?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cars?: CarUncheckedCreateNestedManyWithoutAccountInput
    auctions?: AuctionUncheckedCreateNestedManyWithoutAuctionCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAccountInput
    orders?: OrdersUncheckedCreateNestedManyWithoutOrderCreatorInput
    sellingHistory?: SellingHistoryUncheckedCreateNestedManyWithoutAccountInput
    biddingHistory?: BiddingHistoryUncheckedCreateNestedManyWithoutAccountInput
    requests?: RequestUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountUpdateInput = {
    accountType?: StringFieldUpdateOperationsInput | string
    accountStatus?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    token2fa?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAccountsNestedInput
    cars?: CarUpdateManyWithoutAccountNestedInput
    auctions?: AuctionUpdateManyWithoutAuctionCreatorNestedInput
    comments?: CommentUpdateManyWithoutAccountNestedInput
    orders?: OrdersUpdateManyWithoutOrderCreatorNestedInput
    sellingHistory?: SellingHistoryUpdateManyWithoutAccountNestedInput
    biddingHistory?: BiddingHistoryUpdateManyWithoutAccountNestedInput
    requests?: RequestUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    accountID?: IntFieldUpdateOperationsInput | number
    accountType?: StringFieldUpdateOperationsInput | string
    accountStatus?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userID?: NullableIntFieldUpdateOperationsInput | number | null
    token2fa?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cars?: CarUncheckedUpdateManyWithoutAccountNestedInput
    auctions?: AuctionUncheckedUpdateManyWithoutAuctionCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAccountNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutOrderCreatorNestedInput
    sellingHistory?: SellingHistoryUncheckedUpdateManyWithoutAccountNestedInput
    biddingHistory?: BiddingHistoryUncheckedUpdateManyWithoutAccountNestedInput
    requests?: RequestUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountCreateManyInput = {
    accountID?: number
    accountType: string
    accountStatus: string
    username: string
    password: string
    userID?: number | null
    token2fa?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    accountType?: StringFieldUpdateOperationsInput | string
    accountStatus?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    token2fa?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    accountID?: IntFieldUpdateOperationsInput | number
    accountType?: StringFieldUpdateOperationsInput | string
    accountStatus?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userID?: NullableIntFieldUpdateOperationsInput | number | null
    token2fa?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CarCreateInput = {
    vehicleNumber: string
    carImage?: Buffer | null
    highlights?: string | null
    equipment?: string | null
    modifications?: string | null
    knownFlaws?: string | null
    make: string
    model: string
    interiorColor?: string | null
    exteriorColor?: string | null
    startingBid: number
    reservePrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutCarsInput
    auctions?: AuctionCreateNestedManyWithoutCarInput
  }

  export type CarUncheckedCreateInput = {
    carID?: number
    vehicleNumber: string
    carImage?: Buffer | null
    highlights?: string | null
    equipment?: string | null
    modifications?: string | null
    knownFlaws?: string | null
    make: string
    model: string
    interiorColor?: string | null
    exteriorColor?: string | null
    startingBid: number
    reservePrice: number
    accountID: number
    createdAt?: Date | string
    updatedAt?: Date | string
    auctions?: AuctionUncheckedCreateNestedManyWithoutCarInput
  }

  export type CarUpdateInput = {
    vehicleNumber?: StringFieldUpdateOperationsInput | string
    carImage?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    highlights?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableStringFieldUpdateOperationsInput | string | null
    knownFlaws?: NullableStringFieldUpdateOperationsInput | string | null
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    interiorColor?: NullableStringFieldUpdateOperationsInput | string | null
    exteriorColor?: NullableStringFieldUpdateOperationsInput | string | null
    startingBid?: FloatFieldUpdateOperationsInput | number
    reservePrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutCarsNestedInput
    auctions?: AuctionUpdateManyWithoutCarNestedInput
  }

  export type CarUncheckedUpdateInput = {
    carID?: IntFieldUpdateOperationsInput | number
    vehicleNumber?: StringFieldUpdateOperationsInput | string
    carImage?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    highlights?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableStringFieldUpdateOperationsInput | string | null
    knownFlaws?: NullableStringFieldUpdateOperationsInput | string | null
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    interiorColor?: NullableStringFieldUpdateOperationsInput | string | null
    exteriorColor?: NullableStringFieldUpdateOperationsInput | string | null
    startingBid?: FloatFieldUpdateOperationsInput | number
    reservePrice?: FloatFieldUpdateOperationsInput | number
    accountID?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auctions?: AuctionUncheckedUpdateManyWithoutCarNestedInput
  }

  export type CarCreateManyInput = {
    carID?: number
    vehicleNumber: string
    carImage?: Buffer | null
    highlights?: string | null
    equipment?: string | null
    modifications?: string | null
    knownFlaws?: string | null
    make: string
    model: string
    interiorColor?: string | null
    exteriorColor?: string | null
    startingBid: number
    reservePrice: number
    accountID: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CarUpdateManyMutationInput = {
    vehicleNumber?: StringFieldUpdateOperationsInput | string
    carImage?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    highlights?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableStringFieldUpdateOperationsInput | string | null
    knownFlaws?: NullableStringFieldUpdateOperationsInput | string | null
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    interiorColor?: NullableStringFieldUpdateOperationsInput | string | null
    exteriorColor?: NullableStringFieldUpdateOperationsInput | string | null
    startingBid?: FloatFieldUpdateOperationsInput | number
    reservePrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CarUncheckedUpdateManyInput = {
    carID?: IntFieldUpdateOperationsInput | number
    vehicleNumber?: StringFieldUpdateOperationsInput | string
    carImage?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    highlights?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableStringFieldUpdateOperationsInput | string | null
    knownFlaws?: NullableStringFieldUpdateOperationsInput | string | null
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    interiorColor?: NullableStringFieldUpdateOperationsInput | string | null
    exteriorColor?: NullableStringFieldUpdateOperationsInput | string | null
    startingBid?: FloatFieldUpdateOperationsInput | number
    reservePrice?: FloatFieldUpdateOperationsInput | number
    accountID?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionCreateInput = {
    auctionStatus: string
    startDate: Date | string
    endDate: Date | string
    currentHighestBid: number
    auctionCreationTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    auctionCreator: AccountCreateNestedOneWithoutAuctionsInput
    car: CarCreateNestedOneWithoutAuctionsInput
    comments?: CommentCreateNestedManyWithoutAuctionInput
    orders?: OrdersCreateNestedManyWithoutAuctionInput
    biddingHistories?: BiddingHistoryCreateNestedManyWithoutAuctionInput
  }

  export type AuctionUncheckedCreateInput = {
    auctionID?: number
    auctionStatus: string
    startDate: Date | string
    endDate: Date | string
    currentHighestBid: number
    auctionCreationTime: Date | string
    auctionCreatorID: number
    carID: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutAuctionInput
    orders?: OrdersUncheckedCreateNestedManyWithoutAuctionInput
    biddingHistories?: BiddingHistoryUncheckedCreateNestedManyWithoutAuctionInput
  }

  export type AuctionUpdateInput = {
    auctionStatus?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHighestBid?: FloatFieldUpdateOperationsInput | number
    auctionCreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auctionCreator?: AccountUpdateOneRequiredWithoutAuctionsNestedInput
    car?: CarUpdateOneRequiredWithoutAuctionsNestedInput
    comments?: CommentUpdateManyWithoutAuctionNestedInput
    orders?: OrdersUpdateManyWithoutAuctionNestedInput
    biddingHistories?: BiddingHistoryUpdateManyWithoutAuctionNestedInput
  }

  export type AuctionUncheckedUpdateInput = {
    auctionID?: IntFieldUpdateOperationsInput | number
    auctionStatus?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHighestBid?: FloatFieldUpdateOperationsInput | number
    auctionCreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    auctionCreatorID?: IntFieldUpdateOperationsInput | number
    carID?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutAuctionNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutAuctionNestedInput
    biddingHistories?: BiddingHistoryUncheckedUpdateManyWithoutAuctionNestedInput
  }

  export type AuctionCreateManyInput = {
    auctionID?: number
    auctionStatus: string
    startDate: Date | string
    endDate: Date | string
    currentHighestBid: number
    auctionCreationTime: Date | string
    auctionCreatorID: number
    carID: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuctionUpdateManyMutationInput = {
    auctionStatus?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHighestBid?: FloatFieldUpdateOperationsInput | number
    auctionCreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionUncheckedUpdateManyInput = {
    auctionID?: IntFieldUpdateOperationsInput | number
    auctionStatus?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHighestBid?: FloatFieldUpdateOperationsInput | number
    auctionCreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    auctionCreatorID?: IntFieldUpdateOperationsInput | number
    carID?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    details: string
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutCommentsInput
    auction: AuctionCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    commentID?: number
    details: string
    accountID: number
    auctionID: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateInput = {
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutCommentsNestedInput
    auction?: AuctionUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    commentID?: IntFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
    accountID?: IntFieldUpdateOperationsInput | number
    auctionID?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyInput = {
    commentID?: number
    details: string
    accountID: number
    auctionID: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    commentID?: IntFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
    accountID?: IntFieldUpdateOperationsInput | number
    auctionID?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrdersCreateInput = {
    orderStatus: string
    paymentDeadline: Date | string
    deliveryType: string
    shippingAddress?: string | null
    orderCreationTime: Date | string
    orderCompletionTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderCreator: AccountCreateNestedOneWithoutOrdersInput
    auction: AuctionCreateNestedOneWithoutOrdersInput
    sellingHistory?: SellingHistoryCreateNestedManyWithoutOrderInput
  }

  export type OrdersUncheckedCreateInput = {
    orderID?: number
    orderStatus: string
    paymentDeadline: Date | string
    deliveryType: string
    shippingAddress?: string | null
    orderCreationTime: Date | string
    orderCompletionTime?: Date | string | null
    orderCreatorID: number
    auctionID: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sellingHistory?: SellingHistoryUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrdersUpdateInput = {
    orderStatus?: StringFieldUpdateOperationsInput | string
    paymentDeadline?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryType?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    orderCreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    orderCompletionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderCreator?: AccountUpdateOneRequiredWithoutOrdersNestedInput
    auction?: AuctionUpdateOneRequiredWithoutOrdersNestedInput
    sellingHistory?: SellingHistoryUpdateManyWithoutOrderNestedInput
  }

  export type OrdersUncheckedUpdateInput = {
    orderID?: IntFieldUpdateOperationsInput | number
    orderStatus?: StringFieldUpdateOperationsInput | string
    paymentDeadline?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryType?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    orderCreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    orderCompletionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderCreatorID?: IntFieldUpdateOperationsInput | number
    auctionID?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sellingHistory?: SellingHistoryUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrdersCreateManyInput = {
    orderID?: number
    orderStatus: string
    paymentDeadline: Date | string
    deliveryType: string
    shippingAddress?: string | null
    orderCreationTime: Date | string
    orderCompletionTime?: Date | string | null
    orderCreatorID: number
    auctionID: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrdersUpdateManyMutationInput = {
    orderStatus?: StringFieldUpdateOperationsInput | string
    paymentDeadline?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryType?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    orderCreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    orderCompletionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrdersUncheckedUpdateManyInput = {
    orderID?: IntFieldUpdateOperationsInput | number
    orderStatus?: StringFieldUpdateOperationsInput | string
    paymentDeadline?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryType?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    orderCreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    orderCompletionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderCreatorID?: IntFieldUpdateOperationsInput | number
    auctionID?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellingHistoryCreateInput = {
    order: OrdersCreateNestedOneWithoutSellingHistoryInput
    account: AccountCreateNestedOneWithoutSellingHistoryInput
  }

  export type SellingHistoryUncheckedCreateInput = {
    saleID?: number
    orderID: number
    accountID: number
  }

  export type SellingHistoryUpdateInput = {
    order?: OrdersUpdateOneRequiredWithoutSellingHistoryNestedInput
    account?: AccountUpdateOneRequiredWithoutSellingHistoryNestedInput
  }

  export type SellingHistoryUncheckedUpdateInput = {
    saleID?: IntFieldUpdateOperationsInput | number
    orderID?: IntFieldUpdateOperationsInput | number
    accountID?: IntFieldUpdateOperationsInput | number
  }

  export type SellingHistoryCreateManyInput = {
    saleID?: number
    orderID: number
    accountID: number
  }

  export type SellingHistoryUpdateManyMutationInput = {

  }

  export type SellingHistoryUncheckedUpdateManyInput = {
    saleID?: IntFieldUpdateOperationsInput | number
    orderID?: IntFieldUpdateOperationsInput | number
    accountID?: IntFieldUpdateOperationsInput | number
  }

  export type BiddingHistoryCreateInput = {
    bidAmount: number
    bidTimestamp: Date | string
    bidStatus: string
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutBiddingHistoryInput
    auction: AuctionCreateNestedOneWithoutBiddingHistoriesInput
  }

  export type BiddingHistoryUncheckedCreateInput = {
    bidID?: number
    bidAmount: number
    bidTimestamp: Date | string
    bidStatus: string
    accountID: number
    auctionID: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BiddingHistoryUpdateInput = {
    bidAmount?: FloatFieldUpdateOperationsInput | number
    bidTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    bidStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutBiddingHistoryNestedInput
    auction?: AuctionUpdateOneRequiredWithoutBiddingHistoriesNestedInput
  }

  export type BiddingHistoryUncheckedUpdateInput = {
    bidID?: IntFieldUpdateOperationsInput | number
    bidAmount?: FloatFieldUpdateOperationsInput | number
    bidTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    bidStatus?: StringFieldUpdateOperationsInput | string
    accountID?: IntFieldUpdateOperationsInput | number
    auctionID?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiddingHistoryCreateManyInput = {
    bidID?: number
    bidAmount: number
    bidTimestamp: Date | string
    bidStatus: string
    accountID: number
    auctionID: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BiddingHistoryUpdateManyMutationInput = {
    bidAmount?: FloatFieldUpdateOperationsInput | number
    bidTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    bidStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiddingHistoryUncheckedUpdateManyInput = {
    bidID?: IntFieldUpdateOperationsInput | number
    bidAmount?: FloatFieldUpdateOperationsInput | number
    bidTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    bidStatus?: StringFieldUpdateOperationsInput | string
    accountID?: IntFieldUpdateOperationsInput | number
    auctionID?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestCreateInput = {
    requestStatus: string
    submissionTime: Date | string
    vehicleNumber: string
    carImage: Buffer
    highlights?: string | null
    equipment?: string | null
    modifications?: string | null
    knownFlaws?: string | null
    make: string
    model: string
    interiorColor?: string | null
    exteriorColor?: string | null
    startingBid: number
    reservePrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutRequestsInput
  }

  export type RequestUncheckedCreateInput = {
    requestID?: number
    requestStatus: string
    submissionTime: Date | string
    vehicleNumber: string
    carImage: Buffer
    highlights?: string | null
    equipment?: string | null
    modifications?: string | null
    knownFlaws?: string | null
    make: string
    model: string
    interiorColor?: string | null
    exteriorColor?: string | null
    startingBid: number
    reservePrice: number
    accountID: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestUpdateInput = {
    requestStatus?: StringFieldUpdateOperationsInput | string
    submissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleNumber?: StringFieldUpdateOperationsInput | string
    carImage?: BytesFieldUpdateOperationsInput | Buffer
    highlights?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableStringFieldUpdateOperationsInput | string | null
    knownFlaws?: NullableStringFieldUpdateOperationsInput | string | null
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    interiorColor?: NullableStringFieldUpdateOperationsInput | string | null
    exteriorColor?: NullableStringFieldUpdateOperationsInput | string | null
    startingBid?: FloatFieldUpdateOperationsInput | number
    reservePrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutRequestsNestedInput
  }

  export type RequestUncheckedUpdateInput = {
    requestID?: IntFieldUpdateOperationsInput | number
    requestStatus?: StringFieldUpdateOperationsInput | string
    submissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleNumber?: StringFieldUpdateOperationsInput | string
    carImage?: BytesFieldUpdateOperationsInput | Buffer
    highlights?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableStringFieldUpdateOperationsInput | string | null
    knownFlaws?: NullableStringFieldUpdateOperationsInput | string | null
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    interiorColor?: NullableStringFieldUpdateOperationsInput | string | null
    exteriorColor?: NullableStringFieldUpdateOperationsInput | string | null
    startingBid?: FloatFieldUpdateOperationsInput | number
    reservePrice?: FloatFieldUpdateOperationsInput | number
    accountID?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestCreateManyInput = {
    requestID?: number
    requestStatus: string
    submissionTime: Date | string
    vehicleNumber: string
    carImage: Buffer
    highlights?: string | null
    equipment?: string | null
    modifications?: string | null
    knownFlaws?: string | null
    make: string
    model: string
    interiorColor?: string | null
    exteriorColor?: string | null
    startingBid: number
    reservePrice: number
    accountID: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestUpdateManyMutationInput = {
    requestStatus?: StringFieldUpdateOperationsInput | string
    submissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleNumber?: StringFieldUpdateOperationsInput | string
    carImage?: BytesFieldUpdateOperationsInput | Buffer
    highlights?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableStringFieldUpdateOperationsInput | string | null
    knownFlaws?: NullableStringFieldUpdateOperationsInput | string | null
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    interiorColor?: NullableStringFieldUpdateOperationsInput | string | null
    exteriorColor?: NullableStringFieldUpdateOperationsInput | string | null
    startingBid?: FloatFieldUpdateOperationsInput | number
    reservePrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestUncheckedUpdateManyInput = {
    requestID?: IntFieldUpdateOperationsInput | number
    requestStatus?: StringFieldUpdateOperationsInput | string
    submissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleNumber?: StringFieldUpdateOperationsInput | string
    carImage?: BytesFieldUpdateOperationsInput | Buffer
    highlights?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableStringFieldUpdateOperationsInput | string | null
    knownFlaws?: NullableStringFieldUpdateOperationsInput | string | null
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    interiorColor?: NullableStringFieldUpdateOperationsInput | string | null
    exteriorColor?: NullableStringFieldUpdateOperationsInput | string | null
    startingBid?: FloatFieldUpdateOperationsInput | number
    reservePrice?: FloatFieldUpdateOperationsInput | number
    accountID?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FAQCreateInput = {
    questionType: string
    questionAns: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FAQUncheckedCreateInput = {
    questionID?: number
    questionType: string
    questionAns: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FAQUpdateInput = {
    questionType?: StringFieldUpdateOperationsInput | string
    questionAns?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FAQUncheckedUpdateInput = {
    questionID?: IntFieldUpdateOperationsInput | number
    questionType?: StringFieldUpdateOperationsInput | string
    questionAns?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FAQCreateManyInput = {
    questionID?: number
    questionType: string
    questionAns: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FAQUpdateManyMutationInput = {
    questionType?: StringFieldUpdateOperationsInput | string
    questionAns?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FAQUncheckedUpdateManyInput = {
    questionID?: IntFieldUpdateOperationsInput | number
    questionType?: StringFieldUpdateOperationsInput | string
    questionAns?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    userID?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    address?: SortOrder
    phoneNumber?: SortOrder
    emailAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    userID?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    userID?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    address?: SortOrder
    phoneNumber?: SortOrder
    emailAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    userID?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    address?: SortOrder
    phoneNumber?: SortOrder
    emailAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    userID?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CarListRelationFilter = {
    every?: CarWhereInput
    some?: CarWhereInput
    none?: CarWhereInput
  }

  export type AuctionListRelationFilter = {
    every?: AuctionWhereInput
    some?: AuctionWhereInput
    none?: AuctionWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type OrdersListRelationFilter = {
    every?: OrdersWhereInput
    some?: OrdersWhereInput
    none?: OrdersWhereInput
  }

  export type SellingHistoryListRelationFilter = {
    every?: SellingHistoryWhereInput
    some?: SellingHistoryWhereInput
    none?: SellingHistoryWhereInput
  }

  export type BiddingHistoryListRelationFilter = {
    every?: BiddingHistoryWhereInput
    some?: BiddingHistoryWhereInput
    none?: BiddingHistoryWhereInput
  }

  export type RequestListRelationFilter = {
    every?: RequestWhereInput
    some?: RequestWhereInput
    none?: RequestWhereInput
  }

  export type CarOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuctionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrdersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SellingHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BiddingHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountCountOrderByAggregateInput = {
    accountID?: SortOrder
    accountType?: SortOrder
    accountStatus?: SortOrder
    username?: SortOrder
    password?: SortOrder
    userID?: SortOrder
    token2fa?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    accountID?: SortOrder
    userID?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    accountID?: SortOrder
    accountType?: SortOrder
    accountStatus?: SortOrder
    username?: SortOrder
    password?: SortOrder
    userID?: SortOrder
    token2fa?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    accountID?: SortOrder
    accountType?: SortOrder
    accountStatus?: SortOrder
    username?: SortOrder
    password?: SortOrder
    userID?: SortOrder
    token2fa?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    accountID?: SortOrder
    userID?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | null
    notIn?: Buffer[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Buffer | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type AccountRelationFilter = {
    is?: AccountWhereInput
    isNot?: AccountWhereInput
  }

  export type CarCountOrderByAggregateInput = {
    carID?: SortOrder
    vehicleNumber?: SortOrder
    carImage?: SortOrder
    highlights?: SortOrder
    equipment?: SortOrder
    modifications?: SortOrder
    knownFlaws?: SortOrder
    make?: SortOrder
    model?: SortOrder
    interiorColor?: SortOrder
    exteriorColor?: SortOrder
    startingBid?: SortOrder
    reservePrice?: SortOrder
    accountID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CarAvgOrderByAggregateInput = {
    carID?: SortOrder
    startingBid?: SortOrder
    reservePrice?: SortOrder
    accountID?: SortOrder
  }

  export type CarMaxOrderByAggregateInput = {
    carID?: SortOrder
    vehicleNumber?: SortOrder
    carImage?: SortOrder
    highlights?: SortOrder
    equipment?: SortOrder
    modifications?: SortOrder
    knownFlaws?: SortOrder
    make?: SortOrder
    model?: SortOrder
    interiorColor?: SortOrder
    exteriorColor?: SortOrder
    startingBid?: SortOrder
    reservePrice?: SortOrder
    accountID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CarMinOrderByAggregateInput = {
    carID?: SortOrder
    vehicleNumber?: SortOrder
    carImage?: SortOrder
    highlights?: SortOrder
    equipment?: SortOrder
    modifications?: SortOrder
    knownFlaws?: SortOrder
    make?: SortOrder
    model?: SortOrder
    interiorColor?: SortOrder
    exteriorColor?: SortOrder
    startingBid?: SortOrder
    reservePrice?: SortOrder
    accountID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CarSumOrderByAggregateInput = {
    carID?: SortOrder
    startingBid?: SortOrder
    reservePrice?: SortOrder
    accountID?: SortOrder
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | null
    notIn?: Buffer[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Buffer | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type CarRelationFilter = {
    is?: CarWhereInput
    isNot?: CarWhereInput
  }

  export type AuctionCountOrderByAggregateInput = {
    auctionID?: SortOrder
    auctionStatus?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    currentHighestBid?: SortOrder
    auctionCreationTime?: SortOrder
    auctionCreatorID?: SortOrder
    carID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuctionAvgOrderByAggregateInput = {
    auctionID?: SortOrder
    currentHighestBid?: SortOrder
    auctionCreatorID?: SortOrder
    carID?: SortOrder
  }

  export type AuctionMaxOrderByAggregateInput = {
    auctionID?: SortOrder
    auctionStatus?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    currentHighestBid?: SortOrder
    auctionCreationTime?: SortOrder
    auctionCreatorID?: SortOrder
    carID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuctionMinOrderByAggregateInput = {
    auctionID?: SortOrder
    auctionStatus?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    currentHighestBid?: SortOrder
    auctionCreationTime?: SortOrder
    auctionCreatorID?: SortOrder
    carID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuctionSumOrderByAggregateInput = {
    auctionID?: SortOrder
    currentHighestBid?: SortOrder
    auctionCreatorID?: SortOrder
    carID?: SortOrder
  }

  export type AuctionRelationFilter = {
    is?: AuctionWhereInput
    isNot?: AuctionWhereInput
  }

  export type CommentCountOrderByAggregateInput = {
    commentID?: SortOrder
    details?: SortOrder
    accountID?: SortOrder
    auctionID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    commentID?: SortOrder
    accountID?: SortOrder
    auctionID?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    commentID?: SortOrder
    details?: SortOrder
    accountID?: SortOrder
    auctionID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    commentID?: SortOrder
    details?: SortOrder
    accountID?: SortOrder
    auctionID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    commentID?: SortOrder
    accountID?: SortOrder
    auctionID?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type OrdersCountOrderByAggregateInput = {
    orderID?: SortOrder
    orderStatus?: SortOrder
    paymentDeadline?: SortOrder
    deliveryType?: SortOrder
    shippingAddress?: SortOrder
    orderCreationTime?: SortOrder
    orderCompletionTime?: SortOrder
    orderCreatorID?: SortOrder
    auctionID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrdersAvgOrderByAggregateInput = {
    orderID?: SortOrder
    orderCreatorID?: SortOrder
    auctionID?: SortOrder
  }

  export type OrdersMaxOrderByAggregateInput = {
    orderID?: SortOrder
    orderStatus?: SortOrder
    paymentDeadline?: SortOrder
    deliveryType?: SortOrder
    shippingAddress?: SortOrder
    orderCreationTime?: SortOrder
    orderCompletionTime?: SortOrder
    orderCreatorID?: SortOrder
    auctionID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrdersMinOrderByAggregateInput = {
    orderID?: SortOrder
    orderStatus?: SortOrder
    paymentDeadline?: SortOrder
    deliveryType?: SortOrder
    shippingAddress?: SortOrder
    orderCreationTime?: SortOrder
    orderCompletionTime?: SortOrder
    orderCreatorID?: SortOrder
    auctionID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrdersSumOrderByAggregateInput = {
    orderID?: SortOrder
    orderCreatorID?: SortOrder
    auctionID?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type OrdersRelationFilter = {
    is?: OrdersWhereInput
    isNot?: OrdersWhereInput
  }

  export type SellingHistoryCountOrderByAggregateInput = {
    saleID?: SortOrder
    orderID?: SortOrder
    accountID?: SortOrder
  }

  export type SellingHistoryAvgOrderByAggregateInput = {
    saleID?: SortOrder
    orderID?: SortOrder
    accountID?: SortOrder
  }

  export type SellingHistoryMaxOrderByAggregateInput = {
    saleID?: SortOrder
    orderID?: SortOrder
    accountID?: SortOrder
  }

  export type SellingHistoryMinOrderByAggregateInput = {
    saleID?: SortOrder
    orderID?: SortOrder
    accountID?: SortOrder
  }

  export type SellingHistorySumOrderByAggregateInput = {
    saleID?: SortOrder
    orderID?: SortOrder
    accountID?: SortOrder
  }

  export type BiddingHistoryCountOrderByAggregateInput = {
    bidID?: SortOrder
    bidAmount?: SortOrder
    bidTimestamp?: SortOrder
    bidStatus?: SortOrder
    accountID?: SortOrder
    auctionID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BiddingHistoryAvgOrderByAggregateInput = {
    bidID?: SortOrder
    bidAmount?: SortOrder
    accountID?: SortOrder
    auctionID?: SortOrder
  }

  export type BiddingHistoryMaxOrderByAggregateInput = {
    bidID?: SortOrder
    bidAmount?: SortOrder
    bidTimestamp?: SortOrder
    bidStatus?: SortOrder
    accountID?: SortOrder
    auctionID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BiddingHistoryMinOrderByAggregateInput = {
    bidID?: SortOrder
    bidAmount?: SortOrder
    bidTimestamp?: SortOrder
    bidStatus?: SortOrder
    accountID?: SortOrder
    auctionID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BiddingHistorySumOrderByAggregateInput = {
    bidID?: SortOrder
    bidAmount?: SortOrder
    accountID?: SortOrder
    auctionID?: SortOrder
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[]
    notIn?: Buffer[]
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type RequestCountOrderByAggregateInput = {
    requestID?: SortOrder
    requestStatus?: SortOrder
    submissionTime?: SortOrder
    vehicleNumber?: SortOrder
    carImage?: SortOrder
    highlights?: SortOrder
    equipment?: SortOrder
    modifications?: SortOrder
    knownFlaws?: SortOrder
    make?: SortOrder
    model?: SortOrder
    interiorColor?: SortOrder
    exteriorColor?: SortOrder
    startingBid?: SortOrder
    reservePrice?: SortOrder
    accountID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RequestAvgOrderByAggregateInput = {
    requestID?: SortOrder
    startingBid?: SortOrder
    reservePrice?: SortOrder
    accountID?: SortOrder
  }

  export type RequestMaxOrderByAggregateInput = {
    requestID?: SortOrder
    requestStatus?: SortOrder
    submissionTime?: SortOrder
    vehicleNumber?: SortOrder
    carImage?: SortOrder
    highlights?: SortOrder
    equipment?: SortOrder
    modifications?: SortOrder
    knownFlaws?: SortOrder
    make?: SortOrder
    model?: SortOrder
    interiorColor?: SortOrder
    exteriorColor?: SortOrder
    startingBid?: SortOrder
    reservePrice?: SortOrder
    accountID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RequestMinOrderByAggregateInput = {
    requestID?: SortOrder
    requestStatus?: SortOrder
    submissionTime?: SortOrder
    vehicleNumber?: SortOrder
    carImage?: SortOrder
    highlights?: SortOrder
    equipment?: SortOrder
    modifications?: SortOrder
    knownFlaws?: SortOrder
    make?: SortOrder
    model?: SortOrder
    interiorColor?: SortOrder
    exteriorColor?: SortOrder
    startingBid?: SortOrder
    reservePrice?: SortOrder
    accountID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RequestSumOrderByAggregateInput = {
    requestID?: SortOrder
    startingBid?: SortOrder
    reservePrice?: SortOrder
    accountID?: SortOrder
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[]
    notIn?: Buffer[]
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type FAQCountOrderByAggregateInput = {
    questionID?: SortOrder
    questionType?: SortOrder
    questionAns?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FAQAvgOrderByAggregateInput = {
    questionID?: SortOrder
  }

  export type FAQMaxOrderByAggregateInput = {
    questionID?: SortOrder
    questionType?: SortOrder
    questionAns?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FAQMinOrderByAggregateInput = {
    questionID?: SortOrder
    questionType?: SortOrder
    questionAns?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FAQSumOrderByAggregateInput = {
    questionID?: SortOrder
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type CarCreateNestedManyWithoutAccountInput = {
    create?: XOR<CarCreateWithoutAccountInput, CarUncheckedCreateWithoutAccountInput> | CarCreateWithoutAccountInput[] | CarUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CarCreateOrConnectWithoutAccountInput | CarCreateOrConnectWithoutAccountInput[]
    createMany?: CarCreateManyAccountInputEnvelope
    connect?: CarWhereUniqueInput | CarWhereUniqueInput[]
  }

  export type AuctionCreateNestedManyWithoutAuctionCreatorInput = {
    create?: XOR<AuctionCreateWithoutAuctionCreatorInput, AuctionUncheckedCreateWithoutAuctionCreatorInput> | AuctionCreateWithoutAuctionCreatorInput[] | AuctionUncheckedCreateWithoutAuctionCreatorInput[]
    connectOrCreate?: AuctionCreateOrConnectWithoutAuctionCreatorInput | AuctionCreateOrConnectWithoutAuctionCreatorInput[]
    createMany?: AuctionCreateManyAuctionCreatorInputEnvelope
    connect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutAccountInput = {
    create?: XOR<CommentCreateWithoutAccountInput, CommentUncheckedCreateWithoutAccountInput> | CommentCreateWithoutAccountInput[] | CommentUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAccountInput | CommentCreateOrConnectWithoutAccountInput[]
    createMany?: CommentCreateManyAccountInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type OrdersCreateNestedManyWithoutOrderCreatorInput = {
    create?: XOR<OrdersCreateWithoutOrderCreatorInput, OrdersUncheckedCreateWithoutOrderCreatorInput> | OrdersCreateWithoutOrderCreatorInput[] | OrdersUncheckedCreateWithoutOrderCreatorInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutOrderCreatorInput | OrdersCreateOrConnectWithoutOrderCreatorInput[]
    createMany?: OrdersCreateManyOrderCreatorInputEnvelope
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
  }

  export type SellingHistoryCreateNestedManyWithoutAccountInput = {
    create?: XOR<SellingHistoryCreateWithoutAccountInput, SellingHistoryUncheckedCreateWithoutAccountInput> | SellingHistoryCreateWithoutAccountInput[] | SellingHistoryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: SellingHistoryCreateOrConnectWithoutAccountInput | SellingHistoryCreateOrConnectWithoutAccountInput[]
    createMany?: SellingHistoryCreateManyAccountInputEnvelope
    connect?: SellingHistoryWhereUniqueInput | SellingHistoryWhereUniqueInput[]
  }

  export type BiddingHistoryCreateNestedManyWithoutAccountInput = {
    create?: XOR<BiddingHistoryCreateWithoutAccountInput, BiddingHistoryUncheckedCreateWithoutAccountInput> | BiddingHistoryCreateWithoutAccountInput[] | BiddingHistoryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BiddingHistoryCreateOrConnectWithoutAccountInput | BiddingHistoryCreateOrConnectWithoutAccountInput[]
    createMany?: BiddingHistoryCreateManyAccountInputEnvelope
    connect?: BiddingHistoryWhereUniqueInput | BiddingHistoryWhereUniqueInput[]
  }

  export type RequestCreateNestedManyWithoutAccountInput = {
    create?: XOR<RequestCreateWithoutAccountInput, RequestUncheckedCreateWithoutAccountInput> | RequestCreateWithoutAccountInput[] | RequestUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: RequestCreateOrConnectWithoutAccountInput | RequestCreateOrConnectWithoutAccountInput[]
    createMany?: RequestCreateManyAccountInputEnvelope
    connect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
  }

  export type CarUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<CarCreateWithoutAccountInput, CarUncheckedCreateWithoutAccountInput> | CarCreateWithoutAccountInput[] | CarUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CarCreateOrConnectWithoutAccountInput | CarCreateOrConnectWithoutAccountInput[]
    createMany?: CarCreateManyAccountInputEnvelope
    connect?: CarWhereUniqueInput | CarWhereUniqueInput[]
  }

  export type AuctionUncheckedCreateNestedManyWithoutAuctionCreatorInput = {
    create?: XOR<AuctionCreateWithoutAuctionCreatorInput, AuctionUncheckedCreateWithoutAuctionCreatorInput> | AuctionCreateWithoutAuctionCreatorInput[] | AuctionUncheckedCreateWithoutAuctionCreatorInput[]
    connectOrCreate?: AuctionCreateOrConnectWithoutAuctionCreatorInput | AuctionCreateOrConnectWithoutAuctionCreatorInput[]
    createMany?: AuctionCreateManyAuctionCreatorInputEnvelope
    connect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<CommentCreateWithoutAccountInput, CommentUncheckedCreateWithoutAccountInput> | CommentCreateWithoutAccountInput[] | CommentUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAccountInput | CommentCreateOrConnectWithoutAccountInput[]
    createMany?: CommentCreateManyAccountInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type OrdersUncheckedCreateNestedManyWithoutOrderCreatorInput = {
    create?: XOR<OrdersCreateWithoutOrderCreatorInput, OrdersUncheckedCreateWithoutOrderCreatorInput> | OrdersCreateWithoutOrderCreatorInput[] | OrdersUncheckedCreateWithoutOrderCreatorInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutOrderCreatorInput | OrdersCreateOrConnectWithoutOrderCreatorInput[]
    createMany?: OrdersCreateManyOrderCreatorInputEnvelope
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
  }

  export type SellingHistoryUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<SellingHistoryCreateWithoutAccountInput, SellingHistoryUncheckedCreateWithoutAccountInput> | SellingHistoryCreateWithoutAccountInput[] | SellingHistoryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: SellingHistoryCreateOrConnectWithoutAccountInput | SellingHistoryCreateOrConnectWithoutAccountInput[]
    createMany?: SellingHistoryCreateManyAccountInputEnvelope
    connect?: SellingHistoryWhereUniqueInput | SellingHistoryWhereUniqueInput[]
  }

  export type BiddingHistoryUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<BiddingHistoryCreateWithoutAccountInput, BiddingHistoryUncheckedCreateWithoutAccountInput> | BiddingHistoryCreateWithoutAccountInput[] | BiddingHistoryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BiddingHistoryCreateOrConnectWithoutAccountInput | BiddingHistoryCreateOrConnectWithoutAccountInput[]
    createMany?: BiddingHistoryCreateManyAccountInputEnvelope
    connect?: BiddingHistoryWhereUniqueInput | BiddingHistoryWhereUniqueInput[]
  }

  export type RequestUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<RequestCreateWithoutAccountInput, RequestUncheckedCreateWithoutAccountInput> | RequestCreateWithoutAccountInput[] | RequestUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: RequestCreateOrConnectWithoutAccountInput | RequestCreateOrConnectWithoutAccountInput[]
    createMany?: RequestCreateManyAccountInputEnvelope
    connect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type CarUpdateManyWithoutAccountNestedInput = {
    create?: XOR<CarCreateWithoutAccountInput, CarUncheckedCreateWithoutAccountInput> | CarCreateWithoutAccountInput[] | CarUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CarCreateOrConnectWithoutAccountInput | CarCreateOrConnectWithoutAccountInput[]
    upsert?: CarUpsertWithWhereUniqueWithoutAccountInput | CarUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: CarCreateManyAccountInputEnvelope
    set?: CarWhereUniqueInput | CarWhereUniqueInput[]
    disconnect?: CarWhereUniqueInput | CarWhereUniqueInput[]
    delete?: CarWhereUniqueInput | CarWhereUniqueInput[]
    connect?: CarWhereUniqueInput | CarWhereUniqueInput[]
    update?: CarUpdateWithWhereUniqueWithoutAccountInput | CarUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: CarUpdateManyWithWhereWithoutAccountInput | CarUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: CarScalarWhereInput | CarScalarWhereInput[]
  }

  export type AuctionUpdateManyWithoutAuctionCreatorNestedInput = {
    create?: XOR<AuctionCreateWithoutAuctionCreatorInput, AuctionUncheckedCreateWithoutAuctionCreatorInput> | AuctionCreateWithoutAuctionCreatorInput[] | AuctionUncheckedCreateWithoutAuctionCreatorInput[]
    connectOrCreate?: AuctionCreateOrConnectWithoutAuctionCreatorInput | AuctionCreateOrConnectWithoutAuctionCreatorInput[]
    upsert?: AuctionUpsertWithWhereUniqueWithoutAuctionCreatorInput | AuctionUpsertWithWhereUniqueWithoutAuctionCreatorInput[]
    createMany?: AuctionCreateManyAuctionCreatorInputEnvelope
    set?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    disconnect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    delete?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    connect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    update?: AuctionUpdateWithWhereUniqueWithoutAuctionCreatorInput | AuctionUpdateWithWhereUniqueWithoutAuctionCreatorInput[]
    updateMany?: AuctionUpdateManyWithWhereWithoutAuctionCreatorInput | AuctionUpdateManyWithWhereWithoutAuctionCreatorInput[]
    deleteMany?: AuctionScalarWhereInput | AuctionScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutAccountNestedInput = {
    create?: XOR<CommentCreateWithoutAccountInput, CommentUncheckedCreateWithoutAccountInput> | CommentCreateWithoutAccountInput[] | CommentUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAccountInput | CommentCreateOrConnectWithoutAccountInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAccountInput | CommentUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: CommentCreateManyAccountInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAccountInput | CommentUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAccountInput | CommentUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type OrdersUpdateManyWithoutOrderCreatorNestedInput = {
    create?: XOR<OrdersCreateWithoutOrderCreatorInput, OrdersUncheckedCreateWithoutOrderCreatorInput> | OrdersCreateWithoutOrderCreatorInput[] | OrdersUncheckedCreateWithoutOrderCreatorInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutOrderCreatorInput | OrdersCreateOrConnectWithoutOrderCreatorInput[]
    upsert?: OrdersUpsertWithWhereUniqueWithoutOrderCreatorInput | OrdersUpsertWithWhereUniqueWithoutOrderCreatorInput[]
    createMany?: OrdersCreateManyOrderCreatorInputEnvelope
    set?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    disconnect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    delete?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    update?: OrdersUpdateWithWhereUniqueWithoutOrderCreatorInput | OrdersUpdateWithWhereUniqueWithoutOrderCreatorInput[]
    updateMany?: OrdersUpdateManyWithWhereWithoutOrderCreatorInput | OrdersUpdateManyWithWhereWithoutOrderCreatorInput[]
    deleteMany?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
  }

  export type SellingHistoryUpdateManyWithoutAccountNestedInput = {
    create?: XOR<SellingHistoryCreateWithoutAccountInput, SellingHistoryUncheckedCreateWithoutAccountInput> | SellingHistoryCreateWithoutAccountInput[] | SellingHistoryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: SellingHistoryCreateOrConnectWithoutAccountInput | SellingHistoryCreateOrConnectWithoutAccountInput[]
    upsert?: SellingHistoryUpsertWithWhereUniqueWithoutAccountInput | SellingHistoryUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: SellingHistoryCreateManyAccountInputEnvelope
    set?: SellingHistoryWhereUniqueInput | SellingHistoryWhereUniqueInput[]
    disconnect?: SellingHistoryWhereUniqueInput | SellingHistoryWhereUniqueInput[]
    delete?: SellingHistoryWhereUniqueInput | SellingHistoryWhereUniqueInput[]
    connect?: SellingHistoryWhereUniqueInput | SellingHistoryWhereUniqueInput[]
    update?: SellingHistoryUpdateWithWhereUniqueWithoutAccountInput | SellingHistoryUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: SellingHistoryUpdateManyWithWhereWithoutAccountInput | SellingHistoryUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: SellingHistoryScalarWhereInput | SellingHistoryScalarWhereInput[]
  }

  export type BiddingHistoryUpdateManyWithoutAccountNestedInput = {
    create?: XOR<BiddingHistoryCreateWithoutAccountInput, BiddingHistoryUncheckedCreateWithoutAccountInput> | BiddingHistoryCreateWithoutAccountInput[] | BiddingHistoryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BiddingHistoryCreateOrConnectWithoutAccountInput | BiddingHistoryCreateOrConnectWithoutAccountInput[]
    upsert?: BiddingHistoryUpsertWithWhereUniqueWithoutAccountInput | BiddingHistoryUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: BiddingHistoryCreateManyAccountInputEnvelope
    set?: BiddingHistoryWhereUniqueInput | BiddingHistoryWhereUniqueInput[]
    disconnect?: BiddingHistoryWhereUniqueInput | BiddingHistoryWhereUniqueInput[]
    delete?: BiddingHistoryWhereUniqueInput | BiddingHistoryWhereUniqueInput[]
    connect?: BiddingHistoryWhereUniqueInput | BiddingHistoryWhereUniqueInput[]
    update?: BiddingHistoryUpdateWithWhereUniqueWithoutAccountInput | BiddingHistoryUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: BiddingHistoryUpdateManyWithWhereWithoutAccountInput | BiddingHistoryUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: BiddingHistoryScalarWhereInput | BiddingHistoryScalarWhereInput[]
  }

  export type RequestUpdateManyWithoutAccountNestedInput = {
    create?: XOR<RequestCreateWithoutAccountInput, RequestUncheckedCreateWithoutAccountInput> | RequestCreateWithoutAccountInput[] | RequestUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: RequestCreateOrConnectWithoutAccountInput | RequestCreateOrConnectWithoutAccountInput[]
    upsert?: RequestUpsertWithWhereUniqueWithoutAccountInput | RequestUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: RequestCreateManyAccountInputEnvelope
    set?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    disconnect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    delete?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    connect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    update?: RequestUpdateWithWhereUniqueWithoutAccountInput | RequestUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: RequestUpdateManyWithWhereWithoutAccountInput | RequestUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: RequestScalarWhereInput | RequestScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CarUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<CarCreateWithoutAccountInput, CarUncheckedCreateWithoutAccountInput> | CarCreateWithoutAccountInput[] | CarUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CarCreateOrConnectWithoutAccountInput | CarCreateOrConnectWithoutAccountInput[]
    upsert?: CarUpsertWithWhereUniqueWithoutAccountInput | CarUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: CarCreateManyAccountInputEnvelope
    set?: CarWhereUniqueInput | CarWhereUniqueInput[]
    disconnect?: CarWhereUniqueInput | CarWhereUniqueInput[]
    delete?: CarWhereUniqueInput | CarWhereUniqueInput[]
    connect?: CarWhereUniqueInput | CarWhereUniqueInput[]
    update?: CarUpdateWithWhereUniqueWithoutAccountInput | CarUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: CarUpdateManyWithWhereWithoutAccountInput | CarUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: CarScalarWhereInput | CarScalarWhereInput[]
  }

  export type AuctionUncheckedUpdateManyWithoutAuctionCreatorNestedInput = {
    create?: XOR<AuctionCreateWithoutAuctionCreatorInput, AuctionUncheckedCreateWithoutAuctionCreatorInput> | AuctionCreateWithoutAuctionCreatorInput[] | AuctionUncheckedCreateWithoutAuctionCreatorInput[]
    connectOrCreate?: AuctionCreateOrConnectWithoutAuctionCreatorInput | AuctionCreateOrConnectWithoutAuctionCreatorInput[]
    upsert?: AuctionUpsertWithWhereUniqueWithoutAuctionCreatorInput | AuctionUpsertWithWhereUniqueWithoutAuctionCreatorInput[]
    createMany?: AuctionCreateManyAuctionCreatorInputEnvelope
    set?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    disconnect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    delete?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    connect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    update?: AuctionUpdateWithWhereUniqueWithoutAuctionCreatorInput | AuctionUpdateWithWhereUniqueWithoutAuctionCreatorInput[]
    updateMany?: AuctionUpdateManyWithWhereWithoutAuctionCreatorInput | AuctionUpdateManyWithWhereWithoutAuctionCreatorInput[]
    deleteMany?: AuctionScalarWhereInput | AuctionScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<CommentCreateWithoutAccountInput, CommentUncheckedCreateWithoutAccountInput> | CommentCreateWithoutAccountInput[] | CommentUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAccountInput | CommentCreateOrConnectWithoutAccountInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAccountInput | CommentUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: CommentCreateManyAccountInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAccountInput | CommentUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAccountInput | CommentUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type OrdersUncheckedUpdateManyWithoutOrderCreatorNestedInput = {
    create?: XOR<OrdersCreateWithoutOrderCreatorInput, OrdersUncheckedCreateWithoutOrderCreatorInput> | OrdersCreateWithoutOrderCreatorInput[] | OrdersUncheckedCreateWithoutOrderCreatorInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutOrderCreatorInput | OrdersCreateOrConnectWithoutOrderCreatorInput[]
    upsert?: OrdersUpsertWithWhereUniqueWithoutOrderCreatorInput | OrdersUpsertWithWhereUniqueWithoutOrderCreatorInput[]
    createMany?: OrdersCreateManyOrderCreatorInputEnvelope
    set?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    disconnect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    delete?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    update?: OrdersUpdateWithWhereUniqueWithoutOrderCreatorInput | OrdersUpdateWithWhereUniqueWithoutOrderCreatorInput[]
    updateMany?: OrdersUpdateManyWithWhereWithoutOrderCreatorInput | OrdersUpdateManyWithWhereWithoutOrderCreatorInput[]
    deleteMany?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
  }

  export type SellingHistoryUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<SellingHistoryCreateWithoutAccountInput, SellingHistoryUncheckedCreateWithoutAccountInput> | SellingHistoryCreateWithoutAccountInput[] | SellingHistoryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: SellingHistoryCreateOrConnectWithoutAccountInput | SellingHistoryCreateOrConnectWithoutAccountInput[]
    upsert?: SellingHistoryUpsertWithWhereUniqueWithoutAccountInput | SellingHistoryUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: SellingHistoryCreateManyAccountInputEnvelope
    set?: SellingHistoryWhereUniqueInput | SellingHistoryWhereUniqueInput[]
    disconnect?: SellingHistoryWhereUniqueInput | SellingHistoryWhereUniqueInput[]
    delete?: SellingHistoryWhereUniqueInput | SellingHistoryWhereUniqueInput[]
    connect?: SellingHistoryWhereUniqueInput | SellingHistoryWhereUniqueInput[]
    update?: SellingHistoryUpdateWithWhereUniqueWithoutAccountInput | SellingHistoryUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: SellingHistoryUpdateManyWithWhereWithoutAccountInput | SellingHistoryUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: SellingHistoryScalarWhereInput | SellingHistoryScalarWhereInput[]
  }

  export type BiddingHistoryUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<BiddingHistoryCreateWithoutAccountInput, BiddingHistoryUncheckedCreateWithoutAccountInput> | BiddingHistoryCreateWithoutAccountInput[] | BiddingHistoryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BiddingHistoryCreateOrConnectWithoutAccountInput | BiddingHistoryCreateOrConnectWithoutAccountInput[]
    upsert?: BiddingHistoryUpsertWithWhereUniqueWithoutAccountInput | BiddingHistoryUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: BiddingHistoryCreateManyAccountInputEnvelope
    set?: BiddingHistoryWhereUniqueInput | BiddingHistoryWhereUniqueInput[]
    disconnect?: BiddingHistoryWhereUniqueInput | BiddingHistoryWhereUniqueInput[]
    delete?: BiddingHistoryWhereUniqueInput | BiddingHistoryWhereUniqueInput[]
    connect?: BiddingHistoryWhereUniqueInput | BiddingHistoryWhereUniqueInput[]
    update?: BiddingHistoryUpdateWithWhereUniqueWithoutAccountInput | BiddingHistoryUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: BiddingHistoryUpdateManyWithWhereWithoutAccountInput | BiddingHistoryUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: BiddingHistoryScalarWhereInput | BiddingHistoryScalarWhereInput[]
  }

  export type RequestUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<RequestCreateWithoutAccountInput, RequestUncheckedCreateWithoutAccountInput> | RequestCreateWithoutAccountInput[] | RequestUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: RequestCreateOrConnectWithoutAccountInput | RequestCreateOrConnectWithoutAccountInput[]
    upsert?: RequestUpsertWithWhereUniqueWithoutAccountInput | RequestUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: RequestCreateManyAccountInputEnvelope
    set?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    disconnect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    delete?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    connect?: RequestWhereUniqueInput | RequestWhereUniqueInput[]
    update?: RequestUpdateWithWhereUniqueWithoutAccountInput | RequestUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: RequestUpdateManyWithWhereWithoutAccountInput | RequestUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: RequestScalarWhereInput | RequestScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutCarsInput = {
    create?: XOR<AccountCreateWithoutCarsInput, AccountUncheckedCreateWithoutCarsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCarsInput
    connect?: AccountWhereUniqueInput
  }

  export type AuctionCreateNestedManyWithoutCarInput = {
    create?: XOR<AuctionCreateWithoutCarInput, AuctionUncheckedCreateWithoutCarInput> | AuctionCreateWithoutCarInput[] | AuctionUncheckedCreateWithoutCarInput[]
    connectOrCreate?: AuctionCreateOrConnectWithoutCarInput | AuctionCreateOrConnectWithoutCarInput[]
    createMany?: AuctionCreateManyCarInputEnvelope
    connect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
  }

  export type AuctionUncheckedCreateNestedManyWithoutCarInput = {
    create?: XOR<AuctionCreateWithoutCarInput, AuctionUncheckedCreateWithoutCarInput> | AuctionCreateWithoutCarInput[] | AuctionUncheckedCreateWithoutCarInput[]
    connectOrCreate?: AuctionCreateOrConnectWithoutCarInput | AuctionCreateOrConnectWithoutCarInput[]
    createMany?: AuctionCreateManyCarInputEnvelope
    connect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Buffer | null
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AccountUpdateOneRequiredWithoutCarsNestedInput = {
    create?: XOR<AccountCreateWithoutCarsInput, AccountUncheckedCreateWithoutCarsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCarsInput
    upsert?: AccountUpsertWithoutCarsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutCarsInput, AccountUpdateWithoutCarsInput>, AccountUncheckedUpdateWithoutCarsInput>
  }

  export type AuctionUpdateManyWithoutCarNestedInput = {
    create?: XOR<AuctionCreateWithoutCarInput, AuctionUncheckedCreateWithoutCarInput> | AuctionCreateWithoutCarInput[] | AuctionUncheckedCreateWithoutCarInput[]
    connectOrCreate?: AuctionCreateOrConnectWithoutCarInput | AuctionCreateOrConnectWithoutCarInput[]
    upsert?: AuctionUpsertWithWhereUniqueWithoutCarInput | AuctionUpsertWithWhereUniqueWithoutCarInput[]
    createMany?: AuctionCreateManyCarInputEnvelope
    set?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    disconnect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    delete?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    connect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    update?: AuctionUpdateWithWhereUniqueWithoutCarInput | AuctionUpdateWithWhereUniqueWithoutCarInput[]
    updateMany?: AuctionUpdateManyWithWhereWithoutCarInput | AuctionUpdateManyWithWhereWithoutCarInput[]
    deleteMany?: AuctionScalarWhereInput | AuctionScalarWhereInput[]
  }

  export type AuctionUncheckedUpdateManyWithoutCarNestedInput = {
    create?: XOR<AuctionCreateWithoutCarInput, AuctionUncheckedCreateWithoutCarInput> | AuctionCreateWithoutCarInput[] | AuctionUncheckedCreateWithoutCarInput[]
    connectOrCreate?: AuctionCreateOrConnectWithoutCarInput | AuctionCreateOrConnectWithoutCarInput[]
    upsert?: AuctionUpsertWithWhereUniqueWithoutCarInput | AuctionUpsertWithWhereUniqueWithoutCarInput[]
    createMany?: AuctionCreateManyCarInputEnvelope
    set?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    disconnect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    delete?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    connect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    update?: AuctionUpdateWithWhereUniqueWithoutCarInput | AuctionUpdateWithWhereUniqueWithoutCarInput[]
    updateMany?: AuctionUpdateManyWithWhereWithoutCarInput | AuctionUpdateManyWithWhereWithoutCarInput[]
    deleteMany?: AuctionScalarWhereInput | AuctionScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutAuctionsInput = {
    create?: XOR<AccountCreateWithoutAuctionsInput, AccountUncheckedCreateWithoutAuctionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAuctionsInput
    connect?: AccountWhereUniqueInput
  }

  export type CarCreateNestedOneWithoutAuctionsInput = {
    create?: XOR<CarCreateWithoutAuctionsInput, CarUncheckedCreateWithoutAuctionsInput>
    connectOrCreate?: CarCreateOrConnectWithoutAuctionsInput
    connect?: CarWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutAuctionInput = {
    create?: XOR<CommentCreateWithoutAuctionInput, CommentUncheckedCreateWithoutAuctionInput> | CommentCreateWithoutAuctionInput[] | CommentUncheckedCreateWithoutAuctionInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuctionInput | CommentCreateOrConnectWithoutAuctionInput[]
    createMany?: CommentCreateManyAuctionInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type OrdersCreateNestedManyWithoutAuctionInput = {
    create?: XOR<OrdersCreateWithoutAuctionInput, OrdersUncheckedCreateWithoutAuctionInput> | OrdersCreateWithoutAuctionInput[] | OrdersUncheckedCreateWithoutAuctionInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutAuctionInput | OrdersCreateOrConnectWithoutAuctionInput[]
    createMany?: OrdersCreateManyAuctionInputEnvelope
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
  }

  export type BiddingHistoryCreateNestedManyWithoutAuctionInput = {
    create?: XOR<BiddingHistoryCreateWithoutAuctionInput, BiddingHistoryUncheckedCreateWithoutAuctionInput> | BiddingHistoryCreateWithoutAuctionInput[] | BiddingHistoryUncheckedCreateWithoutAuctionInput[]
    connectOrCreate?: BiddingHistoryCreateOrConnectWithoutAuctionInput | BiddingHistoryCreateOrConnectWithoutAuctionInput[]
    createMany?: BiddingHistoryCreateManyAuctionInputEnvelope
    connect?: BiddingHistoryWhereUniqueInput | BiddingHistoryWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutAuctionInput = {
    create?: XOR<CommentCreateWithoutAuctionInput, CommentUncheckedCreateWithoutAuctionInput> | CommentCreateWithoutAuctionInput[] | CommentUncheckedCreateWithoutAuctionInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuctionInput | CommentCreateOrConnectWithoutAuctionInput[]
    createMany?: CommentCreateManyAuctionInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type OrdersUncheckedCreateNestedManyWithoutAuctionInput = {
    create?: XOR<OrdersCreateWithoutAuctionInput, OrdersUncheckedCreateWithoutAuctionInput> | OrdersCreateWithoutAuctionInput[] | OrdersUncheckedCreateWithoutAuctionInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutAuctionInput | OrdersCreateOrConnectWithoutAuctionInput[]
    createMany?: OrdersCreateManyAuctionInputEnvelope
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
  }

  export type BiddingHistoryUncheckedCreateNestedManyWithoutAuctionInput = {
    create?: XOR<BiddingHistoryCreateWithoutAuctionInput, BiddingHistoryUncheckedCreateWithoutAuctionInput> | BiddingHistoryCreateWithoutAuctionInput[] | BiddingHistoryUncheckedCreateWithoutAuctionInput[]
    connectOrCreate?: BiddingHistoryCreateOrConnectWithoutAuctionInput | BiddingHistoryCreateOrConnectWithoutAuctionInput[]
    createMany?: BiddingHistoryCreateManyAuctionInputEnvelope
    connect?: BiddingHistoryWhereUniqueInput | BiddingHistoryWhereUniqueInput[]
  }

  export type AccountUpdateOneRequiredWithoutAuctionsNestedInput = {
    create?: XOR<AccountCreateWithoutAuctionsInput, AccountUncheckedCreateWithoutAuctionsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAuctionsInput
    upsert?: AccountUpsertWithoutAuctionsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutAuctionsInput, AccountUpdateWithoutAuctionsInput>, AccountUncheckedUpdateWithoutAuctionsInput>
  }

  export type CarUpdateOneRequiredWithoutAuctionsNestedInput = {
    create?: XOR<CarCreateWithoutAuctionsInput, CarUncheckedCreateWithoutAuctionsInput>
    connectOrCreate?: CarCreateOrConnectWithoutAuctionsInput
    upsert?: CarUpsertWithoutAuctionsInput
    connect?: CarWhereUniqueInput
    update?: XOR<XOR<CarUpdateToOneWithWhereWithoutAuctionsInput, CarUpdateWithoutAuctionsInput>, CarUncheckedUpdateWithoutAuctionsInput>
  }

  export type CommentUpdateManyWithoutAuctionNestedInput = {
    create?: XOR<CommentCreateWithoutAuctionInput, CommentUncheckedCreateWithoutAuctionInput> | CommentCreateWithoutAuctionInput[] | CommentUncheckedCreateWithoutAuctionInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuctionInput | CommentCreateOrConnectWithoutAuctionInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuctionInput | CommentUpsertWithWhereUniqueWithoutAuctionInput[]
    createMany?: CommentCreateManyAuctionInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuctionInput | CommentUpdateWithWhereUniqueWithoutAuctionInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuctionInput | CommentUpdateManyWithWhereWithoutAuctionInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type OrdersUpdateManyWithoutAuctionNestedInput = {
    create?: XOR<OrdersCreateWithoutAuctionInput, OrdersUncheckedCreateWithoutAuctionInput> | OrdersCreateWithoutAuctionInput[] | OrdersUncheckedCreateWithoutAuctionInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutAuctionInput | OrdersCreateOrConnectWithoutAuctionInput[]
    upsert?: OrdersUpsertWithWhereUniqueWithoutAuctionInput | OrdersUpsertWithWhereUniqueWithoutAuctionInput[]
    createMany?: OrdersCreateManyAuctionInputEnvelope
    set?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    disconnect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    delete?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    update?: OrdersUpdateWithWhereUniqueWithoutAuctionInput | OrdersUpdateWithWhereUniqueWithoutAuctionInput[]
    updateMany?: OrdersUpdateManyWithWhereWithoutAuctionInput | OrdersUpdateManyWithWhereWithoutAuctionInput[]
    deleteMany?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
  }

  export type BiddingHistoryUpdateManyWithoutAuctionNestedInput = {
    create?: XOR<BiddingHistoryCreateWithoutAuctionInput, BiddingHistoryUncheckedCreateWithoutAuctionInput> | BiddingHistoryCreateWithoutAuctionInput[] | BiddingHistoryUncheckedCreateWithoutAuctionInput[]
    connectOrCreate?: BiddingHistoryCreateOrConnectWithoutAuctionInput | BiddingHistoryCreateOrConnectWithoutAuctionInput[]
    upsert?: BiddingHistoryUpsertWithWhereUniqueWithoutAuctionInput | BiddingHistoryUpsertWithWhereUniqueWithoutAuctionInput[]
    createMany?: BiddingHistoryCreateManyAuctionInputEnvelope
    set?: BiddingHistoryWhereUniqueInput | BiddingHistoryWhereUniqueInput[]
    disconnect?: BiddingHistoryWhereUniqueInput | BiddingHistoryWhereUniqueInput[]
    delete?: BiddingHistoryWhereUniqueInput | BiddingHistoryWhereUniqueInput[]
    connect?: BiddingHistoryWhereUniqueInput | BiddingHistoryWhereUniqueInput[]
    update?: BiddingHistoryUpdateWithWhereUniqueWithoutAuctionInput | BiddingHistoryUpdateWithWhereUniqueWithoutAuctionInput[]
    updateMany?: BiddingHistoryUpdateManyWithWhereWithoutAuctionInput | BiddingHistoryUpdateManyWithWhereWithoutAuctionInput[]
    deleteMany?: BiddingHistoryScalarWhereInput | BiddingHistoryScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutAuctionNestedInput = {
    create?: XOR<CommentCreateWithoutAuctionInput, CommentUncheckedCreateWithoutAuctionInput> | CommentCreateWithoutAuctionInput[] | CommentUncheckedCreateWithoutAuctionInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuctionInput | CommentCreateOrConnectWithoutAuctionInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuctionInput | CommentUpsertWithWhereUniqueWithoutAuctionInput[]
    createMany?: CommentCreateManyAuctionInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuctionInput | CommentUpdateWithWhereUniqueWithoutAuctionInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuctionInput | CommentUpdateManyWithWhereWithoutAuctionInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type OrdersUncheckedUpdateManyWithoutAuctionNestedInput = {
    create?: XOR<OrdersCreateWithoutAuctionInput, OrdersUncheckedCreateWithoutAuctionInput> | OrdersCreateWithoutAuctionInput[] | OrdersUncheckedCreateWithoutAuctionInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutAuctionInput | OrdersCreateOrConnectWithoutAuctionInput[]
    upsert?: OrdersUpsertWithWhereUniqueWithoutAuctionInput | OrdersUpsertWithWhereUniqueWithoutAuctionInput[]
    createMany?: OrdersCreateManyAuctionInputEnvelope
    set?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    disconnect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    delete?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    update?: OrdersUpdateWithWhereUniqueWithoutAuctionInput | OrdersUpdateWithWhereUniqueWithoutAuctionInput[]
    updateMany?: OrdersUpdateManyWithWhereWithoutAuctionInput | OrdersUpdateManyWithWhereWithoutAuctionInput[]
    deleteMany?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
  }

  export type BiddingHistoryUncheckedUpdateManyWithoutAuctionNestedInput = {
    create?: XOR<BiddingHistoryCreateWithoutAuctionInput, BiddingHistoryUncheckedCreateWithoutAuctionInput> | BiddingHistoryCreateWithoutAuctionInput[] | BiddingHistoryUncheckedCreateWithoutAuctionInput[]
    connectOrCreate?: BiddingHistoryCreateOrConnectWithoutAuctionInput | BiddingHistoryCreateOrConnectWithoutAuctionInput[]
    upsert?: BiddingHistoryUpsertWithWhereUniqueWithoutAuctionInput | BiddingHistoryUpsertWithWhereUniqueWithoutAuctionInput[]
    createMany?: BiddingHistoryCreateManyAuctionInputEnvelope
    set?: BiddingHistoryWhereUniqueInput | BiddingHistoryWhereUniqueInput[]
    disconnect?: BiddingHistoryWhereUniqueInput | BiddingHistoryWhereUniqueInput[]
    delete?: BiddingHistoryWhereUniqueInput | BiddingHistoryWhereUniqueInput[]
    connect?: BiddingHistoryWhereUniqueInput | BiddingHistoryWhereUniqueInput[]
    update?: BiddingHistoryUpdateWithWhereUniqueWithoutAuctionInput | BiddingHistoryUpdateWithWhereUniqueWithoutAuctionInput[]
    updateMany?: BiddingHistoryUpdateManyWithWhereWithoutAuctionInput | BiddingHistoryUpdateManyWithWhereWithoutAuctionInput[]
    deleteMany?: BiddingHistoryScalarWhereInput | BiddingHistoryScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutCommentsInput = {
    create?: XOR<AccountCreateWithoutCommentsInput, AccountUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCommentsInput
    connect?: AccountWhereUniqueInput
  }

  export type AuctionCreateNestedOneWithoutCommentsInput = {
    create?: XOR<AuctionCreateWithoutCommentsInput, AuctionUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: AuctionCreateOrConnectWithoutCommentsInput
    connect?: AuctionWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<AccountCreateWithoutCommentsInput, AccountUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCommentsInput
    upsert?: AccountUpsertWithoutCommentsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutCommentsInput, AccountUpdateWithoutCommentsInput>, AccountUncheckedUpdateWithoutCommentsInput>
  }

  export type AuctionUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<AuctionCreateWithoutCommentsInput, AuctionUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: AuctionCreateOrConnectWithoutCommentsInput
    upsert?: AuctionUpsertWithoutCommentsInput
    connect?: AuctionWhereUniqueInput
    update?: XOR<XOR<AuctionUpdateToOneWithWhereWithoutCommentsInput, AuctionUpdateWithoutCommentsInput>, AuctionUncheckedUpdateWithoutCommentsInput>
  }

  export type AccountCreateNestedOneWithoutOrdersInput = {
    create?: XOR<AccountCreateWithoutOrdersInput, AccountUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: AccountCreateOrConnectWithoutOrdersInput
    connect?: AccountWhereUniqueInput
  }

  export type AuctionCreateNestedOneWithoutOrdersInput = {
    create?: XOR<AuctionCreateWithoutOrdersInput, AuctionUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: AuctionCreateOrConnectWithoutOrdersInput
    connect?: AuctionWhereUniqueInput
  }

  export type SellingHistoryCreateNestedManyWithoutOrderInput = {
    create?: XOR<SellingHistoryCreateWithoutOrderInput, SellingHistoryUncheckedCreateWithoutOrderInput> | SellingHistoryCreateWithoutOrderInput[] | SellingHistoryUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: SellingHistoryCreateOrConnectWithoutOrderInput | SellingHistoryCreateOrConnectWithoutOrderInput[]
    createMany?: SellingHistoryCreateManyOrderInputEnvelope
    connect?: SellingHistoryWhereUniqueInput | SellingHistoryWhereUniqueInput[]
  }

  export type SellingHistoryUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<SellingHistoryCreateWithoutOrderInput, SellingHistoryUncheckedCreateWithoutOrderInput> | SellingHistoryCreateWithoutOrderInput[] | SellingHistoryUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: SellingHistoryCreateOrConnectWithoutOrderInput | SellingHistoryCreateOrConnectWithoutOrderInput[]
    createMany?: SellingHistoryCreateManyOrderInputEnvelope
    connect?: SellingHistoryWhereUniqueInput | SellingHistoryWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AccountUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<AccountCreateWithoutOrdersInput, AccountUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: AccountCreateOrConnectWithoutOrdersInput
    upsert?: AccountUpsertWithoutOrdersInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutOrdersInput, AccountUpdateWithoutOrdersInput>, AccountUncheckedUpdateWithoutOrdersInput>
  }

  export type AuctionUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<AuctionCreateWithoutOrdersInput, AuctionUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: AuctionCreateOrConnectWithoutOrdersInput
    upsert?: AuctionUpsertWithoutOrdersInput
    connect?: AuctionWhereUniqueInput
    update?: XOR<XOR<AuctionUpdateToOneWithWhereWithoutOrdersInput, AuctionUpdateWithoutOrdersInput>, AuctionUncheckedUpdateWithoutOrdersInput>
  }

  export type SellingHistoryUpdateManyWithoutOrderNestedInput = {
    create?: XOR<SellingHistoryCreateWithoutOrderInput, SellingHistoryUncheckedCreateWithoutOrderInput> | SellingHistoryCreateWithoutOrderInput[] | SellingHistoryUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: SellingHistoryCreateOrConnectWithoutOrderInput | SellingHistoryCreateOrConnectWithoutOrderInput[]
    upsert?: SellingHistoryUpsertWithWhereUniqueWithoutOrderInput | SellingHistoryUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: SellingHistoryCreateManyOrderInputEnvelope
    set?: SellingHistoryWhereUniqueInput | SellingHistoryWhereUniqueInput[]
    disconnect?: SellingHistoryWhereUniqueInput | SellingHistoryWhereUniqueInput[]
    delete?: SellingHistoryWhereUniqueInput | SellingHistoryWhereUniqueInput[]
    connect?: SellingHistoryWhereUniqueInput | SellingHistoryWhereUniqueInput[]
    update?: SellingHistoryUpdateWithWhereUniqueWithoutOrderInput | SellingHistoryUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: SellingHistoryUpdateManyWithWhereWithoutOrderInput | SellingHistoryUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: SellingHistoryScalarWhereInput | SellingHistoryScalarWhereInput[]
  }

  export type SellingHistoryUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<SellingHistoryCreateWithoutOrderInput, SellingHistoryUncheckedCreateWithoutOrderInput> | SellingHistoryCreateWithoutOrderInput[] | SellingHistoryUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: SellingHistoryCreateOrConnectWithoutOrderInput | SellingHistoryCreateOrConnectWithoutOrderInput[]
    upsert?: SellingHistoryUpsertWithWhereUniqueWithoutOrderInput | SellingHistoryUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: SellingHistoryCreateManyOrderInputEnvelope
    set?: SellingHistoryWhereUniqueInput | SellingHistoryWhereUniqueInput[]
    disconnect?: SellingHistoryWhereUniqueInput | SellingHistoryWhereUniqueInput[]
    delete?: SellingHistoryWhereUniqueInput | SellingHistoryWhereUniqueInput[]
    connect?: SellingHistoryWhereUniqueInput | SellingHistoryWhereUniqueInput[]
    update?: SellingHistoryUpdateWithWhereUniqueWithoutOrderInput | SellingHistoryUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: SellingHistoryUpdateManyWithWhereWithoutOrderInput | SellingHistoryUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: SellingHistoryScalarWhereInput | SellingHistoryScalarWhereInput[]
  }

  export type OrdersCreateNestedOneWithoutSellingHistoryInput = {
    create?: XOR<OrdersCreateWithoutSellingHistoryInput, OrdersUncheckedCreateWithoutSellingHistoryInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutSellingHistoryInput
    connect?: OrdersWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutSellingHistoryInput = {
    create?: XOR<AccountCreateWithoutSellingHistoryInput, AccountUncheckedCreateWithoutSellingHistoryInput>
    connectOrCreate?: AccountCreateOrConnectWithoutSellingHistoryInput
    connect?: AccountWhereUniqueInput
  }

  export type OrdersUpdateOneRequiredWithoutSellingHistoryNestedInput = {
    create?: XOR<OrdersCreateWithoutSellingHistoryInput, OrdersUncheckedCreateWithoutSellingHistoryInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutSellingHistoryInput
    upsert?: OrdersUpsertWithoutSellingHistoryInput
    connect?: OrdersWhereUniqueInput
    update?: XOR<XOR<OrdersUpdateToOneWithWhereWithoutSellingHistoryInput, OrdersUpdateWithoutSellingHistoryInput>, OrdersUncheckedUpdateWithoutSellingHistoryInput>
  }

  export type AccountUpdateOneRequiredWithoutSellingHistoryNestedInput = {
    create?: XOR<AccountCreateWithoutSellingHistoryInput, AccountUncheckedCreateWithoutSellingHistoryInput>
    connectOrCreate?: AccountCreateOrConnectWithoutSellingHistoryInput
    upsert?: AccountUpsertWithoutSellingHistoryInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutSellingHistoryInput, AccountUpdateWithoutSellingHistoryInput>, AccountUncheckedUpdateWithoutSellingHistoryInput>
  }

  export type AccountCreateNestedOneWithoutBiddingHistoryInput = {
    create?: XOR<AccountCreateWithoutBiddingHistoryInput, AccountUncheckedCreateWithoutBiddingHistoryInput>
    connectOrCreate?: AccountCreateOrConnectWithoutBiddingHistoryInput
    connect?: AccountWhereUniqueInput
  }

  export type AuctionCreateNestedOneWithoutBiddingHistoriesInput = {
    create?: XOR<AuctionCreateWithoutBiddingHistoriesInput, AuctionUncheckedCreateWithoutBiddingHistoriesInput>
    connectOrCreate?: AuctionCreateOrConnectWithoutBiddingHistoriesInput
    connect?: AuctionWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutBiddingHistoryNestedInput = {
    create?: XOR<AccountCreateWithoutBiddingHistoryInput, AccountUncheckedCreateWithoutBiddingHistoryInput>
    connectOrCreate?: AccountCreateOrConnectWithoutBiddingHistoryInput
    upsert?: AccountUpsertWithoutBiddingHistoryInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutBiddingHistoryInput, AccountUpdateWithoutBiddingHistoryInput>, AccountUncheckedUpdateWithoutBiddingHistoryInput>
  }

  export type AuctionUpdateOneRequiredWithoutBiddingHistoriesNestedInput = {
    create?: XOR<AuctionCreateWithoutBiddingHistoriesInput, AuctionUncheckedCreateWithoutBiddingHistoriesInput>
    connectOrCreate?: AuctionCreateOrConnectWithoutBiddingHistoriesInput
    upsert?: AuctionUpsertWithoutBiddingHistoriesInput
    connect?: AuctionWhereUniqueInput
    update?: XOR<XOR<AuctionUpdateToOneWithWhereWithoutBiddingHistoriesInput, AuctionUpdateWithoutBiddingHistoriesInput>, AuctionUncheckedUpdateWithoutBiddingHistoriesInput>
  }

  export type AccountCreateNestedOneWithoutRequestsInput = {
    create?: XOR<AccountCreateWithoutRequestsInput, AccountUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutRequestsInput
    connect?: AccountWhereUniqueInput
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Buffer
  }

  export type AccountUpdateOneRequiredWithoutRequestsNestedInput = {
    create?: XOR<AccountCreateWithoutRequestsInput, AccountUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutRequestsInput
    upsert?: AccountUpsertWithoutRequestsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutRequestsInput, AccountUpdateWithoutRequestsInput>, AccountUncheckedUpdateWithoutRequestsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | null
    notIn?: Buffer[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Buffer | null
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | null
    notIn?: Buffer[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Buffer | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[]
    notIn?: Buffer[]
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[]
    notIn?: Buffer[]
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type AccountCreateWithoutUserInput = {
    accountType: string
    accountStatus: string
    username: string
    password: string
    token2fa?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cars?: CarCreateNestedManyWithoutAccountInput
    auctions?: AuctionCreateNestedManyWithoutAuctionCreatorInput
    comments?: CommentCreateNestedManyWithoutAccountInput
    orders?: OrdersCreateNestedManyWithoutOrderCreatorInput
    sellingHistory?: SellingHistoryCreateNestedManyWithoutAccountInput
    biddingHistory?: BiddingHistoryCreateNestedManyWithoutAccountInput
    requests?: RequestCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    accountID?: number
    accountType: string
    accountStatus: string
    username: string
    password: string
    token2fa?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cars?: CarUncheckedCreateNestedManyWithoutAccountInput
    auctions?: AuctionUncheckedCreateNestedManyWithoutAuctionCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAccountInput
    orders?: OrdersUncheckedCreateNestedManyWithoutOrderCreatorInput
    sellingHistory?: SellingHistoryUncheckedCreateNestedManyWithoutAccountInput
    biddingHistory?: BiddingHistoryUncheckedCreateNestedManyWithoutAccountInput
    requests?: RequestUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    accountID?: IntFilter<"Account"> | number
    accountType?: StringFilter<"Account"> | string
    accountStatus?: StringFilter<"Account"> | string
    username?: StringFilter<"Account"> | string
    password?: StringFilter<"Account"> | string
    userID?: IntNullableFilter<"Account"> | number | null
    token2fa?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type UserCreateWithoutAccountsInput = {
    firstName: string
    lastName: string
    address?: string | null
    phoneNumber: string
    emailAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    userID?: number
    firstName: string
    lastName: string
    address?: string | null
    phoneNumber: string
    emailAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type CarCreateWithoutAccountInput = {
    vehicleNumber: string
    carImage?: Buffer | null
    highlights?: string | null
    equipment?: string | null
    modifications?: string | null
    knownFlaws?: string | null
    make: string
    model: string
    interiorColor?: string | null
    exteriorColor?: string | null
    startingBid: number
    reservePrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    auctions?: AuctionCreateNestedManyWithoutCarInput
  }

  export type CarUncheckedCreateWithoutAccountInput = {
    carID?: number
    vehicleNumber: string
    carImage?: Buffer | null
    highlights?: string | null
    equipment?: string | null
    modifications?: string | null
    knownFlaws?: string | null
    make: string
    model: string
    interiorColor?: string | null
    exteriorColor?: string | null
    startingBid: number
    reservePrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    auctions?: AuctionUncheckedCreateNestedManyWithoutCarInput
  }

  export type CarCreateOrConnectWithoutAccountInput = {
    where: CarWhereUniqueInput
    create: XOR<CarCreateWithoutAccountInput, CarUncheckedCreateWithoutAccountInput>
  }

  export type CarCreateManyAccountInputEnvelope = {
    data: CarCreateManyAccountInput | CarCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type AuctionCreateWithoutAuctionCreatorInput = {
    auctionStatus: string
    startDate: Date | string
    endDate: Date | string
    currentHighestBid: number
    auctionCreationTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    car: CarCreateNestedOneWithoutAuctionsInput
    comments?: CommentCreateNestedManyWithoutAuctionInput
    orders?: OrdersCreateNestedManyWithoutAuctionInput
    biddingHistories?: BiddingHistoryCreateNestedManyWithoutAuctionInput
  }

  export type AuctionUncheckedCreateWithoutAuctionCreatorInput = {
    auctionID?: number
    auctionStatus: string
    startDate: Date | string
    endDate: Date | string
    currentHighestBid: number
    auctionCreationTime: Date | string
    carID: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutAuctionInput
    orders?: OrdersUncheckedCreateNestedManyWithoutAuctionInput
    biddingHistories?: BiddingHistoryUncheckedCreateNestedManyWithoutAuctionInput
  }

  export type AuctionCreateOrConnectWithoutAuctionCreatorInput = {
    where: AuctionWhereUniqueInput
    create: XOR<AuctionCreateWithoutAuctionCreatorInput, AuctionUncheckedCreateWithoutAuctionCreatorInput>
  }

  export type AuctionCreateManyAuctionCreatorInputEnvelope = {
    data: AuctionCreateManyAuctionCreatorInput | AuctionCreateManyAuctionCreatorInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutAccountInput = {
    details: string
    createdAt?: Date | string
    updatedAt?: Date | string
    auction: AuctionCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutAccountInput = {
    commentID?: number
    details: string
    auctionID: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutAccountInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutAccountInput, CommentUncheckedCreateWithoutAccountInput>
  }

  export type CommentCreateManyAccountInputEnvelope = {
    data: CommentCreateManyAccountInput | CommentCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type OrdersCreateWithoutOrderCreatorInput = {
    orderStatus: string
    paymentDeadline: Date | string
    deliveryType: string
    shippingAddress?: string | null
    orderCreationTime: Date | string
    orderCompletionTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auction: AuctionCreateNestedOneWithoutOrdersInput
    sellingHistory?: SellingHistoryCreateNestedManyWithoutOrderInput
  }

  export type OrdersUncheckedCreateWithoutOrderCreatorInput = {
    orderID?: number
    orderStatus: string
    paymentDeadline: Date | string
    deliveryType: string
    shippingAddress?: string | null
    orderCreationTime: Date | string
    orderCompletionTime?: Date | string | null
    auctionID: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sellingHistory?: SellingHistoryUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrdersCreateOrConnectWithoutOrderCreatorInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutOrderCreatorInput, OrdersUncheckedCreateWithoutOrderCreatorInput>
  }

  export type OrdersCreateManyOrderCreatorInputEnvelope = {
    data: OrdersCreateManyOrderCreatorInput | OrdersCreateManyOrderCreatorInput[]
    skipDuplicates?: boolean
  }

  export type SellingHistoryCreateWithoutAccountInput = {
    order: OrdersCreateNestedOneWithoutSellingHistoryInput
  }

  export type SellingHistoryUncheckedCreateWithoutAccountInput = {
    saleID?: number
    orderID: number
  }

  export type SellingHistoryCreateOrConnectWithoutAccountInput = {
    where: SellingHistoryWhereUniqueInput
    create: XOR<SellingHistoryCreateWithoutAccountInput, SellingHistoryUncheckedCreateWithoutAccountInput>
  }

  export type SellingHistoryCreateManyAccountInputEnvelope = {
    data: SellingHistoryCreateManyAccountInput | SellingHistoryCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type BiddingHistoryCreateWithoutAccountInput = {
    bidAmount: number
    bidTimestamp: Date | string
    bidStatus: string
    createdAt?: Date | string
    updatedAt?: Date | string
    auction: AuctionCreateNestedOneWithoutBiddingHistoriesInput
  }

  export type BiddingHistoryUncheckedCreateWithoutAccountInput = {
    bidID?: number
    bidAmount: number
    bidTimestamp: Date | string
    bidStatus: string
    auctionID: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BiddingHistoryCreateOrConnectWithoutAccountInput = {
    where: BiddingHistoryWhereUniqueInput
    create: XOR<BiddingHistoryCreateWithoutAccountInput, BiddingHistoryUncheckedCreateWithoutAccountInput>
  }

  export type BiddingHistoryCreateManyAccountInputEnvelope = {
    data: BiddingHistoryCreateManyAccountInput | BiddingHistoryCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type RequestCreateWithoutAccountInput = {
    requestStatus: string
    submissionTime: Date | string
    vehicleNumber: string
    carImage: Buffer
    highlights?: string | null
    equipment?: string | null
    modifications?: string | null
    knownFlaws?: string | null
    make: string
    model: string
    interiorColor?: string | null
    exteriorColor?: string | null
    startingBid: number
    reservePrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestUncheckedCreateWithoutAccountInput = {
    requestID?: number
    requestStatus: string
    submissionTime: Date | string
    vehicleNumber: string
    carImage: Buffer
    highlights?: string | null
    equipment?: string | null
    modifications?: string | null
    knownFlaws?: string | null
    make: string
    model: string
    interiorColor?: string | null
    exteriorColor?: string | null
    startingBid: number
    reservePrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestCreateOrConnectWithoutAccountInput = {
    where: RequestWhereUniqueInput
    create: XOR<RequestCreateWithoutAccountInput, RequestUncheckedCreateWithoutAccountInput>
  }

  export type RequestCreateManyAccountInputEnvelope = {
    data: RequestCreateManyAccountInput | RequestCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    emailAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    userID?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    emailAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CarUpsertWithWhereUniqueWithoutAccountInput = {
    where: CarWhereUniqueInput
    update: XOR<CarUpdateWithoutAccountInput, CarUncheckedUpdateWithoutAccountInput>
    create: XOR<CarCreateWithoutAccountInput, CarUncheckedCreateWithoutAccountInput>
  }

  export type CarUpdateWithWhereUniqueWithoutAccountInput = {
    where: CarWhereUniqueInput
    data: XOR<CarUpdateWithoutAccountInput, CarUncheckedUpdateWithoutAccountInput>
  }

  export type CarUpdateManyWithWhereWithoutAccountInput = {
    where: CarScalarWhereInput
    data: XOR<CarUpdateManyMutationInput, CarUncheckedUpdateManyWithoutAccountInput>
  }

  export type CarScalarWhereInput = {
    AND?: CarScalarWhereInput | CarScalarWhereInput[]
    OR?: CarScalarWhereInput[]
    NOT?: CarScalarWhereInput | CarScalarWhereInput[]
    carID?: IntFilter<"Car"> | number
    vehicleNumber?: StringFilter<"Car"> | string
    carImage?: BytesNullableFilter<"Car"> | Buffer | null
    highlights?: StringNullableFilter<"Car"> | string | null
    equipment?: StringNullableFilter<"Car"> | string | null
    modifications?: StringNullableFilter<"Car"> | string | null
    knownFlaws?: StringNullableFilter<"Car"> | string | null
    make?: StringFilter<"Car"> | string
    model?: StringFilter<"Car"> | string
    interiorColor?: StringNullableFilter<"Car"> | string | null
    exteriorColor?: StringNullableFilter<"Car"> | string | null
    startingBid?: FloatFilter<"Car"> | number
    reservePrice?: FloatFilter<"Car"> | number
    accountID?: IntFilter<"Car"> | number
    createdAt?: DateTimeFilter<"Car"> | Date | string
    updatedAt?: DateTimeFilter<"Car"> | Date | string
  }

  export type AuctionUpsertWithWhereUniqueWithoutAuctionCreatorInput = {
    where: AuctionWhereUniqueInput
    update: XOR<AuctionUpdateWithoutAuctionCreatorInput, AuctionUncheckedUpdateWithoutAuctionCreatorInput>
    create: XOR<AuctionCreateWithoutAuctionCreatorInput, AuctionUncheckedCreateWithoutAuctionCreatorInput>
  }

  export type AuctionUpdateWithWhereUniqueWithoutAuctionCreatorInput = {
    where: AuctionWhereUniqueInput
    data: XOR<AuctionUpdateWithoutAuctionCreatorInput, AuctionUncheckedUpdateWithoutAuctionCreatorInput>
  }

  export type AuctionUpdateManyWithWhereWithoutAuctionCreatorInput = {
    where: AuctionScalarWhereInput
    data: XOR<AuctionUpdateManyMutationInput, AuctionUncheckedUpdateManyWithoutAuctionCreatorInput>
  }

  export type AuctionScalarWhereInput = {
    AND?: AuctionScalarWhereInput | AuctionScalarWhereInput[]
    OR?: AuctionScalarWhereInput[]
    NOT?: AuctionScalarWhereInput | AuctionScalarWhereInput[]
    auctionID?: IntFilter<"Auction"> | number
    auctionStatus?: StringFilter<"Auction"> | string
    startDate?: DateTimeFilter<"Auction"> | Date | string
    endDate?: DateTimeFilter<"Auction"> | Date | string
    currentHighestBid?: FloatFilter<"Auction"> | number
    auctionCreationTime?: DateTimeFilter<"Auction"> | Date | string
    auctionCreatorID?: IntFilter<"Auction"> | number
    carID?: IntFilter<"Auction"> | number
    createdAt?: DateTimeFilter<"Auction"> | Date | string
    updatedAt?: DateTimeFilter<"Auction"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutAccountInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutAccountInput, CommentUncheckedUpdateWithoutAccountInput>
    create: XOR<CommentCreateWithoutAccountInput, CommentUncheckedCreateWithoutAccountInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutAccountInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutAccountInput, CommentUncheckedUpdateWithoutAccountInput>
  }

  export type CommentUpdateManyWithWhereWithoutAccountInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutAccountInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    commentID?: IntFilter<"Comment"> | number
    details?: StringFilter<"Comment"> | string
    accountID?: IntFilter<"Comment"> | number
    auctionID?: IntFilter<"Comment"> | number
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type OrdersUpsertWithWhereUniqueWithoutOrderCreatorInput = {
    where: OrdersWhereUniqueInput
    update: XOR<OrdersUpdateWithoutOrderCreatorInput, OrdersUncheckedUpdateWithoutOrderCreatorInput>
    create: XOR<OrdersCreateWithoutOrderCreatorInput, OrdersUncheckedCreateWithoutOrderCreatorInput>
  }

  export type OrdersUpdateWithWhereUniqueWithoutOrderCreatorInput = {
    where: OrdersWhereUniqueInput
    data: XOR<OrdersUpdateWithoutOrderCreatorInput, OrdersUncheckedUpdateWithoutOrderCreatorInput>
  }

  export type OrdersUpdateManyWithWhereWithoutOrderCreatorInput = {
    where: OrdersScalarWhereInput
    data: XOR<OrdersUpdateManyMutationInput, OrdersUncheckedUpdateManyWithoutOrderCreatorInput>
  }

  export type OrdersScalarWhereInput = {
    AND?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
    OR?: OrdersScalarWhereInput[]
    NOT?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
    orderID?: IntFilter<"Orders"> | number
    orderStatus?: StringFilter<"Orders"> | string
    paymentDeadline?: DateTimeFilter<"Orders"> | Date | string
    deliveryType?: StringFilter<"Orders"> | string
    shippingAddress?: StringNullableFilter<"Orders"> | string | null
    orderCreationTime?: DateTimeFilter<"Orders"> | Date | string
    orderCompletionTime?: DateTimeNullableFilter<"Orders"> | Date | string | null
    orderCreatorID?: IntFilter<"Orders"> | number
    auctionID?: IntFilter<"Orders"> | number
    createdAt?: DateTimeFilter<"Orders"> | Date | string
    updatedAt?: DateTimeFilter<"Orders"> | Date | string
  }

  export type SellingHistoryUpsertWithWhereUniqueWithoutAccountInput = {
    where: SellingHistoryWhereUniqueInput
    update: XOR<SellingHistoryUpdateWithoutAccountInput, SellingHistoryUncheckedUpdateWithoutAccountInput>
    create: XOR<SellingHistoryCreateWithoutAccountInput, SellingHistoryUncheckedCreateWithoutAccountInput>
  }

  export type SellingHistoryUpdateWithWhereUniqueWithoutAccountInput = {
    where: SellingHistoryWhereUniqueInput
    data: XOR<SellingHistoryUpdateWithoutAccountInput, SellingHistoryUncheckedUpdateWithoutAccountInput>
  }

  export type SellingHistoryUpdateManyWithWhereWithoutAccountInput = {
    where: SellingHistoryScalarWhereInput
    data: XOR<SellingHistoryUpdateManyMutationInput, SellingHistoryUncheckedUpdateManyWithoutAccountInput>
  }

  export type SellingHistoryScalarWhereInput = {
    AND?: SellingHistoryScalarWhereInput | SellingHistoryScalarWhereInput[]
    OR?: SellingHistoryScalarWhereInput[]
    NOT?: SellingHistoryScalarWhereInput | SellingHistoryScalarWhereInput[]
    saleID?: IntFilter<"SellingHistory"> | number
    orderID?: IntFilter<"SellingHistory"> | number
    accountID?: IntFilter<"SellingHistory"> | number
  }

  export type BiddingHistoryUpsertWithWhereUniqueWithoutAccountInput = {
    where: BiddingHistoryWhereUniqueInput
    update: XOR<BiddingHistoryUpdateWithoutAccountInput, BiddingHistoryUncheckedUpdateWithoutAccountInput>
    create: XOR<BiddingHistoryCreateWithoutAccountInput, BiddingHistoryUncheckedCreateWithoutAccountInput>
  }

  export type BiddingHistoryUpdateWithWhereUniqueWithoutAccountInput = {
    where: BiddingHistoryWhereUniqueInput
    data: XOR<BiddingHistoryUpdateWithoutAccountInput, BiddingHistoryUncheckedUpdateWithoutAccountInput>
  }

  export type BiddingHistoryUpdateManyWithWhereWithoutAccountInput = {
    where: BiddingHistoryScalarWhereInput
    data: XOR<BiddingHistoryUpdateManyMutationInput, BiddingHistoryUncheckedUpdateManyWithoutAccountInput>
  }

  export type BiddingHistoryScalarWhereInput = {
    AND?: BiddingHistoryScalarWhereInput | BiddingHistoryScalarWhereInput[]
    OR?: BiddingHistoryScalarWhereInput[]
    NOT?: BiddingHistoryScalarWhereInput | BiddingHistoryScalarWhereInput[]
    bidID?: IntFilter<"BiddingHistory"> | number
    bidAmount?: FloatFilter<"BiddingHistory"> | number
    bidTimestamp?: DateTimeFilter<"BiddingHistory"> | Date | string
    bidStatus?: StringFilter<"BiddingHistory"> | string
    accountID?: IntFilter<"BiddingHistory"> | number
    auctionID?: IntFilter<"BiddingHistory"> | number
    createdAt?: DateTimeFilter<"BiddingHistory"> | Date | string
    updatedAt?: DateTimeFilter<"BiddingHistory"> | Date | string
  }

  export type RequestUpsertWithWhereUniqueWithoutAccountInput = {
    where: RequestWhereUniqueInput
    update: XOR<RequestUpdateWithoutAccountInput, RequestUncheckedUpdateWithoutAccountInput>
    create: XOR<RequestCreateWithoutAccountInput, RequestUncheckedCreateWithoutAccountInput>
  }

  export type RequestUpdateWithWhereUniqueWithoutAccountInput = {
    where: RequestWhereUniqueInput
    data: XOR<RequestUpdateWithoutAccountInput, RequestUncheckedUpdateWithoutAccountInput>
  }

  export type RequestUpdateManyWithWhereWithoutAccountInput = {
    where: RequestScalarWhereInput
    data: XOR<RequestUpdateManyMutationInput, RequestUncheckedUpdateManyWithoutAccountInput>
  }

  export type RequestScalarWhereInput = {
    AND?: RequestScalarWhereInput | RequestScalarWhereInput[]
    OR?: RequestScalarWhereInput[]
    NOT?: RequestScalarWhereInput | RequestScalarWhereInput[]
    requestID?: IntFilter<"Request"> | number
    requestStatus?: StringFilter<"Request"> | string
    submissionTime?: DateTimeFilter<"Request"> | Date | string
    vehicleNumber?: StringFilter<"Request"> | string
    carImage?: BytesFilter<"Request"> | Buffer
    highlights?: StringNullableFilter<"Request"> | string | null
    equipment?: StringNullableFilter<"Request"> | string | null
    modifications?: StringNullableFilter<"Request"> | string | null
    knownFlaws?: StringNullableFilter<"Request"> | string | null
    make?: StringFilter<"Request"> | string
    model?: StringFilter<"Request"> | string
    interiorColor?: StringNullableFilter<"Request"> | string | null
    exteriorColor?: StringNullableFilter<"Request"> | string | null
    startingBid?: FloatFilter<"Request"> | number
    reservePrice?: FloatFilter<"Request"> | number
    accountID?: IntFilter<"Request"> | number
    createdAt?: DateTimeFilter<"Request"> | Date | string
    updatedAt?: DateTimeFilter<"Request"> | Date | string
  }

  export type AccountCreateWithoutCarsInput = {
    accountType: string
    accountStatus: string
    username: string
    password: string
    token2fa?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAccountsInput
    auctions?: AuctionCreateNestedManyWithoutAuctionCreatorInput
    comments?: CommentCreateNestedManyWithoutAccountInput
    orders?: OrdersCreateNestedManyWithoutOrderCreatorInput
    sellingHistory?: SellingHistoryCreateNestedManyWithoutAccountInput
    biddingHistory?: BiddingHistoryCreateNestedManyWithoutAccountInput
    requests?: RequestCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutCarsInput = {
    accountID?: number
    accountType: string
    accountStatus: string
    username: string
    password: string
    userID?: number | null
    token2fa?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auctions?: AuctionUncheckedCreateNestedManyWithoutAuctionCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAccountInput
    orders?: OrdersUncheckedCreateNestedManyWithoutOrderCreatorInput
    sellingHistory?: SellingHistoryUncheckedCreateNestedManyWithoutAccountInput
    biddingHistory?: BiddingHistoryUncheckedCreateNestedManyWithoutAccountInput
    requests?: RequestUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutCarsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutCarsInput, AccountUncheckedCreateWithoutCarsInput>
  }

  export type AuctionCreateWithoutCarInput = {
    auctionStatus: string
    startDate: Date | string
    endDate: Date | string
    currentHighestBid: number
    auctionCreationTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    auctionCreator: AccountCreateNestedOneWithoutAuctionsInput
    comments?: CommentCreateNestedManyWithoutAuctionInput
    orders?: OrdersCreateNestedManyWithoutAuctionInput
    biddingHistories?: BiddingHistoryCreateNestedManyWithoutAuctionInput
  }

  export type AuctionUncheckedCreateWithoutCarInput = {
    auctionID?: number
    auctionStatus: string
    startDate: Date | string
    endDate: Date | string
    currentHighestBid: number
    auctionCreationTime: Date | string
    auctionCreatorID: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutAuctionInput
    orders?: OrdersUncheckedCreateNestedManyWithoutAuctionInput
    biddingHistories?: BiddingHistoryUncheckedCreateNestedManyWithoutAuctionInput
  }

  export type AuctionCreateOrConnectWithoutCarInput = {
    where: AuctionWhereUniqueInput
    create: XOR<AuctionCreateWithoutCarInput, AuctionUncheckedCreateWithoutCarInput>
  }

  export type AuctionCreateManyCarInputEnvelope = {
    data: AuctionCreateManyCarInput | AuctionCreateManyCarInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutCarsInput = {
    update: XOR<AccountUpdateWithoutCarsInput, AccountUncheckedUpdateWithoutCarsInput>
    create: XOR<AccountCreateWithoutCarsInput, AccountUncheckedCreateWithoutCarsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutCarsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutCarsInput, AccountUncheckedUpdateWithoutCarsInput>
  }

  export type AccountUpdateWithoutCarsInput = {
    accountType?: StringFieldUpdateOperationsInput | string
    accountStatus?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    token2fa?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAccountsNestedInput
    auctions?: AuctionUpdateManyWithoutAuctionCreatorNestedInput
    comments?: CommentUpdateManyWithoutAccountNestedInput
    orders?: OrdersUpdateManyWithoutOrderCreatorNestedInput
    sellingHistory?: SellingHistoryUpdateManyWithoutAccountNestedInput
    biddingHistory?: BiddingHistoryUpdateManyWithoutAccountNestedInput
    requests?: RequestUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutCarsInput = {
    accountID?: IntFieldUpdateOperationsInput | number
    accountType?: StringFieldUpdateOperationsInput | string
    accountStatus?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userID?: NullableIntFieldUpdateOperationsInput | number | null
    token2fa?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auctions?: AuctionUncheckedUpdateManyWithoutAuctionCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAccountNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutOrderCreatorNestedInput
    sellingHistory?: SellingHistoryUncheckedUpdateManyWithoutAccountNestedInput
    biddingHistory?: BiddingHistoryUncheckedUpdateManyWithoutAccountNestedInput
    requests?: RequestUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AuctionUpsertWithWhereUniqueWithoutCarInput = {
    where: AuctionWhereUniqueInput
    update: XOR<AuctionUpdateWithoutCarInput, AuctionUncheckedUpdateWithoutCarInput>
    create: XOR<AuctionCreateWithoutCarInput, AuctionUncheckedCreateWithoutCarInput>
  }

  export type AuctionUpdateWithWhereUniqueWithoutCarInput = {
    where: AuctionWhereUniqueInput
    data: XOR<AuctionUpdateWithoutCarInput, AuctionUncheckedUpdateWithoutCarInput>
  }

  export type AuctionUpdateManyWithWhereWithoutCarInput = {
    where: AuctionScalarWhereInput
    data: XOR<AuctionUpdateManyMutationInput, AuctionUncheckedUpdateManyWithoutCarInput>
  }

  export type AccountCreateWithoutAuctionsInput = {
    accountType: string
    accountStatus: string
    username: string
    password: string
    token2fa?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAccountsInput
    cars?: CarCreateNestedManyWithoutAccountInput
    comments?: CommentCreateNestedManyWithoutAccountInput
    orders?: OrdersCreateNestedManyWithoutOrderCreatorInput
    sellingHistory?: SellingHistoryCreateNestedManyWithoutAccountInput
    biddingHistory?: BiddingHistoryCreateNestedManyWithoutAccountInput
    requests?: RequestCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutAuctionsInput = {
    accountID?: number
    accountType: string
    accountStatus: string
    username: string
    password: string
    userID?: number | null
    token2fa?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cars?: CarUncheckedCreateNestedManyWithoutAccountInput
    comments?: CommentUncheckedCreateNestedManyWithoutAccountInput
    orders?: OrdersUncheckedCreateNestedManyWithoutOrderCreatorInput
    sellingHistory?: SellingHistoryUncheckedCreateNestedManyWithoutAccountInput
    biddingHistory?: BiddingHistoryUncheckedCreateNestedManyWithoutAccountInput
    requests?: RequestUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutAuctionsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutAuctionsInput, AccountUncheckedCreateWithoutAuctionsInput>
  }

  export type CarCreateWithoutAuctionsInput = {
    vehicleNumber: string
    carImage?: Buffer | null
    highlights?: string | null
    equipment?: string | null
    modifications?: string | null
    knownFlaws?: string | null
    make: string
    model: string
    interiorColor?: string | null
    exteriorColor?: string | null
    startingBid: number
    reservePrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutCarsInput
  }

  export type CarUncheckedCreateWithoutAuctionsInput = {
    carID?: number
    vehicleNumber: string
    carImage?: Buffer | null
    highlights?: string | null
    equipment?: string | null
    modifications?: string | null
    knownFlaws?: string | null
    make: string
    model: string
    interiorColor?: string | null
    exteriorColor?: string | null
    startingBid: number
    reservePrice: number
    accountID: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CarCreateOrConnectWithoutAuctionsInput = {
    where: CarWhereUniqueInput
    create: XOR<CarCreateWithoutAuctionsInput, CarUncheckedCreateWithoutAuctionsInput>
  }

  export type CommentCreateWithoutAuctionInput = {
    details: string
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutAuctionInput = {
    commentID?: number
    details: string
    accountID: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutAuctionInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutAuctionInput, CommentUncheckedCreateWithoutAuctionInput>
  }

  export type CommentCreateManyAuctionInputEnvelope = {
    data: CommentCreateManyAuctionInput | CommentCreateManyAuctionInput[]
    skipDuplicates?: boolean
  }

  export type OrdersCreateWithoutAuctionInput = {
    orderStatus: string
    paymentDeadline: Date | string
    deliveryType: string
    shippingAddress?: string | null
    orderCreationTime: Date | string
    orderCompletionTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderCreator: AccountCreateNestedOneWithoutOrdersInput
    sellingHistory?: SellingHistoryCreateNestedManyWithoutOrderInput
  }

  export type OrdersUncheckedCreateWithoutAuctionInput = {
    orderID?: number
    orderStatus: string
    paymentDeadline: Date | string
    deliveryType: string
    shippingAddress?: string | null
    orderCreationTime: Date | string
    orderCompletionTime?: Date | string | null
    orderCreatorID: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sellingHistory?: SellingHistoryUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrdersCreateOrConnectWithoutAuctionInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutAuctionInput, OrdersUncheckedCreateWithoutAuctionInput>
  }

  export type OrdersCreateManyAuctionInputEnvelope = {
    data: OrdersCreateManyAuctionInput | OrdersCreateManyAuctionInput[]
    skipDuplicates?: boolean
  }

  export type BiddingHistoryCreateWithoutAuctionInput = {
    bidAmount: number
    bidTimestamp: Date | string
    bidStatus: string
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutBiddingHistoryInput
  }

  export type BiddingHistoryUncheckedCreateWithoutAuctionInput = {
    bidID?: number
    bidAmount: number
    bidTimestamp: Date | string
    bidStatus: string
    accountID: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BiddingHistoryCreateOrConnectWithoutAuctionInput = {
    where: BiddingHistoryWhereUniqueInput
    create: XOR<BiddingHistoryCreateWithoutAuctionInput, BiddingHistoryUncheckedCreateWithoutAuctionInput>
  }

  export type BiddingHistoryCreateManyAuctionInputEnvelope = {
    data: BiddingHistoryCreateManyAuctionInput | BiddingHistoryCreateManyAuctionInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutAuctionsInput = {
    update: XOR<AccountUpdateWithoutAuctionsInput, AccountUncheckedUpdateWithoutAuctionsInput>
    create: XOR<AccountCreateWithoutAuctionsInput, AccountUncheckedCreateWithoutAuctionsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutAuctionsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutAuctionsInput, AccountUncheckedUpdateWithoutAuctionsInput>
  }

  export type AccountUpdateWithoutAuctionsInput = {
    accountType?: StringFieldUpdateOperationsInput | string
    accountStatus?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    token2fa?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAccountsNestedInput
    cars?: CarUpdateManyWithoutAccountNestedInput
    comments?: CommentUpdateManyWithoutAccountNestedInput
    orders?: OrdersUpdateManyWithoutOrderCreatorNestedInput
    sellingHistory?: SellingHistoryUpdateManyWithoutAccountNestedInput
    biddingHistory?: BiddingHistoryUpdateManyWithoutAccountNestedInput
    requests?: RequestUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutAuctionsInput = {
    accountID?: IntFieldUpdateOperationsInput | number
    accountType?: StringFieldUpdateOperationsInput | string
    accountStatus?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userID?: NullableIntFieldUpdateOperationsInput | number | null
    token2fa?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cars?: CarUncheckedUpdateManyWithoutAccountNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAccountNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutOrderCreatorNestedInput
    sellingHistory?: SellingHistoryUncheckedUpdateManyWithoutAccountNestedInput
    biddingHistory?: BiddingHistoryUncheckedUpdateManyWithoutAccountNestedInput
    requests?: RequestUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type CarUpsertWithoutAuctionsInput = {
    update: XOR<CarUpdateWithoutAuctionsInput, CarUncheckedUpdateWithoutAuctionsInput>
    create: XOR<CarCreateWithoutAuctionsInput, CarUncheckedCreateWithoutAuctionsInput>
    where?: CarWhereInput
  }

  export type CarUpdateToOneWithWhereWithoutAuctionsInput = {
    where?: CarWhereInput
    data: XOR<CarUpdateWithoutAuctionsInput, CarUncheckedUpdateWithoutAuctionsInput>
  }

  export type CarUpdateWithoutAuctionsInput = {
    vehicleNumber?: StringFieldUpdateOperationsInput | string
    carImage?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    highlights?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableStringFieldUpdateOperationsInput | string | null
    knownFlaws?: NullableStringFieldUpdateOperationsInput | string | null
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    interiorColor?: NullableStringFieldUpdateOperationsInput | string | null
    exteriorColor?: NullableStringFieldUpdateOperationsInput | string | null
    startingBid?: FloatFieldUpdateOperationsInput | number
    reservePrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutCarsNestedInput
  }

  export type CarUncheckedUpdateWithoutAuctionsInput = {
    carID?: IntFieldUpdateOperationsInput | number
    vehicleNumber?: StringFieldUpdateOperationsInput | string
    carImage?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    highlights?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableStringFieldUpdateOperationsInput | string | null
    knownFlaws?: NullableStringFieldUpdateOperationsInput | string | null
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    interiorColor?: NullableStringFieldUpdateOperationsInput | string | null
    exteriorColor?: NullableStringFieldUpdateOperationsInput | string | null
    startingBid?: FloatFieldUpdateOperationsInput | number
    reservePrice?: FloatFieldUpdateOperationsInput | number
    accountID?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutAuctionInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutAuctionInput, CommentUncheckedUpdateWithoutAuctionInput>
    create: XOR<CommentCreateWithoutAuctionInput, CommentUncheckedCreateWithoutAuctionInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutAuctionInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutAuctionInput, CommentUncheckedUpdateWithoutAuctionInput>
  }

  export type CommentUpdateManyWithWhereWithoutAuctionInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutAuctionInput>
  }

  export type OrdersUpsertWithWhereUniqueWithoutAuctionInput = {
    where: OrdersWhereUniqueInput
    update: XOR<OrdersUpdateWithoutAuctionInput, OrdersUncheckedUpdateWithoutAuctionInput>
    create: XOR<OrdersCreateWithoutAuctionInput, OrdersUncheckedCreateWithoutAuctionInput>
  }

  export type OrdersUpdateWithWhereUniqueWithoutAuctionInput = {
    where: OrdersWhereUniqueInput
    data: XOR<OrdersUpdateWithoutAuctionInput, OrdersUncheckedUpdateWithoutAuctionInput>
  }

  export type OrdersUpdateManyWithWhereWithoutAuctionInput = {
    where: OrdersScalarWhereInput
    data: XOR<OrdersUpdateManyMutationInput, OrdersUncheckedUpdateManyWithoutAuctionInput>
  }

  export type BiddingHistoryUpsertWithWhereUniqueWithoutAuctionInput = {
    where: BiddingHistoryWhereUniqueInput
    update: XOR<BiddingHistoryUpdateWithoutAuctionInput, BiddingHistoryUncheckedUpdateWithoutAuctionInput>
    create: XOR<BiddingHistoryCreateWithoutAuctionInput, BiddingHistoryUncheckedCreateWithoutAuctionInput>
  }

  export type BiddingHistoryUpdateWithWhereUniqueWithoutAuctionInput = {
    where: BiddingHistoryWhereUniqueInput
    data: XOR<BiddingHistoryUpdateWithoutAuctionInput, BiddingHistoryUncheckedUpdateWithoutAuctionInput>
  }

  export type BiddingHistoryUpdateManyWithWhereWithoutAuctionInput = {
    where: BiddingHistoryScalarWhereInput
    data: XOR<BiddingHistoryUpdateManyMutationInput, BiddingHistoryUncheckedUpdateManyWithoutAuctionInput>
  }

  export type AccountCreateWithoutCommentsInput = {
    accountType: string
    accountStatus: string
    username: string
    password: string
    token2fa?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAccountsInput
    cars?: CarCreateNestedManyWithoutAccountInput
    auctions?: AuctionCreateNestedManyWithoutAuctionCreatorInput
    orders?: OrdersCreateNestedManyWithoutOrderCreatorInput
    sellingHistory?: SellingHistoryCreateNestedManyWithoutAccountInput
    biddingHistory?: BiddingHistoryCreateNestedManyWithoutAccountInput
    requests?: RequestCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutCommentsInput = {
    accountID?: number
    accountType: string
    accountStatus: string
    username: string
    password: string
    userID?: number | null
    token2fa?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cars?: CarUncheckedCreateNestedManyWithoutAccountInput
    auctions?: AuctionUncheckedCreateNestedManyWithoutAuctionCreatorInput
    orders?: OrdersUncheckedCreateNestedManyWithoutOrderCreatorInput
    sellingHistory?: SellingHistoryUncheckedCreateNestedManyWithoutAccountInput
    biddingHistory?: BiddingHistoryUncheckedCreateNestedManyWithoutAccountInput
    requests?: RequestUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutCommentsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutCommentsInput, AccountUncheckedCreateWithoutCommentsInput>
  }

  export type AuctionCreateWithoutCommentsInput = {
    auctionStatus: string
    startDate: Date | string
    endDate: Date | string
    currentHighestBid: number
    auctionCreationTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    auctionCreator: AccountCreateNestedOneWithoutAuctionsInput
    car: CarCreateNestedOneWithoutAuctionsInput
    orders?: OrdersCreateNestedManyWithoutAuctionInput
    biddingHistories?: BiddingHistoryCreateNestedManyWithoutAuctionInput
  }

  export type AuctionUncheckedCreateWithoutCommentsInput = {
    auctionID?: number
    auctionStatus: string
    startDate: Date | string
    endDate: Date | string
    currentHighestBid: number
    auctionCreationTime: Date | string
    auctionCreatorID: number
    carID: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrdersUncheckedCreateNestedManyWithoutAuctionInput
    biddingHistories?: BiddingHistoryUncheckedCreateNestedManyWithoutAuctionInput
  }

  export type AuctionCreateOrConnectWithoutCommentsInput = {
    where: AuctionWhereUniqueInput
    create: XOR<AuctionCreateWithoutCommentsInput, AuctionUncheckedCreateWithoutCommentsInput>
  }

  export type AccountUpsertWithoutCommentsInput = {
    update: XOR<AccountUpdateWithoutCommentsInput, AccountUncheckedUpdateWithoutCommentsInput>
    create: XOR<AccountCreateWithoutCommentsInput, AccountUncheckedCreateWithoutCommentsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutCommentsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutCommentsInput, AccountUncheckedUpdateWithoutCommentsInput>
  }

  export type AccountUpdateWithoutCommentsInput = {
    accountType?: StringFieldUpdateOperationsInput | string
    accountStatus?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    token2fa?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAccountsNestedInput
    cars?: CarUpdateManyWithoutAccountNestedInput
    auctions?: AuctionUpdateManyWithoutAuctionCreatorNestedInput
    orders?: OrdersUpdateManyWithoutOrderCreatorNestedInput
    sellingHistory?: SellingHistoryUpdateManyWithoutAccountNestedInput
    biddingHistory?: BiddingHistoryUpdateManyWithoutAccountNestedInput
    requests?: RequestUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutCommentsInput = {
    accountID?: IntFieldUpdateOperationsInput | number
    accountType?: StringFieldUpdateOperationsInput | string
    accountStatus?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userID?: NullableIntFieldUpdateOperationsInput | number | null
    token2fa?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cars?: CarUncheckedUpdateManyWithoutAccountNestedInput
    auctions?: AuctionUncheckedUpdateManyWithoutAuctionCreatorNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutOrderCreatorNestedInput
    sellingHistory?: SellingHistoryUncheckedUpdateManyWithoutAccountNestedInput
    biddingHistory?: BiddingHistoryUncheckedUpdateManyWithoutAccountNestedInput
    requests?: RequestUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AuctionUpsertWithoutCommentsInput = {
    update: XOR<AuctionUpdateWithoutCommentsInput, AuctionUncheckedUpdateWithoutCommentsInput>
    create: XOR<AuctionCreateWithoutCommentsInput, AuctionUncheckedCreateWithoutCommentsInput>
    where?: AuctionWhereInput
  }

  export type AuctionUpdateToOneWithWhereWithoutCommentsInput = {
    where?: AuctionWhereInput
    data: XOR<AuctionUpdateWithoutCommentsInput, AuctionUncheckedUpdateWithoutCommentsInput>
  }

  export type AuctionUpdateWithoutCommentsInput = {
    auctionStatus?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHighestBid?: FloatFieldUpdateOperationsInput | number
    auctionCreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auctionCreator?: AccountUpdateOneRequiredWithoutAuctionsNestedInput
    car?: CarUpdateOneRequiredWithoutAuctionsNestedInput
    orders?: OrdersUpdateManyWithoutAuctionNestedInput
    biddingHistories?: BiddingHistoryUpdateManyWithoutAuctionNestedInput
  }

  export type AuctionUncheckedUpdateWithoutCommentsInput = {
    auctionID?: IntFieldUpdateOperationsInput | number
    auctionStatus?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHighestBid?: FloatFieldUpdateOperationsInput | number
    auctionCreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    auctionCreatorID?: IntFieldUpdateOperationsInput | number
    carID?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrdersUncheckedUpdateManyWithoutAuctionNestedInput
    biddingHistories?: BiddingHistoryUncheckedUpdateManyWithoutAuctionNestedInput
  }

  export type AccountCreateWithoutOrdersInput = {
    accountType: string
    accountStatus: string
    username: string
    password: string
    token2fa?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAccountsInput
    cars?: CarCreateNestedManyWithoutAccountInput
    auctions?: AuctionCreateNestedManyWithoutAuctionCreatorInput
    comments?: CommentCreateNestedManyWithoutAccountInput
    sellingHistory?: SellingHistoryCreateNestedManyWithoutAccountInput
    biddingHistory?: BiddingHistoryCreateNestedManyWithoutAccountInput
    requests?: RequestCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutOrdersInput = {
    accountID?: number
    accountType: string
    accountStatus: string
    username: string
    password: string
    userID?: number | null
    token2fa?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cars?: CarUncheckedCreateNestedManyWithoutAccountInput
    auctions?: AuctionUncheckedCreateNestedManyWithoutAuctionCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAccountInput
    sellingHistory?: SellingHistoryUncheckedCreateNestedManyWithoutAccountInput
    biddingHistory?: BiddingHistoryUncheckedCreateNestedManyWithoutAccountInput
    requests?: RequestUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutOrdersInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutOrdersInput, AccountUncheckedCreateWithoutOrdersInput>
  }

  export type AuctionCreateWithoutOrdersInput = {
    auctionStatus: string
    startDate: Date | string
    endDate: Date | string
    currentHighestBid: number
    auctionCreationTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    auctionCreator: AccountCreateNestedOneWithoutAuctionsInput
    car: CarCreateNestedOneWithoutAuctionsInput
    comments?: CommentCreateNestedManyWithoutAuctionInput
    biddingHistories?: BiddingHistoryCreateNestedManyWithoutAuctionInput
  }

  export type AuctionUncheckedCreateWithoutOrdersInput = {
    auctionID?: number
    auctionStatus: string
    startDate: Date | string
    endDate: Date | string
    currentHighestBid: number
    auctionCreationTime: Date | string
    auctionCreatorID: number
    carID: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutAuctionInput
    biddingHistories?: BiddingHistoryUncheckedCreateNestedManyWithoutAuctionInput
  }

  export type AuctionCreateOrConnectWithoutOrdersInput = {
    where: AuctionWhereUniqueInput
    create: XOR<AuctionCreateWithoutOrdersInput, AuctionUncheckedCreateWithoutOrdersInput>
  }

  export type SellingHistoryCreateWithoutOrderInput = {
    account: AccountCreateNestedOneWithoutSellingHistoryInput
  }

  export type SellingHistoryUncheckedCreateWithoutOrderInput = {
    saleID?: number
    accountID: number
  }

  export type SellingHistoryCreateOrConnectWithoutOrderInput = {
    where: SellingHistoryWhereUniqueInput
    create: XOR<SellingHistoryCreateWithoutOrderInput, SellingHistoryUncheckedCreateWithoutOrderInput>
  }

  export type SellingHistoryCreateManyOrderInputEnvelope = {
    data: SellingHistoryCreateManyOrderInput | SellingHistoryCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutOrdersInput = {
    update: XOR<AccountUpdateWithoutOrdersInput, AccountUncheckedUpdateWithoutOrdersInput>
    create: XOR<AccountCreateWithoutOrdersInput, AccountUncheckedCreateWithoutOrdersInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutOrdersInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutOrdersInput, AccountUncheckedUpdateWithoutOrdersInput>
  }

  export type AccountUpdateWithoutOrdersInput = {
    accountType?: StringFieldUpdateOperationsInput | string
    accountStatus?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    token2fa?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAccountsNestedInput
    cars?: CarUpdateManyWithoutAccountNestedInput
    auctions?: AuctionUpdateManyWithoutAuctionCreatorNestedInput
    comments?: CommentUpdateManyWithoutAccountNestedInput
    sellingHistory?: SellingHistoryUpdateManyWithoutAccountNestedInput
    biddingHistory?: BiddingHistoryUpdateManyWithoutAccountNestedInput
    requests?: RequestUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutOrdersInput = {
    accountID?: IntFieldUpdateOperationsInput | number
    accountType?: StringFieldUpdateOperationsInput | string
    accountStatus?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userID?: NullableIntFieldUpdateOperationsInput | number | null
    token2fa?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cars?: CarUncheckedUpdateManyWithoutAccountNestedInput
    auctions?: AuctionUncheckedUpdateManyWithoutAuctionCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAccountNestedInput
    sellingHistory?: SellingHistoryUncheckedUpdateManyWithoutAccountNestedInput
    biddingHistory?: BiddingHistoryUncheckedUpdateManyWithoutAccountNestedInput
    requests?: RequestUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AuctionUpsertWithoutOrdersInput = {
    update: XOR<AuctionUpdateWithoutOrdersInput, AuctionUncheckedUpdateWithoutOrdersInput>
    create: XOR<AuctionCreateWithoutOrdersInput, AuctionUncheckedCreateWithoutOrdersInput>
    where?: AuctionWhereInput
  }

  export type AuctionUpdateToOneWithWhereWithoutOrdersInput = {
    where?: AuctionWhereInput
    data: XOR<AuctionUpdateWithoutOrdersInput, AuctionUncheckedUpdateWithoutOrdersInput>
  }

  export type AuctionUpdateWithoutOrdersInput = {
    auctionStatus?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHighestBid?: FloatFieldUpdateOperationsInput | number
    auctionCreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auctionCreator?: AccountUpdateOneRequiredWithoutAuctionsNestedInput
    car?: CarUpdateOneRequiredWithoutAuctionsNestedInput
    comments?: CommentUpdateManyWithoutAuctionNestedInput
    biddingHistories?: BiddingHistoryUpdateManyWithoutAuctionNestedInput
  }

  export type AuctionUncheckedUpdateWithoutOrdersInput = {
    auctionID?: IntFieldUpdateOperationsInput | number
    auctionStatus?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHighestBid?: FloatFieldUpdateOperationsInput | number
    auctionCreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    auctionCreatorID?: IntFieldUpdateOperationsInput | number
    carID?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutAuctionNestedInput
    biddingHistories?: BiddingHistoryUncheckedUpdateManyWithoutAuctionNestedInput
  }

  export type SellingHistoryUpsertWithWhereUniqueWithoutOrderInput = {
    where: SellingHistoryWhereUniqueInput
    update: XOR<SellingHistoryUpdateWithoutOrderInput, SellingHistoryUncheckedUpdateWithoutOrderInput>
    create: XOR<SellingHistoryCreateWithoutOrderInput, SellingHistoryUncheckedCreateWithoutOrderInput>
  }

  export type SellingHistoryUpdateWithWhereUniqueWithoutOrderInput = {
    where: SellingHistoryWhereUniqueInput
    data: XOR<SellingHistoryUpdateWithoutOrderInput, SellingHistoryUncheckedUpdateWithoutOrderInput>
  }

  export type SellingHistoryUpdateManyWithWhereWithoutOrderInput = {
    where: SellingHistoryScalarWhereInput
    data: XOR<SellingHistoryUpdateManyMutationInput, SellingHistoryUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrdersCreateWithoutSellingHistoryInput = {
    orderStatus: string
    paymentDeadline: Date | string
    deliveryType: string
    shippingAddress?: string | null
    orderCreationTime: Date | string
    orderCompletionTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderCreator: AccountCreateNestedOneWithoutOrdersInput
    auction: AuctionCreateNestedOneWithoutOrdersInput
  }

  export type OrdersUncheckedCreateWithoutSellingHistoryInput = {
    orderID?: number
    orderStatus: string
    paymentDeadline: Date | string
    deliveryType: string
    shippingAddress?: string | null
    orderCreationTime: Date | string
    orderCompletionTime?: Date | string | null
    orderCreatorID: number
    auctionID: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrdersCreateOrConnectWithoutSellingHistoryInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutSellingHistoryInput, OrdersUncheckedCreateWithoutSellingHistoryInput>
  }

  export type AccountCreateWithoutSellingHistoryInput = {
    accountType: string
    accountStatus: string
    username: string
    password: string
    token2fa?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAccountsInput
    cars?: CarCreateNestedManyWithoutAccountInput
    auctions?: AuctionCreateNestedManyWithoutAuctionCreatorInput
    comments?: CommentCreateNestedManyWithoutAccountInput
    orders?: OrdersCreateNestedManyWithoutOrderCreatorInput
    biddingHistory?: BiddingHistoryCreateNestedManyWithoutAccountInput
    requests?: RequestCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutSellingHistoryInput = {
    accountID?: number
    accountType: string
    accountStatus: string
    username: string
    password: string
    userID?: number | null
    token2fa?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cars?: CarUncheckedCreateNestedManyWithoutAccountInput
    auctions?: AuctionUncheckedCreateNestedManyWithoutAuctionCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAccountInput
    orders?: OrdersUncheckedCreateNestedManyWithoutOrderCreatorInput
    biddingHistory?: BiddingHistoryUncheckedCreateNestedManyWithoutAccountInput
    requests?: RequestUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutSellingHistoryInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutSellingHistoryInput, AccountUncheckedCreateWithoutSellingHistoryInput>
  }

  export type OrdersUpsertWithoutSellingHistoryInput = {
    update: XOR<OrdersUpdateWithoutSellingHistoryInput, OrdersUncheckedUpdateWithoutSellingHistoryInput>
    create: XOR<OrdersCreateWithoutSellingHistoryInput, OrdersUncheckedCreateWithoutSellingHistoryInput>
    where?: OrdersWhereInput
  }

  export type OrdersUpdateToOneWithWhereWithoutSellingHistoryInput = {
    where?: OrdersWhereInput
    data: XOR<OrdersUpdateWithoutSellingHistoryInput, OrdersUncheckedUpdateWithoutSellingHistoryInput>
  }

  export type OrdersUpdateWithoutSellingHistoryInput = {
    orderStatus?: StringFieldUpdateOperationsInput | string
    paymentDeadline?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryType?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    orderCreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    orderCompletionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderCreator?: AccountUpdateOneRequiredWithoutOrdersNestedInput
    auction?: AuctionUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrdersUncheckedUpdateWithoutSellingHistoryInput = {
    orderID?: IntFieldUpdateOperationsInput | number
    orderStatus?: StringFieldUpdateOperationsInput | string
    paymentDeadline?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryType?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    orderCreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    orderCompletionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderCreatorID?: IntFieldUpdateOperationsInput | number
    auctionID?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpsertWithoutSellingHistoryInput = {
    update: XOR<AccountUpdateWithoutSellingHistoryInput, AccountUncheckedUpdateWithoutSellingHistoryInput>
    create: XOR<AccountCreateWithoutSellingHistoryInput, AccountUncheckedCreateWithoutSellingHistoryInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutSellingHistoryInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutSellingHistoryInput, AccountUncheckedUpdateWithoutSellingHistoryInput>
  }

  export type AccountUpdateWithoutSellingHistoryInput = {
    accountType?: StringFieldUpdateOperationsInput | string
    accountStatus?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    token2fa?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAccountsNestedInput
    cars?: CarUpdateManyWithoutAccountNestedInput
    auctions?: AuctionUpdateManyWithoutAuctionCreatorNestedInput
    comments?: CommentUpdateManyWithoutAccountNestedInput
    orders?: OrdersUpdateManyWithoutOrderCreatorNestedInput
    biddingHistory?: BiddingHistoryUpdateManyWithoutAccountNestedInput
    requests?: RequestUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutSellingHistoryInput = {
    accountID?: IntFieldUpdateOperationsInput | number
    accountType?: StringFieldUpdateOperationsInput | string
    accountStatus?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userID?: NullableIntFieldUpdateOperationsInput | number | null
    token2fa?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cars?: CarUncheckedUpdateManyWithoutAccountNestedInput
    auctions?: AuctionUncheckedUpdateManyWithoutAuctionCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAccountNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutOrderCreatorNestedInput
    biddingHistory?: BiddingHistoryUncheckedUpdateManyWithoutAccountNestedInput
    requests?: RequestUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountCreateWithoutBiddingHistoryInput = {
    accountType: string
    accountStatus: string
    username: string
    password: string
    token2fa?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAccountsInput
    cars?: CarCreateNestedManyWithoutAccountInput
    auctions?: AuctionCreateNestedManyWithoutAuctionCreatorInput
    comments?: CommentCreateNestedManyWithoutAccountInput
    orders?: OrdersCreateNestedManyWithoutOrderCreatorInput
    sellingHistory?: SellingHistoryCreateNestedManyWithoutAccountInput
    requests?: RequestCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutBiddingHistoryInput = {
    accountID?: number
    accountType: string
    accountStatus: string
    username: string
    password: string
    userID?: number | null
    token2fa?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cars?: CarUncheckedCreateNestedManyWithoutAccountInput
    auctions?: AuctionUncheckedCreateNestedManyWithoutAuctionCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAccountInput
    orders?: OrdersUncheckedCreateNestedManyWithoutOrderCreatorInput
    sellingHistory?: SellingHistoryUncheckedCreateNestedManyWithoutAccountInput
    requests?: RequestUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutBiddingHistoryInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutBiddingHistoryInput, AccountUncheckedCreateWithoutBiddingHistoryInput>
  }

  export type AuctionCreateWithoutBiddingHistoriesInput = {
    auctionStatus: string
    startDate: Date | string
    endDate: Date | string
    currentHighestBid: number
    auctionCreationTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    auctionCreator: AccountCreateNestedOneWithoutAuctionsInput
    car: CarCreateNestedOneWithoutAuctionsInput
    comments?: CommentCreateNestedManyWithoutAuctionInput
    orders?: OrdersCreateNestedManyWithoutAuctionInput
  }

  export type AuctionUncheckedCreateWithoutBiddingHistoriesInput = {
    auctionID?: number
    auctionStatus: string
    startDate: Date | string
    endDate: Date | string
    currentHighestBid: number
    auctionCreationTime: Date | string
    auctionCreatorID: number
    carID: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutAuctionInput
    orders?: OrdersUncheckedCreateNestedManyWithoutAuctionInput
  }

  export type AuctionCreateOrConnectWithoutBiddingHistoriesInput = {
    where: AuctionWhereUniqueInput
    create: XOR<AuctionCreateWithoutBiddingHistoriesInput, AuctionUncheckedCreateWithoutBiddingHistoriesInput>
  }

  export type AccountUpsertWithoutBiddingHistoryInput = {
    update: XOR<AccountUpdateWithoutBiddingHistoryInput, AccountUncheckedUpdateWithoutBiddingHistoryInput>
    create: XOR<AccountCreateWithoutBiddingHistoryInput, AccountUncheckedCreateWithoutBiddingHistoryInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutBiddingHistoryInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutBiddingHistoryInput, AccountUncheckedUpdateWithoutBiddingHistoryInput>
  }

  export type AccountUpdateWithoutBiddingHistoryInput = {
    accountType?: StringFieldUpdateOperationsInput | string
    accountStatus?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    token2fa?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAccountsNestedInput
    cars?: CarUpdateManyWithoutAccountNestedInput
    auctions?: AuctionUpdateManyWithoutAuctionCreatorNestedInput
    comments?: CommentUpdateManyWithoutAccountNestedInput
    orders?: OrdersUpdateManyWithoutOrderCreatorNestedInput
    sellingHistory?: SellingHistoryUpdateManyWithoutAccountNestedInput
    requests?: RequestUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutBiddingHistoryInput = {
    accountID?: IntFieldUpdateOperationsInput | number
    accountType?: StringFieldUpdateOperationsInput | string
    accountStatus?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userID?: NullableIntFieldUpdateOperationsInput | number | null
    token2fa?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cars?: CarUncheckedUpdateManyWithoutAccountNestedInput
    auctions?: AuctionUncheckedUpdateManyWithoutAuctionCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAccountNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutOrderCreatorNestedInput
    sellingHistory?: SellingHistoryUncheckedUpdateManyWithoutAccountNestedInput
    requests?: RequestUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AuctionUpsertWithoutBiddingHistoriesInput = {
    update: XOR<AuctionUpdateWithoutBiddingHistoriesInput, AuctionUncheckedUpdateWithoutBiddingHistoriesInput>
    create: XOR<AuctionCreateWithoutBiddingHistoriesInput, AuctionUncheckedCreateWithoutBiddingHistoriesInput>
    where?: AuctionWhereInput
  }

  export type AuctionUpdateToOneWithWhereWithoutBiddingHistoriesInput = {
    where?: AuctionWhereInput
    data: XOR<AuctionUpdateWithoutBiddingHistoriesInput, AuctionUncheckedUpdateWithoutBiddingHistoriesInput>
  }

  export type AuctionUpdateWithoutBiddingHistoriesInput = {
    auctionStatus?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHighestBid?: FloatFieldUpdateOperationsInput | number
    auctionCreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auctionCreator?: AccountUpdateOneRequiredWithoutAuctionsNestedInput
    car?: CarUpdateOneRequiredWithoutAuctionsNestedInput
    comments?: CommentUpdateManyWithoutAuctionNestedInput
    orders?: OrdersUpdateManyWithoutAuctionNestedInput
  }

  export type AuctionUncheckedUpdateWithoutBiddingHistoriesInput = {
    auctionID?: IntFieldUpdateOperationsInput | number
    auctionStatus?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHighestBid?: FloatFieldUpdateOperationsInput | number
    auctionCreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    auctionCreatorID?: IntFieldUpdateOperationsInput | number
    carID?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutAuctionNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutAuctionNestedInput
  }

  export type AccountCreateWithoutRequestsInput = {
    accountType: string
    accountStatus: string
    username: string
    password: string
    token2fa?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutAccountsInput
    cars?: CarCreateNestedManyWithoutAccountInput
    auctions?: AuctionCreateNestedManyWithoutAuctionCreatorInput
    comments?: CommentCreateNestedManyWithoutAccountInput
    orders?: OrdersCreateNestedManyWithoutOrderCreatorInput
    sellingHistory?: SellingHistoryCreateNestedManyWithoutAccountInput
    biddingHistory?: BiddingHistoryCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutRequestsInput = {
    accountID?: number
    accountType: string
    accountStatus: string
    username: string
    password: string
    userID?: number | null
    token2fa?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cars?: CarUncheckedCreateNestedManyWithoutAccountInput
    auctions?: AuctionUncheckedCreateNestedManyWithoutAuctionCreatorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAccountInput
    orders?: OrdersUncheckedCreateNestedManyWithoutOrderCreatorInput
    sellingHistory?: SellingHistoryUncheckedCreateNestedManyWithoutAccountInput
    biddingHistory?: BiddingHistoryUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutRequestsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutRequestsInput, AccountUncheckedCreateWithoutRequestsInput>
  }

  export type AccountUpsertWithoutRequestsInput = {
    update: XOR<AccountUpdateWithoutRequestsInput, AccountUncheckedUpdateWithoutRequestsInput>
    create: XOR<AccountCreateWithoutRequestsInput, AccountUncheckedCreateWithoutRequestsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutRequestsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutRequestsInput, AccountUncheckedUpdateWithoutRequestsInput>
  }

  export type AccountUpdateWithoutRequestsInput = {
    accountType?: StringFieldUpdateOperationsInput | string
    accountStatus?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    token2fa?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAccountsNestedInput
    cars?: CarUpdateManyWithoutAccountNestedInput
    auctions?: AuctionUpdateManyWithoutAuctionCreatorNestedInput
    comments?: CommentUpdateManyWithoutAccountNestedInput
    orders?: OrdersUpdateManyWithoutOrderCreatorNestedInput
    sellingHistory?: SellingHistoryUpdateManyWithoutAccountNestedInput
    biddingHistory?: BiddingHistoryUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutRequestsInput = {
    accountID?: IntFieldUpdateOperationsInput | number
    accountType?: StringFieldUpdateOperationsInput | string
    accountStatus?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    userID?: NullableIntFieldUpdateOperationsInput | number | null
    token2fa?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cars?: CarUncheckedUpdateManyWithoutAccountNestedInput
    auctions?: AuctionUncheckedUpdateManyWithoutAuctionCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAccountNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutOrderCreatorNestedInput
    sellingHistory?: SellingHistoryUncheckedUpdateManyWithoutAccountNestedInput
    biddingHistory?: BiddingHistoryUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountCreateManyUserInput = {
    accountID?: number
    accountType: string
    accountStatus: string
    username: string
    password: string
    token2fa?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    accountType?: StringFieldUpdateOperationsInput | string
    accountStatus?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    token2fa?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cars?: CarUpdateManyWithoutAccountNestedInput
    auctions?: AuctionUpdateManyWithoutAuctionCreatorNestedInput
    comments?: CommentUpdateManyWithoutAccountNestedInput
    orders?: OrdersUpdateManyWithoutOrderCreatorNestedInput
    sellingHistory?: SellingHistoryUpdateManyWithoutAccountNestedInput
    biddingHistory?: BiddingHistoryUpdateManyWithoutAccountNestedInput
    requests?: RequestUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    accountID?: IntFieldUpdateOperationsInput | number
    accountType?: StringFieldUpdateOperationsInput | string
    accountStatus?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    token2fa?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cars?: CarUncheckedUpdateManyWithoutAccountNestedInput
    auctions?: AuctionUncheckedUpdateManyWithoutAuctionCreatorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAccountNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutOrderCreatorNestedInput
    sellingHistory?: SellingHistoryUncheckedUpdateManyWithoutAccountNestedInput
    biddingHistory?: BiddingHistoryUncheckedUpdateManyWithoutAccountNestedInput
    requests?: RequestUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    accountID?: IntFieldUpdateOperationsInput | number
    accountType?: StringFieldUpdateOperationsInput | string
    accountStatus?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    token2fa?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CarCreateManyAccountInput = {
    carID?: number
    vehicleNumber: string
    carImage?: Buffer | null
    highlights?: string | null
    equipment?: string | null
    modifications?: string | null
    knownFlaws?: string | null
    make: string
    model: string
    interiorColor?: string | null
    exteriorColor?: string | null
    startingBid: number
    reservePrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuctionCreateManyAuctionCreatorInput = {
    auctionID?: number
    auctionStatus: string
    startDate: Date | string
    endDate: Date | string
    currentHighestBid: number
    auctionCreationTime: Date | string
    carID: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyAccountInput = {
    commentID?: number
    details: string
    auctionID: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrdersCreateManyOrderCreatorInput = {
    orderID?: number
    orderStatus: string
    paymentDeadline: Date | string
    deliveryType: string
    shippingAddress?: string | null
    orderCreationTime: Date | string
    orderCompletionTime?: Date | string | null
    auctionID: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellingHistoryCreateManyAccountInput = {
    saleID?: number
    orderID: number
  }

  export type BiddingHistoryCreateManyAccountInput = {
    bidID?: number
    bidAmount: number
    bidTimestamp: Date | string
    bidStatus: string
    auctionID: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequestCreateManyAccountInput = {
    requestID?: number
    requestStatus: string
    submissionTime: Date | string
    vehicleNumber: string
    carImage: Buffer
    highlights?: string | null
    equipment?: string | null
    modifications?: string | null
    knownFlaws?: string | null
    make: string
    model: string
    interiorColor?: string | null
    exteriorColor?: string | null
    startingBid: number
    reservePrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CarUpdateWithoutAccountInput = {
    vehicleNumber?: StringFieldUpdateOperationsInput | string
    carImage?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    highlights?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableStringFieldUpdateOperationsInput | string | null
    knownFlaws?: NullableStringFieldUpdateOperationsInput | string | null
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    interiorColor?: NullableStringFieldUpdateOperationsInput | string | null
    exteriorColor?: NullableStringFieldUpdateOperationsInput | string | null
    startingBid?: FloatFieldUpdateOperationsInput | number
    reservePrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auctions?: AuctionUpdateManyWithoutCarNestedInput
  }

  export type CarUncheckedUpdateWithoutAccountInput = {
    carID?: IntFieldUpdateOperationsInput | number
    vehicleNumber?: StringFieldUpdateOperationsInput | string
    carImage?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    highlights?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableStringFieldUpdateOperationsInput | string | null
    knownFlaws?: NullableStringFieldUpdateOperationsInput | string | null
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    interiorColor?: NullableStringFieldUpdateOperationsInput | string | null
    exteriorColor?: NullableStringFieldUpdateOperationsInput | string | null
    startingBid?: FloatFieldUpdateOperationsInput | number
    reservePrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auctions?: AuctionUncheckedUpdateManyWithoutCarNestedInput
  }

  export type CarUncheckedUpdateManyWithoutAccountInput = {
    carID?: IntFieldUpdateOperationsInput | number
    vehicleNumber?: StringFieldUpdateOperationsInput | string
    carImage?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    highlights?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableStringFieldUpdateOperationsInput | string | null
    knownFlaws?: NullableStringFieldUpdateOperationsInput | string | null
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    interiorColor?: NullableStringFieldUpdateOperationsInput | string | null
    exteriorColor?: NullableStringFieldUpdateOperationsInput | string | null
    startingBid?: FloatFieldUpdateOperationsInput | number
    reservePrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionUpdateWithoutAuctionCreatorInput = {
    auctionStatus?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHighestBid?: FloatFieldUpdateOperationsInput | number
    auctionCreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    car?: CarUpdateOneRequiredWithoutAuctionsNestedInput
    comments?: CommentUpdateManyWithoutAuctionNestedInput
    orders?: OrdersUpdateManyWithoutAuctionNestedInput
    biddingHistories?: BiddingHistoryUpdateManyWithoutAuctionNestedInput
  }

  export type AuctionUncheckedUpdateWithoutAuctionCreatorInput = {
    auctionID?: IntFieldUpdateOperationsInput | number
    auctionStatus?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHighestBid?: FloatFieldUpdateOperationsInput | number
    auctionCreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    carID?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutAuctionNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutAuctionNestedInput
    biddingHistories?: BiddingHistoryUncheckedUpdateManyWithoutAuctionNestedInput
  }

  export type AuctionUncheckedUpdateManyWithoutAuctionCreatorInput = {
    auctionID?: IntFieldUpdateOperationsInput | number
    auctionStatus?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHighestBid?: FloatFieldUpdateOperationsInput | number
    auctionCreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    carID?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutAccountInput = {
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auction?: AuctionUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutAccountInput = {
    commentID?: IntFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
    auctionID?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutAccountInput = {
    commentID?: IntFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
    auctionID?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrdersUpdateWithoutOrderCreatorInput = {
    orderStatus?: StringFieldUpdateOperationsInput | string
    paymentDeadline?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryType?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    orderCreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    orderCompletionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auction?: AuctionUpdateOneRequiredWithoutOrdersNestedInput
    sellingHistory?: SellingHistoryUpdateManyWithoutOrderNestedInput
  }

  export type OrdersUncheckedUpdateWithoutOrderCreatorInput = {
    orderID?: IntFieldUpdateOperationsInput | number
    orderStatus?: StringFieldUpdateOperationsInput | string
    paymentDeadline?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryType?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    orderCreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    orderCompletionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auctionID?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sellingHistory?: SellingHistoryUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrdersUncheckedUpdateManyWithoutOrderCreatorInput = {
    orderID?: IntFieldUpdateOperationsInput | number
    orderStatus?: StringFieldUpdateOperationsInput | string
    paymentDeadline?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryType?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    orderCreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    orderCompletionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auctionID?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellingHistoryUpdateWithoutAccountInput = {
    order?: OrdersUpdateOneRequiredWithoutSellingHistoryNestedInput
  }

  export type SellingHistoryUncheckedUpdateWithoutAccountInput = {
    saleID?: IntFieldUpdateOperationsInput | number
    orderID?: IntFieldUpdateOperationsInput | number
  }

  export type SellingHistoryUncheckedUpdateManyWithoutAccountInput = {
    saleID?: IntFieldUpdateOperationsInput | number
    orderID?: IntFieldUpdateOperationsInput | number
  }

  export type BiddingHistoryUpdateWithoutAccountInput = {
    bidAmount?: FloatFieldUpdateOperationsInput | number
    bidTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    bidStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auction?: AuctionUpdateOneRequiredWithoutBiddingHistoriesNestedInput
  }

  export type BiddingHistoryUncheckedUpdateWithoutAccountInput = {
    bidID?: IntFieldUpdateOperationsInput | number
    bidAmount?: FloatFieldUpdateOperationsInput | number
    bidTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    bidStatus?: StringFieldUpdateOperationsInput | string
    auctionID?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiddingHistoryUncheckedUpdateManyWithoutAccountInput = {
    bidID?: IntFieldUpdateOperationsInput | number
    bidAmount?: FloatFieldUpdateOperationsInput | number
    bidTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    bidStatus?: StringFieldUpdateOperationsInput | string
    auctionID?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestUpdateWithoutAccountInput = {
    requestStatus?: StringFieldUpdateOperationsInput | string
    submissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleNumber?: StringFieldUpdateOperationsInput | string
    carImage?: BytesFieldUpdateOperationsInput | Buffer
    highlights?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableStringFieldUpdateOperationsInput | string | null
    knownFlaws?: NullableStringFieldUpdateOperationsInput | string | null
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    interiorColor?: NullableStringFieldUpdateOperationsInput | string | null
    exteriorColor?: NullableStringFieldUpdateOperationsInput | string | null
    startingBid?: FloatFieldUpdateOperationsInput | number
    reservePrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestUncheckedUpdateWithoutAccountInput = {
    requestID?: IntFieldUpdateOperationsInput | number
    requestStatus?: StringFieldUpdateOperationsInput | string
    submissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleNumber?: StringFieldUpdateOperationsInput | string
    carImage?: BytesFieldUpdateOperationsInput | Buffer
    highlights?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableStringFieldUpdateOperationsInput | string | null
    knownFlaws?: NullableStringFieldUpdateOperationsInput | string | null
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    interiorColor?: NullableStringFieldUpdateOperationsInput | string | null
    exteriorColor?: NullableStringFieldUpdateOperationsInput | string | null
    startingBid?: FloatFieldUpdateOperationsInput | number
    reservePrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestUncheckedUpdateManyWithoutAccountInput = {
    requestID?: IntFieldUpdateOperationsInput | number
    requestStatus?: StringFieldUpdateOperationsInput | string
    submissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicleNumber?: StringFieldUpdateOperationsInput | string
    carImage?: BytesFieldUpdateOperationsInput | Buffer
    highlights?: NullableStringFieldUpdateOperationsInput | string | null
    equipment?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: NullableStringFieldUpdateOperationsInput | string | null
    knownFlaws?: NullableStringFieldUpdateOperationsInput | string | null
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    interiorColor?: NullableStringFieldUpdateOperationsInput | string | null
    exteriorColor?: NullableStringFieldUpdateOperationsInput | string | null
    startingBid?: FloatFieldUpdateOperationsInput | number
    reservePrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionCreateManyCarInput = {
    auctionID?: number
    auctionStatus: string
    startDate: Date | string
    endDate: Date | string
    currentHighestBid: number
    auctionCreationTime: Date | string
    auctionCreatorID: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuctionUpdateWithoutCarInput = {
    auctionStatus?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHighestBid?: FloatFieldUpdateOperationsInput | number
    auctionCreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auctionCreator?: AccountUpdateOneRequiredWithoutAuctionsNestedInput
    comments?: CommentUpdateManyWithoutAuctionNestedInput
    orders?: OrdersUpdateManyWithoutAuctionNestedInput
    biddingHistories?: BiddingHistoryUpdateManyWithoutAuctionNestedInput
  }

  export type AuctionUncheckedUpdateWithoutCarInput = {
    auctionID?: IntFieldUpdateOperationsInput | number
    auctionStatus?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHighestBid?: FloatFieldUpdateOperationsInput | number
    auctionCreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    auctionCreatorID?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutAuctionNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutAuctionNestedInput
    biddingHistories?: BiddingHistoryUncheckedUpdateManyWithoutAuctionNestedInput
  }

  export type AuctionUncheckedUpdateManyWithoutCarInput = {
    auctionID?: IntFieldUpdateOperationsInput | number
    auctionStatus?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    currentHighestBid?: FloatFieldUpdateOperationsInput | number
    auctionCreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    auctionCreatorID?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyAuctionInput = {
    commentID?: number
    details: string
    accountID: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrdersCreateManyAuctionInput = {
    orderID?: number
    orderStatus: string
    paymentDeadline: Date | string
    deliveryType: string
    shippingAddress?: string | null
    orderCreationTime: Date | string
    orderCompletionTime?: Date | string | null
    orderCreatorID: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BiddingHistoryCreateManyAuctionInput = {
    bidID?: number
    bidAmount: number
    bidTimestamp: Date | string
    bidStatus: string
    accountID: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateWithoutAuctionInput = {
    details?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutAuctionInput = {
    commentID?: IntFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
    accountID?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutAuctionInput = {
    commentID?: IntFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
    accountID?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrdersUpdateWithoutAuctionInput = {
    orderStatus?: StringFieldUpdateOperationsInput | string
    paymentDeadline?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryType?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    orderCreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    orderCompletionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderCreator?: AccountUpdateOneRequiredWithoutOrdersNestedInput
    sellingHistory?: SellingHistoryUpdateManyWithoutOrderNestedInput
  }

  export type OrdersUncheckedUpdateWithoutAuctionInput = {
    orderID?: IntFieldUpdateOperationsInput | number
    orderStatus?: StringFieldUpdateOperationsInput | string
    paymentDeadline?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryType?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    orderCreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    orderCompletionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderCreatorID?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sellingHistory?: SellingHistoryUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrdersUncheckedUpdateManyWithoutAuctionInput = {
    orderID?: IntFieldUpdateOperationsInput | number
    orderStatus?: StringFieldUpdateOperationsInput | string
    paymentDeadline?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryType?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableStringFieldUpdateOperationsInput | string | null
    orderCreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    orderCompletionTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderCreatorID?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiddingHistoryUpdateWithoutAuctionInput = {
    bidAmount?: FloatFieldUpdateOperationsInput | number
    bidTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    bidStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutBiddingHistoryNestedInput
  }

  export type BiddingHistoryUncheckedUpdateWithoutAuctionInput = {
    bidID?: IntFieldUpdateOperationsInput | number
    bidAmount?: FloatFieldUpdateOperationsInput | number
    bidTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    bidStatus?: StringFieldUpdateOperationsInput | string
    accountID?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiddingHistoryUncheckedUpdateManyWithoutAuctionInput = {
    bidID?: IntFieldUpdateOperationsInput | number
    bidAmount?: FloatFieldUpdateOperationsInput | number
    bidTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    bidStatus?: StringFieldUpdateOperationsInput | string
    accountID?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellingHistoryCreateManyOrderInput = {
    saleID?: number
    accountID: number
  }

  export type SellingHistoryUpdateWithoutOrderInput = {
    account?: AccountUpdateOneRequiredWithoutSellingHistoryNestedInput
  }

  export type SellingHistoryUncheckedUpdateWithoutOrderInput = {
    saleID?: IntFieldUpdateOperationsInput | number
    accountID?: IntFieldUpdateOperationsInput | number
  }

  export type SellingHistoryUncheckedUpdateManyWithoutOrderInput = {
    saleID?: IntFieldUpdateOperationsInput | number
    accountID?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountCountOutputTypeDefaultArgs instead
     */
    export type AccountCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CarCountOutputTypeDefaultArgs instead
     */
    export type CarCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CarCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuctionCountOutputTypeDefaultArgs instead
     */
    export type AuctionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuctionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrdersCountOutputTypeDefaultArgs instead
     */
    export type OrdersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrdersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountDefaultArgs instead
     */
    export type AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CarDefaultArgs instead
     */
    export type CarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CarDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuctionDefaultArgs instead
     */
    export type AuctionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuctionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentDefaultArgs instead
     */
    export type CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrdersDefaultArgs instead
     */
    export type OrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrdersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SellingHistoryDefaultArgs instead
     */
    export type SellingHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SellingHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BiddingHistoryDefaultArgs instead
     */
    export type BiddingHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BiddingHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RequestDefaultArgs instead
     */
    export type RequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FAQDefaultArgs instead
     */
    export type FAQArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FAQDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}